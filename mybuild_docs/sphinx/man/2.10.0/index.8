.\" Man page generated from reStructuredText.
.
.TH "INDEX" "8" "Nov 22, 2023" "2.10.0" "OPAE"
.SH NAME
index \- Manual page index
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.sp
The main documentation for the site is organized into following sections:
.INDENT 0.0
.IP \(bu 2
\fI\%OPAE User Guides\fP
.IP \(bu 2
\fI\%OPAE Libraries\fP
.IP \(bu 2
\fI\%OPAE Linux Kernel Drivers\fP
.IP \(bu 2
\fI\%OPAE FPGA Tools\fP
.UNINDENT
.SH QUICK START GUIDE
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Overview
.sp
The OPAE C library is a lightweight user\-space library that provides
an abstraction for FPGA resources in a compute environment. Built on top of the
OPAE Intel® FPGA driver stack that supports Intel® FPGA platforms, the library
abstracts away hardware\-specific and OS\-specific details and exposes the
underlying FPGA resources as a set of features accessible from within
software programs running on the host.
.sp
These features include the acceleration logic preconfigured on the
device, as well as functions to manage and reconfigure the
device. Hence, the library can enable user applications to
transparently and seamlessly leverage FPGA\-based acceleration.
.sp
In this document, we will explore the initial steps on how to set up
the required libraries and utilities to use the FPGA devices.
.sp
If you do not have access to an Intel® Xeon® processor with integrated
FPGA, or a programmable FPGA acceleration card for Intel® Xeon®
processors, you will not be able to run the examples below. However, you can
still make use of the AFU simulation environment (ASE) to develop and test
accelerator RTL with OPAE applications.
.sp
The source for the OPAE SDK Linux device drivers is available at the
\fI\%OPAE Linux DFL drivers repository\fP\&.
.SS Build the OPAE Linux device drivers from the source
.sp
For building the OPAE kernel and kernel driver, the kernel development environment is required. So before you build the kernel, you must install the required packages. Run the following commands (we are using Fedora 32 as an example):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sudo yum install gcc gcc\-c++ make kernel\-headers kernel\-devel elfutils\-libelf\-devel ncurses\-devel openssl\-devel bison flex
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Download the OPAE upstream kernel tree from GitHub:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git clone https://github.com/OPAE/linux\-dfl.git \-b fpga\-upstream\-dev\-5.8.0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Configure the kernel:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cd linux\-dfl
cp /boot/config\-\(gauname \-r\(ga .config
cat configs/n3000_d5005_defconfig >> .config 
echo \(aqCONFIG_LOCALVERSION="\-dfl"\(aq >> .config
echo \(aqCONFIG_LOCALVERSION_AUTO=y\(aq >> .config
make olddefconfig
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Compile and install the new kernel:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
make \-j
sudo make modules_install
sudo make install
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
After the installation finishes, reboot your system.
Log back into the system, and confirm the correct version for the kernel:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ uname \-a
Linux localhost.localdomain 5.8.0\-rc1\-dfl\-g73e16386cda0 #6 SMP Wed Aug 19 08:38:32 EDT 2020 x86_64 x86_64 x86_64 GNU/Linux
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Building and installing the OPAE SDK from the source
.sp
Download the OPAE SDK source package:
.INDENT 0.0
.IP \(bu 2
Go to the section corresponding to the desired release on
\fI\%GitHub\fP:
.IP \(bu 2
Click the \fBSource code (tar.gz)\fP link under the section’s \fBAssets\fP\&.
.IP \(bu 2
On the command line, go through the following steps to install it:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
# Unpack
tar xfvz opae\-sdk\-<release>.tar.gz
# Configure
cd opae\-sdk\-<release>
mkdir build
cd build
# The default installation prefix is \(ga/usr/local\(ga;
# You have the option to configure for a different location
cmake [\-DCMAKE_INSTALL_PREFIX=<prefix>] ..
# Compile
make
# Install: you need system administration privileges (\(gasudo\(ga)
# if you have elected to install in the default location
[sudo] make install
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The remainder of this guide assumes you installed into \fB/usr/local\fP\&.
.SS Configuring the FPGA (loading an FPGA AFU)
.sp
The \fBfpgaconf\fP tool exercises the AFU reconfiguration
functionality. It shows how to read a bitstream from a disk file,
check its validity and compatibility, and then injects it into FPGA to
be configured as a new AFU, which can then be discovered and used by
user applications.
.sp
For this step, you require a valid green bitstream (GBS) file. To
reconfigure the FPGA slot, you can issue the following command as system
administrator:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sudo fpgaconf \-b 0x5e <filename>.gbs
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fB\-b\fP option to \fBfpgaconf\fP indicates the \fItarget bus number\fP of the
FPGA slot to be reconfigured. Alternatively, you can also specify the
\fItarget socket number\fP of the FPGA using the \fB\-s\fP option.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo fpgaconf \-\-help
Usage:
        fpgaconf [\-hvn] [\-b <bus>] [\-d <device>] [\-f <function>] [\-s <socket>] <gbs>

                \-h,\-\-help           Print this help
                \-v,\-\-verbose        Increase verbosity
                \-n,\-\-dry\-run        Don\(aqt actually perform actions
                \-b,\-\-bus            Set target bus number
                \-d,\-\-device         Set target device number
                \-f,\-\-function       Set target function number
                \-s,\-\-socket         Set target socket number
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
The sample application on the Building a Sample Application
section requires loading of an AFU called "Native Loopback
Adapter" (NLB) on the FPGA. Please refer to the NLB documentation
for the location of the NLB\(aqs green bitstream. You also can verify
if the NLB green bitstream has already been loaded into the FPGA
slot by typing the following command and checking the output
matches the following:

\(ga\(ga\(gabash
$ cat /sys/class/fpga_region/region0/dfl\-port.0/afu_id
d8424dc4a4a3c413f89e433683f9040b
\(ga\(ga\(ga
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
The fpgaconf tool is not available for the Intel PAC N3000. The NLB is
already included in the AFU.
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Building a sample application
.sp
The library source includes code samples. Use these samples to learn
how to call functions in the library. Build and run these samples as
quick sanity checks to determine if your installation and environment
are set up properly.
.sp
In this guide, we will build \fBhello_fpga.c\fP\&. This is the “Hello
World!” example of using the library.  This code searches for a
predefined and known AFU called “Native Loopback Adapter” on the
FPGA. If found, it acquires ownership and then interacts with the AFU
by sending it a 2MB message and waiting for the message to be echoed
back. This code exercises all major components of the API except for
AFU reconfiguration: AFU search, enumeration, access, MMIO, and memory
management.
.sp
You can also find the source for \fBhello_fpga\fP in the \fBsamples\fP directory of the
OPAE SDK repository on GitHub.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    int main(int argc, char *argv[])
    {
        fpga_properties    filter = NULL;
        fpga_token         afu_token;
        fpga_handle        afu_handle;
        fpga_guid          guid;
        uint32_t           num_matches;

        volatile uint64_t *dsm_ptr    = NULL;
        volatile uint64_t *status_ptr = NULL;
        volatile uint64_t *input_ptr  = NULL;
        volatile uint64_t *output_ptr = NULL;

        uint64_t        dsm_wsid;
        uint64_t        input_wsid;
        uint64_t        output_wsid;
        fpga_result     res = FPGA_OK;

        if (uuid_parse(NLB0_AFUID, guid) < 0) {
            fprintf(stderr, "Error parsing guid \(aq%s\(aq\en", NLB0_AFUID);
            goto out_exit;
        }

        /* Look for accelerator by its "afu_id" */
        res = fpgaGetProperties(NULL, &filter);
        ON_ERR_GOTO(res, out_exit, "creating properties object");

        res = fpgaPropertiesSetObjectType(filter, FPGA_ACCELERATOR);
        ON_ERR_GOTO(res, out_destroy_prop, "setting object type");

        res = fpgaPropertiesSetGuid(filter, guid);
        ON_ERR_GOTO(res, out_destroy_prop, "setting GUID");

        /* TODO: Add selection via BDF / device ID */

        res = fpgaEnumerate(&filter, 1, &afu_token, 1, &num_matches);
        ON_ERR_GOTO(res, out_destroy_prop, "enumerating accelerators");

        if (num_matches < 1) {
            fprintf(stderr, "accelerator not found.\en");
            res = fpgaDestroyProperties(&filter);
            return FPGA_INVALID_PARAM;
        }

        /* Open accelerator and map MMIO */
        res = fpgaOpen(afu_token, &afu_handle, 0);
        ON_ERR_GOTO(res, out_destroy_tok, "opening accelerator");

        res = fpgaMapMMIO(afu_handle, 0, NULL);
        ON_ERR_GOTO(res, out_close, "mapping MMIO space");

        /* Allocate buffers */
        res = fpgaPrepareBuffer(afu_handle, LPBK1_DSM_SIZE,
                    (void **)&dsm_ptr, &dsm_wsid, 0);
        ON_ERR_GOTO(res, out_close, "allocating DSM buffer");

        res = fpgaPrepareBuffer(afu_handle, LPBK1_BUFFER_ALLOCATION_SIZE,
                   (void **)&input_ptr, &input_wsid, 0);
        ON_ERR_GOTO(res, out_free_dsm, "allocating input buffer");

        res = fpgaPrepareBuffer(afu_handle, LPBK1_BUFFER_ALLOCATION_SIZE,
                   (void **)&output_ptr, &output_wsid, 0);
        ON_ERR_GOTO(res, out_free_input, "allocating output buffer");

        printf("Running Test\en");

        /* Initialize buffers */
        memset((void *)dsm_ptr,    0,    LPBK1_DSM_SIZE);
        memset((void *)input_ptr,  0xAF, LPBK1_BUFFER_SIZE);
        memset((void *)output_ptr, 0xBE, LPBK1_BUFFER_SIZE);

        cache_line *cl_ptr = (cache_line *)input_ptr;
        for (uint32_t i = 0; i < LPBK1_BUFFER_SIZE / CL(1); ++i) {
            cl_ptr[i].uint[15] = i+1; /* set the last uint in every cacheline */
        }

        /* Reset accelerator */
        res = fpgaReset(afu_handle);
        ON_ERR_GOTO(res, out_free_output, "resetting accelerator");

        /* Program DMA addresses */
        uint64_t iova;
        res = fpgaGetIOAddress(afu_handle, dsm_wsid, &iova);
        ON_ERR_GOTO(res, out_free_output, "getting DSM IOVA");

        res = fpgaWriteMMIO64(afu_handle, 0, CSR_AFU_DSM_BASEL, iova);
        ON_ERR_GOTO(res, out_free_output, "writing CSR_AFU_DSM_BASEL");

        res = fpgaWriteMMIO32(afu_handle, 0, CSR_CTL, 0);
        ON_ERR_GOTO(res, out_free_output, "writing CSR_CFG");
        res = fpgaWriteMMIO32(afu_handle, 0, CSR_CTL, 1);
        ON_ERR_GOTO(res, out_free_output, "writing CSR_CFG");

        res = fpgaGetIOAddress(afu_handle, input_wsid, &iova);
        ON_ERR_GOTO(res, out_free_output, "getting input IOVA");
        res = fpgaWriteMMIO64(afu_handle, 0, CSR_SRC_ADDR, CACHELINE_ALIGNED_ADDR(iova));
        ON_ERR_GOTO(res, out_free_output, "writing CSR_SRC_ADDR");

        res = fpgaGetIOAddress(afu_handle, output_wsid, &iova);
        ON_ERR_GOTO(res, out_free_output, "getting output IOVA");
        res = fpgaWriteMMIO64(afu_handle, 0, CSR_DST_ADDR, CACHELINE_ALIGNED_ADDR(iova));
        ON_ERR_GOTO(res, out_free_output, "writing CSR_DST_ADDR");

        res = fpgaWriteMMIO32(afu_handle, 0, CSR_NUM_LINES, LPBK1_BUFFER_SIZE / CL(1));
        ON_ERR_GOTO(res, out_free_output, "writing CSR_NUM_LINES");
        res = fpgaWriteMMIO32(afu_handle, 0, CSR_CFG, 0x42000);
        ON_ERR_GOTO(res, out_free_output, "writing CSR_CFG");

        status_ptr = dsm_ptr + DSM_STATUS_TEST_COMPLETE/8;

        /* Start the test */
        res = fpgaWriteMMIO32(afu_handle, 0, CSR_CTL, 3);
        ON_ERR_GOTO(res, out_free_output, "writing CSR_CFG");

        /* Wait for test completion */
        while (0 == ((*status_ptr) & 0x1)) {
            usleep(100);
        }

        /* Stop the device */
        res = fpgaWriteMMIO32(afu_handle, 0, CSR_CTL, 7);
        ON_ERR_GOTO(res, out_free_output, "writing CSR_CFG");

        /* Check output buffer contents */
        for (uint32_t i = 0; i < LPBK1_BUFFER_SIZE; i++) {
            if (((uint8_t*)output_ptr)[i] != ((uint8_t*)input_ptr)[i]) {
                fprintf(stderr, "Output does NOT match input "
                    "at offset %i!\en", i);
                break;
            }
        }

        printf("Done Running Test\en");

        /* Release buffers */
    out_free_output:
        res = fpgaReleaseBuffer(afu_handle, output_wsid);
        ON_ERR_GOTO(res, out_free_input, "releasing output buffer");
    out_free_input:
        res = fpgaReleaseBuffer(afu_handle, input_wsid);
        ON_ERR_GOTO(res, out_free_dsm, "releasing input buffer");
    out_free_dsm:
        res = fpgaReleaseBuffer(afu_handle, dsm_wsid);
        ON_ERR_GOTO(res, out_unmap, "releasing DSM buffer");

        /* Unmap MMIO space */
    out_unmap:
        res = fpgaUnmapMMIO(afu_handle, 0);
        ON_ERR_GOTO(res, out_close, "unmapping MMIO space");

        /* Release accelerator */
    out_close:
        res = fpgaClose(afu_handle);
        ON_ERR_GOTO(res, out_destroy_tok, "closing accelerator");

        /* Destroy token */
    out_destroy_tok:
        res = fpgaDestroyToken(&afu_token);
        ON_ERR_GOTO(res, out_destroy_prop, "destroying token");

        /* Destroy properties object */
    out_destroy_prop:
        res = fpgaDestroyProperties(&filter);
        ON_ERR_GOTO(res, out_exit, "destroying properties object");

    out_exit:
        return res;

    }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Linking with the OPAE library is straightforward.  Code using this library
should include the header file \fBfpga.h\fP\&. Taking the GCC compiler on
Linux as an example, the minimalist compile and link line should look
like:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
gcc \-std=c99 hello_fpga.c \-I/usr/local/include \-L/usr/local/lib \-lopae\-c \-luuid \-ljson\-c \-lpthread \-o hello_fpga
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
The API uses some features from the C99 language standard. The
\(ga\-std=c99\(ga switch is required if the compiler does not support C99 by
default.
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Third\-party library dependency: The library internally uses
\(galibuuid\(ga and \(galibjson\-c\(ga. But they are not distributed as part of the
library. Make sure you have these libraries properly installed.
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
The layout of AFU is different between the N3000 card and Rush Creek/Darby Creek.
In the N3000 card, the NLB and DMA are contained in the AFU, so we need to do
enumeration again in AFU to discover the NLB.
To run the hello_fpga application on the N3000 card, it should use the \(ga\-c\(ga
option to support the N3000 card:

\(ga\(ga\(gabash
$ sudo ./hello_fpga \-c
Running Test
Running on bus 0x08.
AFU NLB0 found @ 28000
Done Running Test
\(ga\(ga\(ga
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To run the \fBhello_fpga\fP application; just issue:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo ./hello_fpga
Running Test
Done
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Setup IOFS Release1 Bitstream on FPGA PCIe card
.sp
Program IOFS Release1 bitstream on the FPGA D5005 or N6000 cards and reboot the system.
.sp
Run this command:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ lspci | grep acc
3b:00.0 Processing accelerators: Intel Corporation Device af00 (rev 01)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Number of virtual functions supported by bitstream:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cat /sys/bus/pci/devices/0000:3b:00.0/sriov_totalvfs 
output: 3
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Enable FPGA virtual functions:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sudo sh \-c "echo 3 > /sys/bus/pci/devices/0000:3b:00.0/sriov_numvfs"
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
List of FPGA PF and VF’s:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Physical Functions (PFs):
  3b:00.0 Processing accelerators: Intel Corporation Device af00 (rev 01)

Virtual Functions (VFs).
  3b:00.1 Processing accelerators: Intel Corporation Device af01 (rev 01)
  3b:00.2 Processing accelerators: Intel Corporation Device af01 (rev 01)
  3b:00.3 Processing accelerators: Intel Corporation Device af01 (rev 01)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Bind vfio\-pcie driver to FPGA virtual functions:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sudo opaevfio  \-i 0000:3b:00.1 \-u userid \-g groupid
sudo opaevfio  \-i 0000:3b:00.2 \-u userid \-g groupid
sudo opaevfio  \-i 0000:3b:00.3 \-u userid \-g groupid
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
List of fpga accelerators:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ fpgainfo port

  //****** PORT ******//
  Object Id                        : 0x600D000000000000
  PCIe s:b:d.f                     : 0000:3b:00.3
  Device Id                        : 0xAF00
  Socket Id                        : 0xFF
  Accelerator Id                   : 43425ee6\-92b2\-4742\-b03a\-bd8d4a533812
  Accelerator GUID                 : 43425ee6\-92b2\-4742\-b03a\-bd8d4a533812
  //****** PORT ******//
  Object Id                        : 0x400D000000000000
  PCIe s:b:d.f                     : 0000:3b:00.2
  Device Id                        : 0xAF00
  Socket Id                        : 0xFF
  Accelerator Id                   : 8568AB4E\-6bA5\-4616\-BB65\-2A578330A8EB
  Accelerator GUID                 : 8568AB4E\-6bA5\-4616\-BB65\-2A578330A8EB
  //****** PORT ******//
  Object Id                        : 0x200D000000000000
  PCIe s:b:d.f                     : 0000:3b:00.1
  Device Id                        : 0xAF00
  Socket Id                        : 0xFF
  Accelerator Id                   : 56e203e9\-864f\-49a7\-b94b\-12284c31e02b
  Accelerator GUID                 : 56e203e9\-864f\-49a7\-b94b\-12284c31e02b

FPGA VF1/3b:00.1/Host Exerciser Loopback Accelerator GUID: 56E203E9\-864F\-49A7\-B94B\-12284C31E02B
FPGA VF2/3b:00.2/Host Exerciser Memory Accelerator GUID: 8568AB4E\-6bA5\-4616\-BB65\-2A578330A8EB
FPGA VF3/3b:00.3/Host Exerciser HSSI Accelerator GUID: 43425ee6\-92b2\-4742\-b03a\-bd8d4a533812
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Unbind pcie\-vfio dirver to FPGA virtual functions:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sudo opaevfio  \-r 0000:3b:00.1
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Host Exerciser Loopback (HE\-LBK) AFU can move data between host memory and FPGA:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ host_exerciser lpbk
  
  [lpbk] [info] starting test run, count of 1
  Input Config:0
  Allocate SRC Buffer
  Allocate DST Buffer
  Allocate DSM Buffer
  Start Test
  Test Completed
  Host Exerciser swtest msg:0
  Host Exerciser numReads:32
  Host Exerciser numWrites:32
  Host Exerciser numPendReads:0
  Host Exerciser numPendWrites:0
  [lpbk] [info] Test lpbk(1): PASS
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
  In order to successfully run hello\e_fpga, the user needs to configure
  system hugepage to reserve 2M\-hugepages.
  For example, the command below reserves 20 2M\-hugepages:

  \(ga\(ga\(gabash
  echo 20 | sudo tee /sys/kernel/mm/hugepages/hugepages\-2048kB/nr_hugepages
  \(ga\(ga\(ga

  For x86_64 architecture CPU, user can use the following command to find out available huge page sizes:

  \(ga\(ga\(gabash
  $ grep pse /proc/cpuinfo | uniq
  flags : ... pse ...
  \(ga\(ga\(ga

  If this command returns a non\-empty string, 2MB pages are supported:

  \(ga\(ga\(gabash
  $ grep pse /proc/cpuinfo | uniq
  flags : ... pdpe1gb ...
  \(ga\(ga\(ga

  If this commands returns a non\-empty string, 1GB pages are supported.
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
The default configuration for many Linux distributions currently sets a
relatively low limit for pinned memory allocations per process 
(RLIMIT_MEMLOCK, often set to a default of 64kiB).

To run an OPAE application that attempts to share more memory than specified
by this limit between software and an accelerator, you can either:

* Run the application as root, or
* Increase the limit for locked memory via \(gaulimit\(ga:

\(ga\(ga\(gabash
ulimit \-l unlimited
\(ga\(ga\(ga

See the Installation Guide for how to permanently adjust the memlock limit.
.ft P
.fi
.UNINDENT
.UNINDENT
.SH OPAE INSTALLATION GUIDE
.SS How to download the OPAE SDK
.sp
OPAE SDK releases are available on \fI\%GitHub\fP\&.
Source code for the OPAE DFL device driver for Linux is also available on \fI\%GitHub\fP\&.
.SS Install the Fedora
.sp
Download the Fedora  (x86_64 version) installation file in \fI\%fedora\fP, and install the Fedora  in yourserver. You can choose Fedora Workstation or Fedora server.
.SS Build the kernel and DFL drivers
.sp
For building the OPAE kernel and kernel driver, the kernel development environment is required. So before you build the kernel, you must install the required packages. Run the following commands:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo dnf install gcc gcc\-c++ make kernel\-headers kernel\-devel elfutils\-libelf\-devel ncurses\-devel openssl\-devel bison flex
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Download the OPAE upstream kernel tree from github, for example download from fpga\-ofs\-dev\-5.15\-lts branch.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ git clone https://github.com/OPAE/linux\-dfl.git \-b fpga\-ofs\-dev\-5.15\-lts
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Configure the kernel.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cd linux\-dfl
$ cp /boot/config\-\(gauname \-r\(ga .config
$ cat configs/dfl\-config >> .config
$ echo \(aqCONFIG_LOCALVERSION="\-dfl"\(aq >> .config
$ echo \(aqCONFIG_LOCALVERSION_AUTO=y\(aq >> .config
$ sed \-i \-r \(aqs/CONFIG_SYSTEM_TRUSTED_KEYS=.*/CONFIG_SYSTEM_TRUSTED_KEYS=""/\(aq .config
$ sed \-i \(aq/^CONFIG_DEBUG_INFO_BTF/ s/./#&/\(aq .config
$ echo \(aqCONFIG_DEBUG_ATOMIC_SLEEP=y\(aq >> .config
$ make olddefconfig
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Compile and install the new kernel.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ make \-j $(nproc)
$ sudo make modules_install \-j $(nproc)
$ sudo make install
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Build linux DFL Kernel instructions please also refer to: https://github.com/OPAE/linux\-dfl/wiki/Build\-the\-linux\-dfl\-kernel
.sp
When install finished, reboot your system.
When the system login again, verify the kernel version is correct. For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[figo@localhost linux\-dfl]$ uname \-a
Linux localhost.localdomain 5.15.lts\-dfl\-g73e16386cda0 #6 SMP Mon Jun 13 21:21:31 \-04 2022 x86_64 x86_64 x86_64
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
And also you can check the OPAE dfl drivers have auto\-loaded.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[figo@localhost linux\-dfl]$ lsmod | grep fpga
ifpga_sec_mgr          20480  1 intel_m10_bmc_secure
fpga_region            20480  3 dfl_fme_region,dfl_fme,dfl
fpga_bridge            24576  4 dfl_fme_region,fpga_region,dfl_fme,dfl_fme_br
fpga_mgr               16384  4 dfl_fme_region,fpga_region,dfl_fme_mgr,dfl_fme
[figo@localhost linux\-dfl]$ lsmod | grep dfl
dfl_eth_group          36864  0
dfl_fme_region         20480  0
dfl_emif               16384  0
dfl_n3000_nios         20480  0
dfl_fme_br             16384  0
dfl_fme_mgr            20480  1
dfl_fme                49152  0
dfl_afu                36864  0
dfl_pci                20480  0
dfl                    40960  7 dfl_pci,dfl_fme,dfl_fme_br,dfl_eth_group,dfl_n3000_nios,dfl_afu,dfl_emif
fpga_region            20480  3 dfl_fme_region,dfl_fme,dfl
fpga_bridge            24576  4 dfl_fme_region,fpga_region,dfl_fme,dfl_fme_br
fpga_mgr               16384  4 dfl_fme_region,fpga_region,dfl_fme_mgr,dfl_fme
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Build the OPAE\-SDK
.sp
Before you build the OPAE SDK, you must install the required packages. Run the following commands:
.SS Rocky Linux 8.5
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# dnf install \-y \(aqdnf\-command(config\-manager)\(aq
# dnf config\-manager \-\-set\-enabled powertools
# dnf install \-y epel\-release
# dnf check\-update
# dnf upgrade \-y
# dnf install \-y python3 python3\-pip python3\-devel python3\-jsonschema python3\-pyyaml python3\-pybind11 git gcc gcc\-c++ make cmake libuuid\-devel json\-c\-devel hwloc\-devel tbb\-devel cli11\-devel spdlog\-devel libedit\-devel systemd\-devel rpm\-build rpmdevtools pybind11\-devel yaml\-cpp\-devel libudev\-devel linuxptp
# python3 \-m pip install jsonschema virtualenv pyyaml
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Fedora
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# dnf check\-update
# dnf upgrade \-y
# dnf install \-y python3 python3\-pip python3\-devel python3\-jsonschema python3\-pyyaml python3\-pybind11 git gcc g++ make cmake libuuid\-devel json\-c\-devel hwloc\-devel tbb\-devel libedit\-devel rpm\-build rpmdevtools pybind11\-devel yaml\-cpp\-devel libudev\-devel cli11\-devel spdlog\-devel linuxptp
# pip3 install jsonschema virtualenv pyyaml
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Ubuntu 20.04
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# apt\-get update
# apt\-get upgrade \-y
# apt\-get install \-y python3 python3\-pip python3\-dev git gcc g++ make cmake uuid\-dev libjson\-c\-dev libhwloc\-dev libtbb\-dev libedit\-dev libudev\-dev linuxptp pandoc devscripts debhelper doxygen
# pip3 install jsonschema virtualenv pyyaml pybind11
.ft P
.fi
.UNINDENT
.UNINDENT
.SS RHEL 8.2
.sp
Register and enable Red Hat subscription to install any packages on the system.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# subscription\-manager register \-\-proxy=PROXY \-\-username=USER \-\-password=PASSWORD \-\-auto\-attach
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Set the RHEL version and install packages. Set proxy name and port number.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# subscription\-manager release \-\-set=8.2 \-\-proxy proxy\-name.com:port number
# subscription\-manager repos \-\-enable codeready\-builder\-for\-rhel\-8\-x86_64\-rpms
# dnf upgrade \-y
# dnf install \-y https://dl.fedoraproject.org/pub/epel/epel\-release\-latest\-8.noarch.rpm
# dnf install \-y python3 python3\-pip python3\-devel gdb vim git gcc gcc\-c++ make cmake libuuid\-devel rpm\-build systemd\-devel  nmap
# dnf install \-y python3\-jsonschema json\-c\-devel tbb\-devel rpmdevtools libcap\-devel 
# dnf check\-update || true
# dnf install \-y spdlog\-devel cli11\-devel python3\-pyyaml python3\-pybind11 hwloc\-devel libedit\-devel
# python3 \-m pip install \-\-user jsonschema virtualenv pudb pyyaml
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Install the latest version of \fI\%cmake\fP on top of the outdated cmake package from the package manager.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# cd cmake\-3.25.1/
# ./bootstrap \-\-prefix=/usr
# make
# make install
# which cmake
/usr/bin/cmake
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Create opae\-sdk packages
.sp
Download the OPAE\-SDK source code from github. For example, download from Master branch.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ git clone https://github.com/OPAE/opae\-sdk.git
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Compile and build the OPAE\-SDK RPMs (Fedora, Rocky, RHEL 8.2).
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cd opae\-sdk/packaging/opae/rpm
$ ./create fedora
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
After a successful compile, there are 3 rpm packages generated (Fedora, Rocky, RHEL8.2). For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
opae\-2.1.0\-1.fc34.x86_64.rpm
opae\-devel\-2.1.0\-1.fc34.x86_64.rpm
opae\-extra\-tools\-2.1.0\-1.fc34.x86_64.rpm
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Compile and build the OPAE\-SDK deb packages (Ubuntu 22.04).
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cd opae\-sdk/packaging/opae/deb
$ ./create
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
After a successful compile, there are 3 deb packages generated (Ubuntu 22.04). For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
opae_2.1.1\-1_amd64.deb  
opae\-devel_2.1.1\-1_amd64.deb  
opae\-extra\-tools_2.1.1\-1_amd64.deb
.ft P
.fi
.UNINDENT
.UNINDENT
.SS OPAE SDK installation with rpm/deb packages
.sp
The rpm packages generated in the previous step can be installed using these commands:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo dnf install ./*.rpm
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The deb packages generated in the previous step can be installed using these commands:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo dpkg \-i  ./*.deb
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
When you installed the rpms, you can run fpgainfo command to check the FPGA FME infomation. For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[figo@localhost install_guide]$ fpgainfo fme
Board Management Controller, MAX10 NIOS FW version: D.2.1.24
Board Management Controller, MAX10 Build version: D.2.0.7
//****** FME ******//
Object Id                        : 0xEF00000
PCIe s:b:d.f                     : 0000:08:00.0
Device Id                        : 0x0B30
Socket Id                        : 0x00
Ports Num                        : 01
Bitstream Id                     : 0x2300011001030F
Bitstream Version                : 0.2.3
Pr Interface Id                  : f3c99413\-5081\-4aad\-bced\-07eb84a6d0bb
Boot Page                        : user
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To uninstall the OPAE rpms, you can use this commands
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ dnf list installed | grep opae
$ sudo dnf remove opae*.x86_64
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To uninstall the OPAE deb, you can use this commands
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ dpkg \-l  | grep opae
$ dpkg \-r opae\-extra\-tools:amd64
$ dpkg \-r opae\-devel:amd64
$ dpkg \-r opae
.ft P
.fi
.UNINDENT
.UNINDENT
.SS FPGA Device Access Permissions
.sp
Access to FPGA accelerators and devices is controlled using file access permissions on the
Intel® FPGA device files, \fB/dev/dfl\-fme.*\fP and \fB/dev/dfl\-port.*\fP, as well as to the files reachable through \fB/sys/class/fpga_region/\fP\&.
.sp
In order to allow regular (non\-root) users to access accelerators, you need to grant them read and write permissions on \fB/dev/dfl\-port.*\fP (with \fB*\fP denoting the respective socket, i.e. 0 or 1). E.g.:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo chmod a+rw /dev/dfl\-port.0
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Memlock limit
.sp
Depending on the requirements of your application, you may also want to
increase the maximum amount of memory a user process is allowed to lock. The
exact way to do this depends on your Linux distribution.
.sp
You can check the current memlock limit using
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ ulimit \-l
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
A way to permanently remove the limit for locked memory for a regular user is
to add the following lines to your /etc/security/limits.conf:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
user1    hard   memlock           unlimited
user1    soft   memlock           unlimited
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This removes the limit on locked memory for user \fBuser1\fP\&. To remove it for
all users, you can replace \fBuser1\fP with \fB*\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
*    hard   memlock           unlimited
*    soft   memlock           unlimited
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that settings in the /etc/security/limits.conf file don’t apply to
services.  To increase the locked memory limit for a service you need to
modify the application’s systemd service file and add the line:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[Service]
LimitMEMLOCK=infinity
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Hugepage Settings
.sp
Users need to configure system hugepages to reserve 2MB\-hugepages or
1GB\-hugepages. For example, the ‘hello_fpga’ sample requires several
2MB\-hugepages. And the \fIfpgadiag\fP tool requires several 1GB\-hugepages.
.sp
The command below reserves 20 2M\-hugepages:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo sh \-c \(aqecho 20 > /sys/kernel/mm/hugepages/hugepages\-2048kB/nr_hugepages\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The command below reserves 4 1GB\-hugepages:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo sh \-c \(aqecho 4 > /sys/kernel/mm/hugepages/hugepages\-1048576kB/nr_hugepages\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
For x86_64 architecture processors, user can use following command to find out avaiable hugepage sizes:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ grep pse /proc/cpuinfo | uniq
flags : ... pse ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If this commands returns a non\-empty string, 2MB pages are supported.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ grep pse /proc/cpuinfo | uniq
flags : ... pdpe1gb ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If this commands returns a non\-empty string, 1GB pages are supported.
.SH OPAE C API PROGRAMMING GUIDE
.SS Overview
.sp
The OPAE C library (\fIlibopae\-c\fP) is a lightweight user\-space library that
provides abstractions for FPGA resources in a compute environment. The OPAE C library
builds on the driver stack that supports the FPGA device, abstracting
hardware\- and OS\-specific details. It provides access to the underlying FPGA
resources as a set of features available to software programs
running on the host. These features include the acceleration logic
preconfigured on the FPGA and functions to manage and reconfigure
the FPGA. The library enables your applications to
transparently and seamlessly benefit from FPGA\-based acceleration.
.sp
[image: Layered architecture]
[image]

.sp
By providing a unified C API, the library supports different FPGA
integration and deployment models, ranging from single\-node systems with one or
a few FPGA devices to large\-scale FPGA deployments in a data center.
At one end of the spectrum, the API supports a simple application using a PCIe link to reconfigure
the FPGA with different accelerator functions. At the other end of the spectrum, resource
management and orchestration services in a data center can use this API to
discover and select FPGA resources and then allocate them for use by acceleration workloads.
.SS OPAE Role
.sp
The OPAE provides a common base layer for a wide range of
applications without sacrificing performance or efficiency. The abstraction layer limits
the details of the FPGA hardware that software applications must handle.
.sp
The OPAE provides consistent interfaces to crucial components of the platform. The  OPAE does not constrain
frameworks and applications by making optimizations with limited applicability. When the OPAE does
provide convenience functions or optimizations, they are optional.
.sp
For example, the OPAE provides an interface to allocate physically contiguous
buffers in system memory that user\-space software and an accelerator can share.
This interface enables the most basic feature set of
allocating and sharing a large page of memory in one API call. However, it
does \fInot\fP provide a malloc()\-like interface backed by a memory pool or slab
allocator. Higher layers of the software stack can make such
domain\-specific optimizations.
.SS Intel Accelerator Stack Hardware Terminology
.sp
The following terms define the hardware and hardware processes involved in creating an accelerator function.
.INDENT 0.0
.IP \(bu 2
FPGA: \fI\%Field Programmable Gate Array\fP
is a discrete or integrated device connecting to a host CPU via PCIe or other type of interconnects.
.IP \(bu 2
Accelerator Function Unit (AFU): The AFU is the supplied implementation of an accelerator, typically
in HDL. AFUs implement a function such as compression, encryption, or mathematical operations.
The Quartus Prime Pro software synthesizes the RTL logic into a bitstream.
.IP \(bu 2
Accelerator Function (AF): The AF is the compiled binary for an AFU. An AF is a raw binary file (.rbf)
bitstream. A tool (\fIfpgaconf\fP) reconfigures the FPGA using an AF bitstream.
.IP \(bu 2
Reconfiguration: The process of reprogramming the FPGA with a different AF.
.UNINDENT
.SS OPAE Software Concepts Reflected in the C API
.sp
The following OPAE data structures and functions integrate AFUs into the OPAE environment.
The OPAE C API models these data structures and functions. For more information on the object
models refer to the \fI\%Object model\fP section.
.INDENT 0.0
.IP \(bu 2
Accelerator: An accelerator is an allocable accelerator function implemented in an FPGA.
An accelerator tracks the  \fIownership\fP of an AFU (or part of it) for a process that uses it.
Multiple processes can share an accelerator.
.IP \(bu 2
Device: The OPAE enumerates and models two device types: the FPGA and the AFU.
.IP \(bu 2
Events: Events are asynchronous notifications. The FPGA driver
triggers particular events to indicate error conditions. Accelerator logic can also
define its own events. User applications can choose to be
notified when particular events occur and respond appropriately.
.IP \(bu 2
Shared memory buffers: Software allocates shared memory buffers in user process memory
on the host. Shared memory buffers facilitate data transfers between the user process and the
accelerator that it owns.
.UNINDENT
.SS OPAE Library
.sp
Linking with this library is straightforward.
Code using the  OPAE library should include the header file \fBfpga.h\fP\&. Taking the GCC
compiler on Linux as an example, here is the simplest compile and link command:
.sp
\fBgcc myprog.c \-I</path/to/fpga.h> \-L</path/to/libopae\-c.so> \-lopae\-c \-luuid \-ljson\-c \-lpthread\fP
.sp
\&.. note::
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
The OPAE library uses the third\-party \(galibuuid\(ga and \(galibjson\-c\(ga libraries that are not distributed with 
the OPAE library. Make sure to install these libraries.
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Sample Code
.sp
The library source includes two code samples. Use these samples
to learn how to call functions in the library. Build and run these samples
to determine if your installation and environment are set up properly.
.sp
Refer to the \fI\%Running the Hello FPGA Example\fP chapter in the \fIIntel® Acceleration Stack
Quick Start Guide for for Intel Programmable Acceleration Card with Intel Arria® 10 GX FPGA\fP for more information about using the sample code.
.SS High\-Level Directory Structure
.sp
Building and installing the OPAE library results in the following directory structure on the Linux OS.
Windows and MacOS have similar directories and files.
.sp
|Directory & Files |Contents |
|——————|———|
|include/opae      |Directory containing all header files|
|include/opae/fpga.h |Top\-level header for user code to include|
|include/opae/access.h |Header file for accelerator acquire/release, MMIO, memory management, event handling, and so on |
|include/opae/bitstream.h |Header file for bitstream manipulation functions |
|include/opae/common.h |Header file for error reporting functions |
|include/opae/enum.h |Header file for AFU enumeration functions |
|include/opae/manage.h |Header file for FPGA management functions |
|include/opae/types.h |Various type definitions |
|lib               |Directory containing shared library files |
|lib/libopae\-c.so    |The shared dynamic library for linking with the user application |
|doc               |Directory containing API documentation |
|doc/html          |Directory for documentation of HTML format
|doc/latex         |Directory for documentation of LaTex format
|doc/man           |Directory for documentation of Unix man page format
.SS Basic Application Flow
.sp
The figure below shows the basic application flow from the
viewpoint of a user\-process.
.sp
[image: Basic flow]
[image]

.SS API Components
.sp
The API object model abstracts the physical FPGA device and
available functions. It is a generalized model and extends to
describe any FPGA type.
.SS Object Models
.INDENT 0.0
.IP \(bu 2
\fBfpga_objtype\fP: An enum type that represents the type of an FPGA resource, either \fBFPGA_DEVICE\fP or \fBFPGA_ACCELERATOR\fP\&.
An \fBFPGA_DEVICE\fP object corresponds to a physical FPGA device. Only \fBFPGA_DEVICE\fP objects can invoke management functions.
The \fBFPGA_ACCELERATOR\fP represents an instance of an AFU.
.IP \(bu 2
\fBfpga_token\fP: An opaque type that represents a resource known to, but not
necessarily owned by, the calling process. The calling process must own a
resource before it can invoke functions of the resource.
.IP \(bu 2
\fBfpga_handle\fP: An opaque type that represents a resource owned by the
calling process. The API functions \fBfpgaOpen()\fP and \fBfpgaClose()\fP acquire and release ownership of a resource that an \fBfpga_handle\fP represents. (Refer to the \fI\%Functions\fP section for more information.)
.IP \(bu 2
\fBfpga_properties\fP: An opaque type for a properties object. Your
applications use these properties to query and search for appropriate resources. The
\fI\%FPGA Resource Properties\fP section documents properties visible to your
applications.
.IP \(bu 2
\fBfpga_event_handle\fP: An opaque handle the FPGA driver uses to notify your
application about an event.
.IP \(bu 2
\fBfpga_event_type\fP: An enum type that represents the types of events. The following are valid values:
\fBFPGA_EVENT_INTERRUPT\fP, \fBFPGA_EVENT_ERROR\fP, and \fBFPGA_EVENT_POWER_THERMAL\fP\&. (The Intel Programmable Acceleration Card (PAC) with
Intel Arria 10 GX FPGA does not handle thermal and power events.)
.IP \(bu 2
\fBfpga_result\fP: An enum type to represent the result of an API function. If the
function returns successfully the result is \fBFPGA_OK\fP\&. Otherwise, the result is
the appropriate error codes. Function \fBfpgaErrStr()\fP translates an error code
into human\-readable strings.
.UNINDENT
.SS Functions
.sp
The table below groups important API calls by their functionality. For more information about each of the functions, refer to the
\fI\%OPAE C API reference manual\fP\&.
.sp
|Functionality |API Call |FPGA |Accelerator|Description |
|:——–|:———\-|:—–:|:—–:|:———————–|
|Enumeration | \fBfpgaEnumerate()\fP |Yes| Yes| Query FPGA resources that match certain properties |
|Enumeration: Properties | \fBfpga[Get, Update, Clear, Clone, Destroy Properties]()\fP |Yes| Yes| Manage \fBfpga_properties\fP life cycle |
|           | \fBfpgaPropertiesGet[Prop]()\fP | Yes| Yes|Get the specified property \fIProp\fP, from the \fI\%FPGA Resource Properties\fP table |
|           | \fBfpgaPropertiesSet[Prop]()\fP | Yes| Yes|Set the specified property \fIProp\fP, from the \fI\%FPGA Resource Properties\fP table |
|Access: Ownership  | \fBfpga[Open, Close]()\fP | Yes| Yes|Acquire/release ownership |
|Access: Reset      | \fBfpgaReset()\fP |Yes| Yes| Reset an accelerator |
|Access: Event handling | \fBfpga[Register, Unregister]Event()\fP |Yes| Yes| Register/unregister an event to be notified about |
|               | \fBfpga[Create, Destroy]EventHandle()\fP|Yes| Yes| Manage \fBfpga_event_handle\fP life cycle |
|Access: MMIO       | \fBfpgaMapMMIO()\fP, \fBfpgaUnMapMMIO()\fP |Yes| Yes| Map/unmap MMIO space |
|           | \fBfpgaGetMMIOInfo()\fP |Yes| Yes| Get information about the specified MMIO space |
|           | \fBfpgaReadMMIO[32, 64]()\fP | Yes| Yes|Read a 32\-bit or 64\-bit value from MMIO space |
|           | \fBfpgaWriteMMIO[32, 64]()\fP |Yes| Yes| Write a 32\-bit or 64\-bit value to MMIO space |
|Memory management: Shared memory | \fBfpga[Prepare, Release]Buffer()\fP |Yes| Yes| Manage memory buffer shared between the calling process and an accelerator |
|              | \fBfpgaGetIOAddress()\fP | Yes| Yes|Return the device I/O address of a shared memory buffer |
|Management: Reconfiguration | \fBfpgaReconfigureSlot()\fP | Yes | No | Replace an existing AFU with a new one |
|Error report | \fBfpgaErrStr()\fP | Yes| Yes|Map an error code to a human readable string |
.sp
\&.. note::
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
The UMsg APIs are not supported for the Intel(R) PAC cards. They will be deprecated in a future release.
.ft P
.fi
.UNINDENT
.UNINDENT
.SS FPGA Resource Properties
.sp
Applications query resource properties by specifying the property name for \fBProp\fP in the
\fBfpgaPropertiesGet[Prop]()\fP and \fBfpgaPropertiesSet[Prop]()\fP functions. The FPGA and Accelerator
columns state whether or not the Property is available for the FPGA or Accelerator objects.
.sp
|Property |FPGA |Accelerator |Description |
|:———|:—–:|:—\-:|:—–|
|Parent |No |Yes |\fBfpga_token\fP of the parent object |
|ObjectType |Yes |Yes |The type of the resource: either \fBFPGA_DEVICE\fP or \fBFPGA_ACCELERATOR\fP |
|Bus |Yes |Yes |The bus number |
|Device |Yes |Yes |The PCI device number |
|Function |Yes |Yes |The PCI function number |
|SocketId |Yes |Yes |The socket ID |
|DeviceId |Yes |Yes |The device ID |
|NumSlots |Yes |No |Number of AFU slots available on an \fBFPGA_DEVICE\fP resource |
|BBSID |Yes |No |The FPGA Interface Manager (FIM) ID of an \fBFPGA_DEVICE\fP resource |
|BBSVersion |Yes |No |The FIM version of an \fBFPGA_DEVICE\fP resource |
|VendorId |Yes |No |The vendor ID of an \fBFPGA_DEVICE\fP resource |
|GUID |Yes |Yes |The GUID of an \fBFPGA_DEVICE\fP or \fBFPGA_ACCELERATOR\fP resource |
|NumMMIO |No |Yes |The number of MMIO space of an \fBFPGA_ACCELERATOR\fP resource |
|NumInterrupts |No |Yes |The number of interrupts of an \fBFPGA_ACCELERATOR\fP resource |
|AcceleratorState |No |Yes |The state of an \fBFPGA_ACCELERATOR\fP resource: either \fBFPGA_ACCELERATOR_ASSIGNED\fP or \fBFPGA_ACCELERATOR_UNASSIGNED\fP|
.SS OPAE C API Return Codes
.sp
The OPAE C library returns a code for every exported public API function.  \fBFPGA_OK\fP indicates successful completion
of the requested operation. Any return code other than \fBFPGA_OK\fP indicates an error or unexpected
behavior. When using the OPAE C API, always check the API return codes.
.sp
|Error Code|Description|
|———\-|———–|
|\fBFPGA_OK\fP|Operation completed successfully|
|\fBFPGA_INVALID_PARAM\fP|Invalid parameter supplied|
|\fBFPGA_BUSY\fP|Resource is busy|
|\fBFPGA_EXCEPTION\fP|An exception occurred|
|\fBFPGA_NOT_FOUND\fP|A required resource was not found|
|\fBFPGA_NO_MEMORY\fP|Not enough memory to complete operation|
|\fBFPGA_NOT_SUPPORTED\fP|Requested operation is not supported|
|\fBFPGA_NO_DRIVER\fP|Driver is not loaded|
|\fBFPGA_NO_DAEMON\fP|FPGA Daemon (\fBfpgad\fP) is not running|
|\fBFPGA_NO_ACCESS\fP|Insufficient privileges or permissions|
|\fBFPGA_RECONF_ERROR\fP|Error while reconfiguring FPGA|
.SS Usage Models
.SS Query and Search for a Resource
.sp
The user\-code first populates an \fBfpga_properties\fP object with the required properties.
Then, \fBfpgaEnumerate()\fP searches for matching resources. \fBfpgaEnumerate()\fP may return more
than one matching resource.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "fpga/fpga.h"

fpga_guid               guid;
fpga_properties         filter = NULL;
fpga_result             res;
fpga_token              tokens[MAX_NUM_TOKENS];
uint32_t                num_matches = 0;

/* Start with an empty properties object */
res = fpgaGetProperties(NULL, &filter);

/* Populate the properties object with required values.
   In this case, search for accelerators that matches 
   the specified GUID.
*/
uuid_parse(GUID, guid);
res = fpgaPropertiesSetObjectType(filter, FPGA_ACCELERATOR);
res = fpgaPropertiesSetGuid(filter, guid);

/* Query the number of matching resources */
res = fpgaEnumerate(&filter, 1, NULL, 1, &num_matches);

/* Return tokens for all matching resources */
res = fpgaEnumerate(&filter, 1, tokens, num_matches, &num_matches);

/* Destroy the properties object */
res = fpgaDestroyProperties(&filter);

/* More code */
\&......

/* Destroy tokens */
for (uint32_t i = 0; i < num_matches; ++i) {
    res = fpgaDestroyToken(tokens[i]);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fBfpgaEnumerate()\fP function can take multiple \fBfpga_properties\fPobjects in an array. In such cases,
the function performs a logical OR of  the properties object and returns resources that match any of
the multiple properties. The  \fBfpga_token\fP objects that \fBfpgaEnumerate()\fP returns, do not signify
ownership. To acquire ownership of a resource represented by a token, pass the token to \fBfpgaOpen()\fP\&.
.SS Acquire and Release a Resource
.sp
Use \fBfpgaOpen()\fP and \fBfpgaClose()\fP to acquire and release ownership of a resource.
The calling process must own the resource before it can initiate MMIO, access share memory buffers,
and use functions offered by the resource.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    #include "fpga/fpga.h"

    fpga_handle             handle;
    fpga_result             res;

    /* Acquire ownership of a resource that 
    \(gafpgaEnumerate()\(ga previously returned as a token */
     
    res = fpgaOpen(token, &handle);

    /* More code */
    ......

    /* Release the ownership */
    res = fpgaClose(handle);
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Shared Memory Buffer
.sp
This code snippet shows how to prepare a memory buffer to be shared between the
calling process and an accelerator.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    #include "fpga/fpga.h"

    fpga_handle             handle;
    fpga_result             res;

    /* Hint for the virtual address of the buffer */
    volatile uint64_t       *addr_hint;
    /* An ID we can use to reference the buffer later */
    uint32_t                bufid;
    /* Flag to indicate whether or not the buffer is preallocated */
    int                     flag = 0;

    /* Allocate (if necessary), pin, and map a buffer to be accessible
       by an accelerator
    */
    res = fpgaPrepareBuffer(handle, BUF_SIZE, (void **) &addr_hint,
                            &bufid, flag);

    /* The actual address mapped to the buffer */
    uint64_t                iova;
    /* Get the IO virtual address for the buffer */
    res = fpgaGetIOAddress(handle, bufid, &iova);

    /* Inform the accelerator about the virtual address by writing to its mapped
       register file
    */
    ......

    /* More code */
    ......

    /* Release the shared buffer */
    res = fpgaReleaseBuffer(handle, bufid);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\&.. note::
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
The \(gaflag\(ga variable can take a constant \(gaFPGA_BUF_PREALLOCATED\(ga to
indicate that the calling process has already allocated the address space
that \(gaaddr_hint\(ga points to.
.ft P
.fi
.UNINDENT
.UNINDENT
.SS MMIO
.sp
This code snippet shows how to map and unmap the register file of an accelerator into the
calling process’s virtual memory space.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    #include "fpga/fpga.h"

    fpga_handle             handle;
    fpga_result             res;

    /* Index of the MMIO space. There might be multiple spaces on an accelerator */
    uint32_t                mmio_num = 0;
    /* Mapped address */
    uint64_t                mmio_addr;

    /* Map MMIO */
    res = fpgaMapMMIO(handle, mmio_num, &mmio_addr);

    /* Write to a 32\-bit value to the mapped register file at a certain byte
       offset.

       CSR_CTL is the offset in the mapped space to where the value will be
       written. It\(aqs defined elsewhere.
    */
    res = fpgaWriteMMIO32(handle, mmio_num, CSR_CTL, value);

    /* More code */
    ......

    /* Unmap MMIO */
    res = fpgaUnmapMMIO(handle, mmio_num);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\&.. Note::
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Every AFU has its own register adress space and its own protocol to control operation through 
the registers. 
.ft P
.fi
.UNINDENT
.UNINDENT
.SH OPAE PYTHON BINDINGS
.sp
OPAE (Open Programmable Acceleration Engine) now includes Python bindings for
interacting with FPGA resources. The OPAE Python API is built on top of the
OPAE C++ Core API and its object model. Because of this, developing OPAE
applications in Python is very similar to developing OPAE applications in C++
which significantly reduces the learning curve required to adapt to the Python API.
While the object model remains the same, some static factory functions in the
OPAE C++ Core API have been moved to module level methods in the OPAE Python API
with the exception of the properties class. The goal of the OPAE Python API is
to enable fast prototyping, test automation, infrastructure managment, and an
easy to use framework for FPGA resource interactions that don’t rely on software
algorithms with a high runtime complexity.
.sp
Currently, the only Python package that is part of OPAE is \fBopae.fpga\fP
.SS Implementation
.sp
The OPAE Python API is implemented by creating a Python extension using \fBpybind11 <http://pybind11.readthedocs.io/en/stable>\fP_\&.
This extension is created by using the pybind11 API which relies mostly on
macros and compile time introspection to define the module initialization point
as well as type converters between OPAE C++ Core types and OPAE Python types.
.SS Benefits
.sp
The major benefits of using pybind11 for developing the OPAE Python API
include, but are not limited to, the following features of pybind11:
.INDENT 0.0
.IP \(bu 2
Uses C++ 11 standard library although it can use C++ 14 or C++17.
.IP \(bu 2
Automatic conversions of shared_ptr types
.IP \(bu 2
Built\-in support for numpy and Eigen numerical libraries
.IP \(bu 2
Interoperable with the Python C API
.UNINDENT
.SS Runtime Requirements
.sp
Because opae.fpga is built on top of the opae\-cxx\-core API, it does require
that the runtime libraries for both opae\-cxx\-core and opae\-c be installed on
the system (as well as any other libraries they depend on). Those libraries can
be installed using the opae\-libs package (from either RPM or DEB format \-
depending on your Linux distribution).
.SS Installation
.SS Python Wheels
.sp
The preferred method of installation is to use a binary wheel package for your
version of Python.
.sp
The following table lists example names for different Python versions and
platforms.
.sp
| Python Version | Python ABI      | Linux Platform | Package Name |
|—————\-|—————–|—————\-|————–|
| 2.7 | CPython w/ UCS4 | x86_64 | opae.fpga.\-cp27\-cp27mu\-linux_x86_64.whl |
| 3.4 | CPython w/ UCS4 | x86_64 | opae.fpga.\-cp34\-cp34mu\-linux_x86_64.whl |
| 3.6 | CPython w/ UCS4 | x86_64 | opae.fpga.\-cp36\-cp36mu\-linux_x86_64.whl |
.sp
opae.fpga is currently not available in the Python Package Index but once it
does become available, one should be able to install using pip by simply typing
the following:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
> pip install \-\-user opae.fpga
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Installing From Source
.sp
In addition to the runtime libraries mentioned above, installing from source
does require that the OPAE header files be installed as well as those header
files for pybind11. The former can be installed with the opae\-devel package and
the latter can be installed by installing pybind11 Python module.
.SS Example Installation
.sp
The following example shows how to build from source by installing the
prerequisites before running the setup.py file.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
>sudo yum install opae\-libs\-<release>.x86_64.rpm
>sudo yum install opae\-devel\-<release>.x86_64.rpm
>pip install \-\-user pybind11
>pip install \-\-user opae.fpga\-<release>.tar.gz
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fINOTE\fP: The \fBpip\fP examples above use the \fB\-\-user\fP flag to avoid requiring root
permissions. Those packages will be installed in the user’s \fBsite\-packages\fP
directory found in the user’s \fB\&.local\fP directory.
.SS Example Scripts
.sp
The following example is an implementation of the sample, hello_fpga.c, which
is designed to configure the NLB0 diagnostic accelerator for a simple loopback.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
import time
from opae import fpga

NLB0 = "d8424dc4\-a4a3\-c413\-f89e\-433683f9040b"
CTL = 0x138
CFG = 0x140
NUM_LINES = 0x130
SRC_ADDR = 0x0120
DST_ADDR = 0x0128
DSM_ADDR = 0x0110
DSM_STATUS = 0x40

def cl_align(addr):
    return addr >> 6

tokens = fpga.enumerate(type=fpga.ACCELERATOR, guid=NLB0)
assert tokens, "Could not enumerate accelerator: {}".format(NlB0)

with fpga.open(tokens[0], fpga.OPEN_SHARED) as handle:
    src = fpga.allocate_shared_buffer(handle, 4096)
    dst = fpga.allocate_shared_buffer(handle, 4096)
    dsm = fpga.allocate_shared_buffer(handle, 4096)
    handle.write_csr32(CTL, 0)
    handle.write_csr32(CTL, 1)
    handle.write_csr64(DSM_ADDR, dsm.io_address())
    handle.write_csr64(SRC_ADDR, cl_align(src.io_address())) # cacheline\-aligned
    handle.write_csr64(DST_ADDR, cl_align(dst.io_address())) # cacheline\-aligned
    handle.write_csr32(CFG, 0x42000)
    handle.write_csr32(NUM_LINES, 4096/64)
    handle.write_csr32(CTL, 3)
    while dsm[DSM_STATUS] & 0x1 == 0:
        time.sleep(0.001)
    handle.write_csr32(CTL, 7)

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This example shows how one might reprogram (Partial Reconfiguration) an
accelerator on a given bus, 0x5e, using a bitstream file, m0.gbs.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from opae import fpga

BUS = 0x5e
GBS = \(aqm0.gbs\(aq
tokens = fpga.enumerate(type=fpga.DEVICE, bus=BUS)
assert tokens, "Could not enumerate device on bus: {}".format(BUS)
with open(GBS, \(aqrb\(aq) as fd, fpga.open(tokens[0]) as device:
    device.reconfigure(0, fd)
.ft P
.fi
.UNINDENT
.UNINDENT
.SH BUILDING OPAE SDK ARTIFACTS
.SS Steps
.INDENT 0.0
.IP \(bu 2
Fetch the OPAE SDK source tree
.IP \(bu 2
Configure the OPAE SDK CMake project
.IP \(bu 2
Build OPAE SDK targets
.UNINDENT
.sp
The example below lists commands that can be used to fetch and build OPAE SDK.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# fetch the source
git clone https://github.com/OPAE/opae\-sdk.git
cd opae\-sdk
# configure CMake
cmake ..
# build
make


.ft P
.fi
.UNINDENT
.UNINDENT
.sp
For a list of targets that can be built, type \fBmake help\fP from the build
directory.
.sp
CMake options that may be set during the configuration include the following:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
| cmake flag                 | Optional or Mandatory | Purpose                             | Valid values                          | Default value  |
|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
| \-DCMAKE_BUILD_TYPE         | Optional              | Set compiler flags                  | Debug/Release/Coverage/RelWithDebInfo | RelWithDebInfo |
| \-DOPAE_BUILD_LEGACY        | Optional              | Enable/disable opae\-legacy.git      | ON/OFF                                | OFF            |
| \-DOPAE_BUILD_SPHINX_DOC    | Optional              | Enable/disable documentation build  | ON/OFF                                | OFF            |
| \-DOPAE_BUILD_TESTS         | Optional              | Enable/disable building unit tests  | ON/OFF                                | OFF            |
| \-DOPAE_INSTALL_RPATH       | Optional              | Enable/disable rpath for install    | ON/OFF                                | OFF            |
| \-DOPAE_BUILD_LIBOPAE_CXX   | Optional              | Enable/disable OPAE C++ bindings    | ON/OFF                                | ON             | 
| \-DOPAE_WITH_PYBIND11       | Optional              | Enable/disable pybind11 binaries    | ON/OFF                                | ON             |
| \-DOPAE_BUILD_PYTHON_DIST   | Optional              | Enable/disable Python Distribution  | ON/OFF                                | OFF            |
| \-DOPAE_ENABLE_MOCK         | Optional              | Enable/disable mocks for unit tests | ON/OFF                                | OFF            |
| \-DOPAE_BUILD_SIM           | Optional              | Enable/disable opae\-sim.git         | ON/OFF                                | OFF            |

.ft P
.fi
.UNINDENT
.UNINDENT
.SH OPAE C API REFERENCE
.sp
The reference documentation for the OPAE C API is grouped into the following
sections:
.INDENT 0.0
.IP \(bu 2
\fI\%Types\fP
.INDENT 2.0
.IP \(bu 2
\fI\%types.h\fP
.IP \(bu 2
\fI\%types_enum.h\fP
.UNINDENT
.IP \(bu 2
\fI\%Enumeration API\fP
.INDENT 2.0
.IP \(bu 2
\fI\%enum.h\fP
.IP \(bu 2
\fI\%properties.h\fP
.INDENT 2.0
.IP \(bu 2
\fI\%Accessor Return Values\fP
.UNINDENT
.UNINDENT
.IP \(bu 2
\fI\%Access API\fP
.INDENT 2.0
.IP \(bu 2
\fI\%access.h\fP
.UNINDENT
.IP \(bu 2
\fI\%Event API\fP
.INDENT 2.0
.IP \(bu 2
\fI\%event.h\fP
.UNINDENT
.IP \(bu 2
\fI\%MMIO and Shared Memory APIs\fP
.INDENT 2.0
.IP \(bu 2
\fI\%mmio.h\fP
.IP \(bu 2
\fI\%buffer.h\fP
.IP \(bu 2
\fI\%umsg.h\fP
.UNINDENT
.IP \(bu 2
\fI\%Management API\fP
.INDENT 2.0
.IP \(bu 2
\fI\%manage.h\fP
.UNINDENT
.IP \(bu 2
\fI\%Metrics API\fP
.INDENT 2.0
.IP \(bu 2
\fI\%metrics.h\fP
.UNINDENT
.IP \(bu 2
\fI\%SysObject\fP
.INDENT 2.0
.IP \(bu 2
\fI\%sysobject.h\fP
.UNINDENT
.IP \(bu 2
\fI\%Utilities\fP
.INDENT 2.0
.IP \(bu 2
\fI\%utils.h\fP
.UNINDENT
.IP \(bu 2
\fI\%Samples\fP
.INDENT 2.0
.IP \(bu 2
\fI\%hello_fpga.c\fP
.IP \(bu 2
\fI\%hello_events.c\fP
.UNINDENT
.UNINDENT
.SS Types
.sp
The OPAE C API defines a number of types; most prominent are the types
\fIfpga_token\fP, \fIfpga_handle\fP, and \fIfpga_properties\fP\&. All regular types are
defined in [types.h](#types\-h), while the values of enumeration types are
defined in [types_enum.h](#types\-enum\-h).
.SS types.h
.sp
Type definitions for FPGA API. 
.sp
OPAE uses the three opaque types fpga_properties, fpga_token, and fpga_handle to create a hierarchy of objects that can be used to enumerate, reference, acquire, and query FPGA resources. This object model is designed to be extensible to account for different FPGA architectures and platforms.
.sp
Defines
.INDENT 0.0
.TP
.B FPGA_ERROR_NAME_MAX 
Information about an error register
.sp
This data structure captures information about an error register exposed by an accelerator resource. The error API provides functions to retrieve these information structures from a particular resource. 
.UNINDENT
.INDENT 0.0
.TP
.B FPGA_METRIC_STR_SIZE 
FPGA Metric string size 
.UNINDENT
.INDENT 0.0
.TP
.B fpga_is_parent_child(__parent_hdr, __child_hdr) 
Determine token parent/child relationship
.sp
Given pointers to two \fI\%fpga_token_header\fP structs, determine whether the first is the parent of the second. A parent will have objtype == FPGA_DEVICE. A child will have objtype == FPGA_ACCELERATOR. The PCIe address of the two headers will match in all but the function fields. 
.UNINDENT
.sp
Typedefs
.INDENT 0.0
.TP
.B typedef  void  *fpga_properties 
Object for expressing FPGA resource properties
.sp
\fBfpga_properties\fP objects encapsulate all enumerable information about an FPGA resources. They can be used for two purposes: selective enumeration (discovery) and querying information about existing resources.
.sp
For selective enumeration, usually an empty \fBfpga_properties\fP object is created (using \fI\%fpgaGetProperties()\fP) and then populated with the desired criteria for enumeration. An array of \fBfpga_properties\fP can then be passed to \fI\%fpgaEnumerate()\fP, which will return a list of \fBfpga_token\fP objects matching these criteria.
.sp
For querying properties of existing FPGA resources, \fI\%fpgaGetProperties()\fP can also take an \fBfpga_token\fP and will return an \fBfpga_properties\fP object populated with information about the resource referenced by that token.
.sp
After use, \fBfpga_properties\fP objects should be destroyed using fpga_destroyProperties() to free backing memory used by the \fBfpga_properties\fP object. 
.UNINDENT
.INDENT 0.0
.TP
.B typedef  void  *fpga_token 
Token for referencing FPGA resources
.sp
An \fBfpga_token\fP serves as a reference to a specific FPGA resource present in the system. Holding an \fBfpga_token\fP does not constitute ownership of the FPGA resource \- it merely allows the user to query further information about a resource, or to use \fI\%fpgaOpen()\fP to acquire ownership.
.sp
\fBfpga_token\fPs are usually returned by \fI\%fpgaEnumerate()\fP or \fI\%fpgaPropertiesGetParent()\fP, and used by \fI\%fpgaOpen()\fP to acquire ownership and yield a handle to the resource. Some API calls also take \fBfpga_token\fPs as arguments if they don’t require ownership of the resource in question. 
.UNINDENT
.INDENT 0.0
.TP
.B typedef  void  *fpga_handle 
Handle to an FPGA resource
.sp
A valid \fBfpga_handle\fP object, as populated by \fI\%fpgaOpen()\fP, denotes ownership of an FPGA resource. Note that ownership can be exclusive or shared, depending on the flags used in \fI\%fpgaOpen()\fP\&. Ownership can be released by calling \fI\%fpgaClose()\fP, which will render the underlying handle invalid.
.sp
Many OPAE C API functions require a valid token (which is synonymous with ownership of the resource). 
.UNINDENT
.INDENT 0.0
.TP
.B typedef  uint8_t  fpga_guid[16] 
Globally unique identifier (GUID)
.sp
GUIDs are used widely within OPAE for helping identify FPGA resources. For example, every FPGA resource has a \fBguid\fP property, which can be (and in the case of FPGA_ACCELERATOR resource primarily is) used for enumerating a resource of a specific type.
.sp
\fBfpga_guid\fP is compatible with libuuid’s uuid_t, so users can use libuuid functions like uuid_parse() to create and work with GUIDs. 
.UNINDENT
.INDENT 0.0
.TP
.B typedef  void  *fpga_event_handle 
Handle to an event object
.sp
OPAE provides an interface to asynchronous events that can be generated by different FPGA resources. The event API provides functions to register for these events; associated with every event a process has registered for is an \fBfpga_event_handle\fP, which encapsulates the OS\-specific data structure for event objects.
.sp
After use, \fBfpga_event_handle\fP objects should be destroyed using \fI\%fpgaDestroyEventHandle()\fP to free backing memory used by the \fBfpga_event_handle\fP object. 
.UNINDENT
.INDENT 0.0
.TP
.B typedef  void  *fpga_object 
Object pertaining to an FPGA resource as identified by a unique name
.sp
An \fBfpga_object\fP represents either a device attribute or a container of attributes. Similar to filesystems, a ‘/’ may be used to seperate objects in an object hierarchy. Once on object is acquired, it may be used to read or write data in a resource attribute or to query sub\-objects if the object is a container object. The data in an object is buffered and will be kept around until the object is destroyed. Additionally, the data in an attribute can by synchronized from the owning resource using the FPGA_OBJECT_SYNC flag during read operations. The name identifying the object is unique with respect to the resource that owns it. A parent resource may be identified by an \fBfpga_token\fP object, by an \fBfpga_handle\fP object, or another \fBfpga_object\fP object. If a handle object is used when opening the object, then the object is opened with read\-write access. Otherwise, the object is read\-only. 
.UNINDENT
.INDENT 0.0
.TP
.B struct  fpga_version 
\fI#include <opae/types.h>\fP
.sp
Semantic version
.sp
Data structure for expressing version identifiers following the semantic versioning scheme. Used in various properties for tracking component versions. 
.sp
Public Members
.INDENT 7.0
.TP
.B uint8_t  major 
Major version 
.UNINDENT
.INDENT 7.0
.TP
.B uint8_t  minor 
Minor version 
.UNINDENT
.INDENT 7.0
.TP
.B uint16_t  patch 
Revision or patchlevel 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B struct  fpga_error_info 
\fI#include <opae/types.h>\fP
.sp
Public Members
.INDENT 7.0
.TP
.B char  name[64] 
.UNINDENT
.INDENT 7.0
.TP
.B bool  can_clear 
name of the error 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B union  metric_value 
\fI#include <opae/types.h>\fP
.sp
Metric value union 
.sp
Public Members
.INDENT 7.0
.TP
.B uint64_t  ivalue 
.UNINDENT
.INDENT 7.0
.TP
.B double  dvalue 
.UNINDENT
.INDENT 7.0
.TP
.B float  fvalue 
.UNINDENT
.INDENT 7.0
.TP
.B bool  bvalue 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B struct  fpga_metric_info 
\fI#include <opae/types.h>\fP
.sp
Metric info struct 
.sp
Public Members
.INDENT 7.0
.TP
.B uint64_t  metric_num 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%fpga_guid\fP  metric_guid 
.UNINDENT
.INDENT 7.0
.TP
.B char  qualifier_name[256] 
.UNINDENT
.INDENT 7.0
.TP
.B char  group_name[256] 
.UNINDENT
.INDENT 7.0
.TP
.B char  metric_name[256] 
.UNINDENT
.INDENT 7.0
.TP
.B char  metric_units[256] 
.UNINDENT
.INDENT 7.0
.TP
.B enum  \fI\%fpga_metric_datatype\fP  metric_datatype 
.UNINDENT
.INDENT 7.0
.TP
.B enum  \fI\%fpga_metric_type\fP  metric_type 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B struct  fpga_metric 
\fI#include <opae/types.h>\fP
.sp
Metric struct 
.sp
Public Members
.INDENT 7.0
.TP
.B uint64_t  metric_num 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%metric_value\fP  value 
.UNINDENT
.INDENT 7.0
.TP
.B bool  isvalid 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B struct  threshold 
\fI#include <opae/types.h>\fP
.sp
Threshold struct 
.sp
Public Members
.INDENT 7.0
.TP
.B char  threshold_name[256] 
.UNINDENT
.INDENT 7.0
.TP
.B uint32_t  is_valid 
.UNINDENT
.INDENT 7.0
.TP
.B double  value 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B struct  metric_threshold 
\fI#include <opae/types.h>\fP
.sp
Public Members
.INDENT 7.0
.TP
.B char  metric_name[256] 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%threshold\fP  upper_nr_threshold 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%threshold\fP  upper_c_threshold 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%threshold\fP  upper_nc_threshold 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%threshold\fP  lower_nr_threshold 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%threshold\fP  lower_c_threshold 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%threshold\fP  lower_nc_threshold 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%threshold\fP  hysteresis 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B struct  fpga_token_header 
\fI#include <opae/types.h>\fP
.sp
Internal token type header
.sp
Each plugin (dfl: libxfpga.so, vfio: libopae\-v.so) implements its own proprietary token type. This header \fImust\fP appear at offset zero within that structure.
.sp
eg, see lib/plugins/xfpga/types_int.h:struct _fpga_token and lib/plugins/vfio/opae_vfio.h:struct _vfio_token. 
.sp
Public Members
.INDENT 7.0
.TP
.B uint64_t  magic 
.UNINDENT
.INDENT 7.0
.TP
.B uint16_t  vendor_id 
.UNINDENT
.INDENT 7.0
.TP
.B uint16_t  device_id 
.UNINDENT
.INDENT 7.0
.TP
.B uint16_t  segment 
.UNINDENT
.INDENT 7.0
.TP
.B uint8_t  bus 
.UNINDENT
.INDENT 7.0
.TP
.B uint8_t  device 
.UNINDENT
.INDENT 7.0
.TP
.B uint8_t  function 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%fpga_interface\fP  interface 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%fpga_objtype\fP  objtype 
.UNINDENT
.INDENT 7.0
.TP
.B uint64_t  object_id 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%fpga_guid\fP  guid 
.UNINDENT
.INDENT 7.0
.TP
.B uint16_t  subsystem_vendor_id 
.UNINDENT
.INDENT 7.0
.TP
.B uint16_t  subsystem_device_id 
.UNINDENT
.UNINDENT
.SS types_enum.h
.sp
Definitions of enumerated types for the OPAE C API. 
.sp
This file defines return and error codes, event and object types, states, and flags as used or reported by OPAE C API functions. 
.sp
Enums
.INDENT 0.0
.TP
.B enum  fpga_result 
OPAE C API function return codes
.sp
Every public API function exported by the OPAE C library will return one of these codes. Usually, FPGA_OK denotes successful completion of the requested operation, while any return code \fIother\fP than FPGA_OK indicates an error or other deviation from the expected behavior. Users of the OPAE C API should always check the return codes of the APIs they call, and not use output parameters of functions that did not execute successfully.
.sp
The \fI\%fpgaErrStr()\fP function converts error codes into printable messages.
.sp
OPAE also has a logging mechanism that allows a developer to get more information about why a particular call failed with a specific message. If enabled, any function that returns an error code different from FPGA_OK will also print out a message with further details. This mechanism can be enabled by setting the environment variable \fBLIBOPAE_LOG\fP to 1 before running the respective application. 
.sp
\fIValues:\fP
.INDENT 7.0
.TP
.B enumerator  FPGA_OK 
Operation completed successfully 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_INVALID_PARAM 
Invalid parameter supplied 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_BUSY 
Resource is busy 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_EXCEPTION 
An exception occurred 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_NOT_FOUND 
A required resource was not found 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_NO_MEMORY 
Not enough memory to complete operation 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_NOT_SUPPORTED 
Requested operation is not supported 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_NO_DRIVER 
Driver is not loaded 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_NO_DAEMON 
FPGA Daemon (fpgad) is not running 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_NO_ACCESS 
Insufficient privileges or permissions 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_RECONF_ERROR 
Error while reconfiguring FPGA 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B enum  fpga_event_type 
FPGA events
.sp
OPAE currently defines the following event types that applications can register for. Note that not all FPGA resources and target platforms may support all event types. 
.sp
\fIValues:\fP
.INDENT 7.0
.TP
.B enumerator  FPGA_EVENT_INTERRUPT 
Interrupt generated by an accelerator 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_EVENT_ERROR 
Infrastructure error event 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_EVENT_POWER_THERMAL 
Infrastructure thermal event 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B enum  fpga_accelerator_state 
accelerator state 
.sp
\fIValues:\fP
.INDENT 7.0
.TP
.B enumerator  FPGA_ACCELERATOR_ASSIGNED 
accelerator is opened exclusively by another process 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_ACCELERATOR_UNASSIGNED 
accelerator is free to be opened 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B enum  fpga_objtype 
OPAE FPGA resources (objects)
.sp
These are the FPGA resources currently supported by the OPAE object model. 
.sp
\fIValues:\fP
.INDENT 7.0
.TP
.B enumerator  FPGA_DEVICE 
FPGA_DEVICE objects represent FPGA devices and their management functionality. These objects can be opened (typically requires a certain privilege level or access permissions) and used for management functions like fpgaReconfigreSlot(). 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_ACCELERATOR 
FPGA_ACCELERATOR objects represent allocatable units for accessing accelerated functions on the FPGA. They are frequently opened for interacting via control registers (MMIO), shared memory, or other, possibly platform\-specific functions. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B enum  fpga_interface 
OPAE plugin interface
.sp
These are the supported plugin interfaces. 
.sp
\fIValues:\fP
.INDENT 7.0
.TP
.B enumerator  FPGA_IFC_DFL 
FPGA_IFC_DFL indicates that the plugin interface is the Device Feature List driver suite. 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_IFC_VFIO 
FPGA_IFC_VFIO indicates that the plugin interface is the vfio\-pci driver. 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_IFC_SIM_DFL 
FPGA_IFC_SIM_DFL indicates that the plugin interface is the AFU Simulation Environment simulating DFL drivers. 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_IFC_SIM_VFIO 
FPGA_IFC_SIM_VFIO indicates that the plugin interface is the AFU Simulation Environment simulating vfio\-pci. 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_IFC_UIO 
FPGA_IFC_UIO indicates that the plugin interface is the uio\-dfl driver. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B enum  fpga_buffer_flags 
Buffer flags
.sp
These flags can be passed to the \fI\%fpgaPrepareBuffer()\fP function. 
.sp
\fIValues:\fP
.INDENT 7.0
.TP
.B enumerator  FPGA_BUF_PREALLOCATED 
Use existing buffer 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_BUF_QUIET 
Suppress error messages 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_BUF_READ_ONLY 
Buffer is read\-only 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B enum  fpga_open_flags 
Open flags
.sp
These flags can be passed to the \fI\%fpgaOpen()\fP function. 
.sp
\fIValues:\fP
.INDENT 7.0
.TP
.B enumerator  FPGA_OPEN_SHARED 
Open FPGA resource for shared access 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B enum  fpga_reconf_flags 
Reconfiguration flags
.sp
These flags can be passed to the \fI\%fpgaReconfigureSlot()\fP function. 
.sp
\fIValues:\fP
.INDENT 7.0
.TP
.B enumerator  FPGA_RECONF_FORCE 
Reconfigure the slot without checking if it is in use 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_RECONF_SKIP_USRCLK 
Don’t configure AFU user clocks as part of PR 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B enum  fpga_sysobject_flags 
\fIValues:\fP
.INDENT 7.0
.TP
.B enumerator  FPGA_OBJECT_SYNC 
Synchronize data from driver 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_OBJECT_GLOB 
Treat names as glob expressions 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_OBJECT_RAW 
Read or write object data as raw bytes 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_OBJECT_RECURSE_ONE 
Create subobjects one level down from containers 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_OBJECT_RECURSE_ALL 
Create subobjects all levels from from containers 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B enum  fpga_sysobject_type 
\fIValues:\fP
.INDENT 7.0
.TP
.B enumerator  FPGA_OBJECT_CONTAINER 
Represents a group of objects 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_OBJECT_ATTRIBUTE 
An object with an attribute value that can be read/written 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B enum  fpga_metric_type 
fpga metrics types opae defines power,thermal, performance counter and afu metric types 
.sp
\fIValues:\fP
.INDENT 7.0
.TP
.B enumerator  FPGA_METRIC_TYPE_POWER 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_METRIC_TYPE_THERMAL 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_METRIC_TYPE_PERFORMANCE_CTR 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_METRIC_TYPE_AFU 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_METRIC_TYPE_UNKNOWN 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B enum  fpga_metric_datatype 
Metrics data type 
.sp
\fIValues:\fP
.INDENT 7.0
.TP
.B enumerator  FPGA_METRIC_DATATYPE_INT 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_METRIC_DATATYPE_FLOAT 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_METRIC_DATATYPE_DOUBLE 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_METRIC_DATATYPE_BOOL 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  FPGA_METRIC_DATATYPE_UNKNOWN 
.UNINDENT
.UNINDENT
.SS Enumeration API
.sp
The OPAE enumeration API allows selective discovery of FPGA resources. When
enumerating resources, a list of filter criteria can be passed to the
respective function to select a subset of all resources in the system. The
fpgaEnumerate() function itself then returns a list of fpga_tokens denoting
resources, which can be used in subsequent API calls.
.sp
Filter criteria are specified using one or more fpga_properties object. These
objects need to be created using fpgaGetProperties() (defined in
<opae/properties/h>) before being passed to fpgaEnumerate(). Individual
attributes of an fpga_properties object are set using specific accessors,
which are also defined in <opae/properties.h>.
.SS enum.h
.sp
APIs for resource enumeration and managing tokens. 
.sp
These APIs are the first step for any application using OPAE to discover resources that are present on the system. They allow selective enumeration (i.e. getting a list of resources that match a given list of criteria) and methods to manage the lifecycle of tokens generated by \fI\%fpgaEnumerate()\fP\&. 
.sp
Functions
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaEnumerate(const  \fI\%fpga_properties\fP  *filters, uint32_t  num_filters, \fI\%fpga_token\fP  *tokens, uint32_t  max_tokens, uint32_t  *num_matches) 
Enumerate FPGA resources present in the system
.sp
This call allows the user to query the system for FPGA resources that match a certain set of criteria, e.g. all accelerators that are assigned to a host interface and available, all FPGAs of a specific type, etc.
.sp
\fI\%fpgaEnumerate()\fP will create a number of \fBfpga_token\fPs to represent the matching resources and populate the array \fBtokens\fP with these tokens. The \fBmax_tokens\fP argument can be used to limit the number of tokens allocated/returned by \fI\%fpgaEnumerate()\fP; i.e., the number of tokens in the returned \fBtokens\fP array will be either \fBmax_tokens\fP or \fBnum_matches\fP (the number of resources matching the filter), whichever is smaller. Use \fI\%fpgaDestroyToken()\fP to destroy tokens that are no longer needed.
.sp
To query the number of matches for a particular set of filters (e.g. to allocate a \fBtokens\fP array of the appropriate size), call \fI\%fpgaEnumerate()\fP with the parameter \fBtokens\fP set to NULL; this will only return the number of matches in \fBnum_matches\fP\&.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%fpgaEnumerate()\fP will allocate memory for the created tokens returned in \fBtokens\fP\&. It is the responsibility of the using application to free this memory after use by calling \fI\%fpgaDestroyToken()\fP for each of the returned tokens.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfilters\fP – \fB[in]\fP Array of \fBfpga_properties\fP objects describing the properties of the objects that should be returned. A resource is considered matching if its properties match any one of the supplied filters. To match all FPGA resources, pass an empty filters object (one without any filter criteria set) or pass a NULL filters parameter with num_filters set to 0. 
.IP \(bu 2
\fBnum_filters\fP – \fB[in]\fP Number of entries in the \fBfilters\fP array, or 0 to match all FPGA resources when \fBfilters\fP is NULL. 
.IP \(bu 2
\fBtokens\fP – \fB[out]\fP Pointer to an array of fpga_token variables to be populated. If NULL is supplied, \fI\%fpgaEnumerate()\fP will not create any tokens, but it will return the number of possible matches in \fBnum_match\fP\&. 
.IP \(bu 2
\fBmax_tokens\fP – \fB[in]\fP Maximum number of tokens that \fI\%fpgaEnumerate()\fP shall return (length of \fBtokens\fP array). There may be more or fewer matches than this number; \fBnum_matches\fP is set to the number of actual matches. 
.IP \(bu 2
\fBnum_matches\fP – \fB[out]\fP Number of resources matching the \fBfilter\fP criteria. This number can be higher than the number of tokens returned in the \fBtokens\fP array (depending on the value of \fBmax_tokens\fP). 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if invalid pointers or objects are passed into the function. FPGA_NO_DRIVER if OPAE can’t find the respective enumeration data structures usually provided by the driver. FPGA_NO_MEMORY if there was not enough memory to create tokens. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaCloneToken(\fI\%fpga_token\fP  src, \fI\%fpga_token\fP  *dst) 
Clone a fpga_token object
.sp
Creates a copy of an fpga_token object.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This call creates a new token object and allocates memory for it. It is the responsibility of the using application to free this memory after use by calling \fI\%fpgaDestroyToken()\fP for the cloned token.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsrc\fP – \fB[in]\fP fpga_token object to copy 
.IP \(bu 2
\fBdst\fP – \fB[out]\fP New fpga_token object cloned from ‘src’ 
.UNINDENT
.TP
.B Returns
FPGA_OK on success 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaDestroyToken(\fI\%fpga_token\fP  *token) 
Destroy a Token
.sp
This function destroys a token created by \fI\%fpgaEnumerate()\fP and frees the associated memory.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%fpgaDestroyToken()\fP requires the address of an fpga_token as previously created by \fI\%fpgaEnumerate()\fP or \fI\%fpgaCloneToken()\fP\&. Passing any other value results in undefined behavior.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
\fBtoken\fP – \fB[in]\fP fpga_token to destroy 
.TP
.B Returns
FPGA_OK on success 
.UNINDENT
.UNINDENT
.SS properties.h
.sp
Functions for examining and manipulating \fBfpga_properties\fP objects. 
.sp
In OPAE, \fBfpga_properties\fP objects are used both for obtaining information about resources and for selectively enumerating resources based on their properties. This file provides accessor functions (get/set) to allow reading and writing individual items of an \fBfpga_properties\fP object. Generally, not all object types supported by OPAE carry all properties. If you call a property accessor method on a \fBfpga_properties\fP object that does not support this particular property, it will return FPGA_INVALID_PARAM.
.SS Accessor Return Values
.sp
In addition to the return values specified in the documentation below, all accessor functions return FPGA_OK on success, FPGA_INVALID_PARAM if you pass NULL or invalid parameters (i.e. non\-initialized properties objects), FPGA_EXCEPTION if an internal exception occurred trying to access the properties object, FPGA_NOT_FOUND if the requested property is not part of the supplied properties object. 
.sp
Functions
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaGetPropertiesFromHandle(\fI\%fpga_handle\fP  handle, \fI\%fpga_properties\fP  *prop) 
Create a fpga_properties object
.sp
Initializes the memory pointed at by \fBprop\fP to represent a properties object, and populates it with the properties of the resource referred to by \fBhandle\fP\&. Individual properties can then be queried using fpgaPropertiesGet*() accessor functions.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%fpgaGetPropertiesFromHandle()\fP will allocate memory for the created properties object returned in \fBprop\fP\&. It is the responsibility of the caller to free this memory after use by calling \fI\%fpgaDestroyProperties()\fP\&.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Open handle to get properties for. 
.IP \(bu 2
\fBprop\fP – \fB[out]\fP Pointer to a variable of type fpga_properties 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_NO_MEMORY if no memory could be allocated to create the \fBfpga_properties\fP object. FPGA_EXCEPTION if an exception happend while initializing the \fBfpga_properties\fP object. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaGetProperties(\fI\%fpga_token\fP  token, \fI\%fpga_properties\fP  *prop) 
Create a fpga_properties object
.sp
Initializes the memory pointed at by \fBprop\fP to represent a properties object, and populates it with the properties of the resource referred to by \fBtoken\fP\&. Individual properties can then be queried using fpgaPropertiesGet*() accessor functions.
.sp
If \fBtoken\fP is NULL, an “empty” properties object is created to be used as a filter for \fI\%fpgaEnumerate()\fP\&. All individual fields are set to \fBdon\fPt care\(ga, which implies that the fpga_properties object would match all FPGA resources if used for an \fI\%fpgaEnumerate()\fP query. The matching criteria can be further refined by using fpgaSet* functions on the properties object, or the object can be populated with the actual properties of a resource by using \fI\%fpgaUpdateProperties()\fP\&.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%fpgaGetProperties()\fP will allocate memory for the created properties object returned in \fBprop\fP\&. It is the responsibility of the caller to free this memory after use by calling \fI\%fpgaDestroyProperties()\fP\&.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBtoken\fP – \fB[in]\fP Token to get properties for. Can be NULL, which will create an empty properties object to be used as a filter for \fI\%fpgaEnumerate()\fP\&. 
.IP \(bu 2
\fBprop\fP – \fB[out]\fP Pointer to a variable of type fpga_properties 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_NO_MEMORY if no memory could be allocated to create the \fBfpga_properties\fP object. FPGA_EXCEPTION if an exception happend while initializing the \fBfpga_properties\fP object. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaUpdateProperties(\fI\%fpga_token\fP  token, \fI\%fpga_properties\fP  prop) 
Update a fpga_properties object
.sp
Populates the properties object ‘prop’ with properties of the resource referred to by ‘token’. Unlike \fI\%fpgaGetProperties()\fP, this call will not create a new properties object or allocate memory for it, but use a previously created properties object.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBtoken\fP – \fB[in]\fP Token to retrieve properties for 
.IP \(bu 2
\fBprop\fP – \fB[in]\fP fpga_properties object to update 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if \fBtoken\fP or \fBprop\fP are not valid objects. FPGA_NOT_FOUND if the resource referred to by \fBtoken\fP was not found. FPGA_NO_DRIVER if not driver is loaded. FPGA_EXCEPTION if an internal exception occured when trying to update \fBprop\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaClearProperties(\fI\%fpga_properties\fP  prop) 
Clear a fpga_properties object
.sp
Sets all fields of the properties object pointed at by ‘prop’ to ‘don’t care’, which implies that the fpga_properties object would match all FPGA resources if used for an \fI\%fpgaEnumerate()\fP query. The matching criteria can be further refined by using fpgaSet* functions on the properties object.
.sp
Instead of creating a new fpga_properties object every time, this function can be used to re\-use fpga_properties objects from previous queries.
.INDENT 7.0
.TP
.B Parameters
\fBprop\fP – \fB[in]\fP fpga_properties object to clear 
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if \fBprop\fP is not a valid object. FPGA_EXCEPTION if an * internal exception occured when trying to access \fBprop\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaCloneProperties(\fI\%fpga_properties\fP  src, \fI\%fpga_properties\fP  *dst) 
Clone a fpga_properties object
.sp
Creates a copy of an fpga_properties object.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This call creates a new properties object and allocates memory for it. Both the ‘src’ and the newly created ‘dst’ objects will eventually need to be destroyed using \fI\%fpgaDestroyProperties()\fP\&.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsrc\fP – \fB[in]\fP fpga_properties object to copy 
.IP \(bu 2
\fBdst\fP – \fB[out]\fP New fpga_properties object cloned from ‘src’ 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if \fBsrc\fP is not a valid object, or if \fBdst\fP is NULL. FPGA_NO_MEMORY if there was not enough memory to allocate an \fBfpga_properties\fP object for \fBdst\fP\&. FPGA_EXCEPTION if an internal exception occurred either accessing \fBsrc\fP or updating \fBdst\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaDestroyProperties(\fI\%fpga_properties\fP  *prop) 
Destroy a fpga_properties object
.sp
Destroys an existing fpga_properties object that the caller has previously created using \fI\%fpgaGetProperties()\fP or \fI\%fpgaCloneProperties()\fP\&.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%fpgaDestroyProperties()\fP requires the address of an fpga_properties object, similar to \fI\%fpgaGetPropertiesFromHandle()\fP, \fI\%fpgaGetProperties()\fP, and \fI\%fpgaCloneProperties()\fP\&. Passing any other value results in undefined behavior.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
\fBprop\fP – \fB[inout]\fP Pointer to the fpga_properties object to destroy 
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM is \fBprop\fP is not a valid object. FPGA_EXCEPTION if an internal exception occurrred while trying to access \fBprop\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetParent(const  \fI\%fpga_properties\fP  prop, \fI\%fpga_token\fP  *parent) 
Get the token of the parent object
.sp
Returns the token of the parent of the queried resource in ‘*parent’.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query 
.IP \(bu 2
\fBparent\fP – \fB[out]\fP Pointer to a token variable of the resource ‘prop’ is associated with 
.UNINDENT
.TP
.B Returns
FPGA_NOT_FOUND if resource does not have a parent (e.g. an FPGA_DEVICE resource does not have parents). Also see “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetParent(\fI\%fpga_properties\fP  prop, \fI\%fpga_token\fP  parent) 
Set the token of the parent object
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify 
.IP \(bu 2
\fBparent\fP – \fB[out]\fP Pointer to a token variable of the resource ‘prop’ is associated with 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetObjectType(const  \fI\%fpga_properties\fP  prop, \fI\%fpga_objtype\fP  *objtype) 
Get the object type of a resource
.sp
Returns the object type of the queried resource.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query 
.IP \(bu 2
\fBobjtype\fP – \fB[out]\fP Pointer to an object type variable of the resource ‘prop’ is associated with 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetObjectType(\fI\%fpga_properties\fP  prop, \fI\%fpga_objtype\fP  objtype) 
Set the object type of a resource
.sp
Sets the object type of the resource. * Currently supported object types are FPGA_DEVICE and FPGA_ACCELERATOR.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify 
.IP \(bu 2
\fBobjtype\fP – \fB[out]\fP Object type of the resource ‘prop’ is associated with 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetSegment(const  \fI\%fpga_properties\fP  prop, uint16_t  *segment) 
Get the PCI segment number of a resource
.sp
Returns the segment number of the queried resource.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query 
.IP \(bu 2
\fBsegment\fP – \fB[out]\fP Pointer to a PCI segment variable of the resource ‘prop’ is associated with 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetSegment(\fI\%fpga_properties\fP  prop, uint16_t  segment) 
Set the PCI segment number of a resource
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify 
.IP \(bu 2
\fBsegment\fP – \fB[in]\fP PCI segment number of the resource ‘prop’ is associated with 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetBus(const  \fI\%fpga_properties\fP  prop, uint8_t  *bus) 
Get the PCI bus number of a resource
.sp
Returns the bus number the queried resource.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query 
.IP \(bu 2
\fBbus\fP – \fB[out]\fP Pointer to a PCI bus variable of the resource ‘prop’ is associated with 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetBus(\fI\%fpga_properties\fP  prop, uint8_t  bus) 
Set the PCI bus number of a resource
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify 
.IP \(bu 2
\fBbus\fP – \fB[in]\fP PCI bus number of the resource ‘prop’ is associated with 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetDevice(const  \fI\%fpga_properties\fP  prop, uint8_t  *device) 
Get the PCI device number of a resource
.sp
Returns the device number the queried resource.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query 
.IP \(bu 2
\fBdevice\fP – \fB[out]\fP Pointer to a PCI device variable of the resource ‘prop’ is associated with 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetDevice(\fI\%fpga_properties\fP  prop, uint8_t  device) 
Set the PCI device number of a resource
.sp
Enforces the limitation on the number of devices as specified in the PCI spec.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify 
.IP \(bu 2
\fBdevice\fP – \fB[in]\fP PCI device number of the resource ‘prop’ is associated with 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetFunction(const  \fI\%fpga_properties\fP  prop, uint8_t  *function) 
Get the PCI function number of a resource
.sp
Returns the function number the queried resource.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query 
.IP \(bu 2
\fBfunction\fP – \fB[out]\fP Pointer to PCI function variable of the resource ‘prop’ is associated with 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetFunction(\fI\%fpga_properties\fP  prop, uint8_t  function) 
Set the PCI function number of a resource
.sp
Enforces the limitation on the number of functions as specified in the PCI spec.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify 
.IP \(bu 2
\fBfunction\fP – \fB[in]\fP PCI function number of the resource ‘prop’ is associated with 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetSocketID(const  \fI\%fpga_properties\fP  prop, uint8_t  *socket_id) 
Get the socket id of a resource
.sp
Returns the socket id of the queried resource.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query 
.IP \(bu 2
\fBsocket_id\fP – \fB[out]\fP Pointer to a socket id variable of the resource ‘prop’ is associated with 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. See also “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetSocketID(\fI\%fpga_properties\fP  prop, uint8_t  socket_id) 
Set the socket id of the resource
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify 
.IP \(bu 2
\fBsocket_id\fP – \fB[in]\fP Socket id of the resource ‘prop’ is associated with 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetDeviceID(const  \fI\%fpga_properties\fP  prop, uint16_t  *device_id) 
Get the device id of the resource
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query 
.IP \(bu 2
\fBdevice_id\fP – \fB[out]\fP Pointer to a device id variable of the resource ‘prop’ is associated with 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetDeviceID(\fI\%fpga_properties\fP  prop, uint16_t  device_id) 
Set the device id of the resource
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify 
.IP \(bu 2
\fBdevice_id\fP – \fB[in]\fP Device id of the resource ‘prop’ is associated with 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetNumSlots(const  \fI\%fpga_properties\fP  prop, uint32_t  *num_slots) 
Get the number of slots of an FPGA resource property
.sp
Returns the number of slots present in an FPGA.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query \- must be of type FPGA_DEVICE 
.IP \(bu 2
\fBnum_slots\fP – \fB[out]\fP Pointer to number of slots variable of the FPGA 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetNumSlots(\fI\%fpga_properties\fP  prop, uint32_t  num_slots) 
Set the number of slots of an FPGA resource property
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify \- must be of type FPGA_DEVICE 
.IP \(bu 2
\fBnum_slots\fP – \fB[in]\fP Number of slots of the FPGA 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetBBSID(const  \fI\%fpga_properties\fP  prop, uint64_t  *bbs_id) 
Get the BBS ID of an FPGA resource property
.sp
Returns the blue bitstream id of an FPGA.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query \- must be of type FPGA_DEVICE 
.IP \(bu 2
\fBbbs_id\fP – \fB[out]\fP Pointer to a bbs id variable of the FPGA 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetBBSID(\fI\%fpga_properties\fP  prop, uint64_t  bbs_id) 
Set the BBS ID of an FPGA resource property
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify \- must be of type FPGA_DEVICE 
.IP \(bu 2
\fBbbs_id\fP – \fB[in]\fP Blue bitstream id of the FPGA resource 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetBBSVersion(const  \fI\%fpga_properties\fP  prop, \fI\%fpga_version\fP  *bbs_version) 
Get the BBS Version of an FPGA resource property
.sp
Returns the blue bitstream version of an FPGA.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query \- must be of type FPGA_DEVICE 
.IP \(bu 2
\fBbbs_version\fP – \fB[out]\fP Pointer to a bbs version variable of the FPGA 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetBBSVersion(\fI\%fpga_properties\fP  prop, \fI\%fpga_version\fP  version) 
Set the BBS Version of an FPGA resource property
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify \- must be of type FPGA_DEVICE 
.IP \(bu 2
\fBversion\fP – \fB[in]\fP Blue bitstream version of the FPGA resource 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetVendorID(const  \fI\%fpga_properties\fP  prop, uint16_t  *vendor_id) 
Get the vendor id of an FPGA resource property
.sp
Returns the vendor id of an FPGA.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This API is not currently supported. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query \- must be of type FPGA_DEVICE 
.IP \(bu 2
\fBvendor_id\fP – \fB[out]\fP Pointer to a vendor id variable of the FPGA 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also “Accessor Return Values” in \fI\%properties.h\fP\&.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetVendorID(\fI\%fpga_properties\fP  prop, uint16_t  vendor_id) 
Set the vendor id of an FPGA resource property
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This API is not currently supported. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify \- must be of type FPGA_DEVICE 
.IP \(bu 2
\fBvendor_id\fP – \fB[in]\fP Vendor id of the FPGA resource 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also “Accessor Return Values” in \fI\%properties.h\fP\&.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetModel(const  \fI\%fpga_properties\fP  prop, char  *model) 
Get the model of an FPGA resource property
.sp
Returns the model of an FPGA.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This API is not currently supported. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query \- must be of type FPGA_DEVICE 
.IP \(bu 2
\fBmodel\fP – \fB[in]\fP Model of the FPGA resource (string of minimum FPGA_MODEL_LENGTH length 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also “Accessor Return Values” in \fI\%properties.h\fP\&.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetModel(\fI\%fpga_properties\fP  prop, char  *model) 
Set the model of an FPGA resource property
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This API is not currently supported. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify \- must be of type FPGA_DEVICE 
.IP \(bu 2
\fBmodel\fP – \fB[in]\fP Model of the FPGA resource (string of maximum FPGA_MODEL_LENGTH length 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also “Accessor Return Values” in \fI\%properties.h\fP\&.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetLocalMemorySize(const  \fI\%fpga_properties\fP  prop, uint64_t  *lms) 
Get the local memory size of an FPGA resource property
.sp
Returns the local memory size of an FPGA.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This API is not currently supported. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query \- must be of type FPGA_DEVICE 
.IP \(bu 2
\fBlms\fP – \fB[out]\fP Pointer to a memory size variable of the FPGA 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also “Accessor Return Values” in \fI\%properties.h\fP\&.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetLocalMemorySize(\fI\%fpga_properties\fP  prop, uint64_t  lms) 
Set the local memory size of an FPGA resource property
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This API is not currently supported. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify \- must be of type FPGA_DEVICE 
.IP \(bu 2
\fBlms\fP – \fB[in]\fP Local memory size of the FPGA resource 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also “Accessor Return Values” in \fI\%properties.h\fP\&.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetCapabilities(const  \fI\%fpga_properties\fP  prop, uint64_t  *capabilities) 
Get the capabilities FPGA resource property
.sp
Returns the capabilities of an FPGA. Capabilities is a bitfield value
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This API is not currently supported. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query \- must be of type FPGA_DEVICE 
.IP \(bu 2
\fBcapabilities\fP – \fB[out]\fP Pointer to a capabilities variable of the FPGA 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also “Accessor Return Values” in \fI\%properties.h\fP\&.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetCapabilities(\fI\%fpga_properties\fP  prop, uint64_t  capabilities) 
Set the capabilities of an FPGA resource property
.sp
Capabilities is a bitfield value
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This API is not currently supported. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify \- must be of type FPGA_DEVICE 
.IP \(bu 2
\fBcapabilities\fP – \fB[in]\fP Capabilities of the FPGA resource 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also “Accessor Return Values” in \fI\%properties.h\fP\&.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetGUID(const  \fI\%fpga_properties\fP  prop, \fI\%fpga_guid\fP  *guid) 
Get the GUID of a resource
.sp
Returns the GUID of an FPGA or accelerator object.
.sp
For an accelerator, the GUID uniquely identifies a specific accelerator context type, i.e. different accelerators will have different GUIDs. For an FPGA, the GUID is used to identify a certain instance of an FPGA, e.g. to determine whether a given bitstream would be compatible.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query 
.IP \(bu 2
\fBguid\fP – \fB[out]\fP Pointer to a GUID of the slot variable 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetGUID(\fI\%fpga_properties\fP  prop, \fI\%fpga_guid\fP  guid) 
Set the GUID of a resource
.sp
Sets the GUID of an FPGA or accelerator object.
.sp
For an accelerator, the GUID uniquely identifies a specific accelerator context type, i.e. different accelerators will have different GUIDs. For an FPGA, the GUID is used to identify a certain instance of an FPGA, e.g. to determine whether a given bitstream would be compatible.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify 
.IP \(bu 2
\fBguid\fP – \fB[out]\fP Pointer to a GUID of the slot variable 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetNumMMIO(const  \fI\%fpga_properties\fP  prop, uint32_t  *mmio_spaces) 
Get the number of mmio spaces
.sp
Returns the number of mmio spaces of an AFU properties structure.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query \- must be of type FPGA_ACCELERATOR 
.IP \(bu 2
\fBmmio_spaces\fP – \fB[out]\fP Pointer to a variable for number of mmio spaces 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_ACCELERATOR. See also “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetNumMMIO(\fI\%fpga_properties\fP  prop, uint32_t  mmio_spaces) 
Set the number of mmio spaces
.sp
Sets the number of mmio spaces of an AFU properties structure.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify \- must be of type FPGA_ACCELERATOR 
.IP \(bu 2
\fBmmio_spaces\fP – \fB[in]\fP Number of MMIO spaces of the accelerator 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_ACCELERATOR. See also “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetNumInterrupts(const  \fI\%fpga_properties\fP  prop, uint32_t  *num_interrupts) 
Get the number of interrupts
.sp
Returns the number of interrupts of an accelerator properties structure.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query \- must be of type FPGA_ACCELERATOR 
.IP \(bu 2
\fBnum_interrupts\fP – \fB[out]\fP Pointer to a variable for number of interrupts 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_ACCELERATOR. See also “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetNumInterrupts(\fI\%fpga_properties\fP  prop, uint32_t  num_interrupts) 
Set the number of interrupts
.sp
Sets the number of interrupts of an accelerator properties structure.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify \- must be of type FPGA_ACCELERATOR 
.IP \(bu 2
\fBnum_interrupts\fP – \fB[in]\fP Number of interrupts of the accelerator 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_ACCELERATOR. See also “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetAcceleratorState(const  \fI\%fpga_properties\fP  prop, \fI\%fpga_accelerator_state\fP  *state) 
Get the state of a accelerator resource property
.sp
Returns the accelerator state of a accelerator.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query \- must be of type FPGA_ACCELERATOR 
.IP \(bu 2
\fBstate\fP – \fB[out]\fP Pointer to a accelerator state variable of the accelerator 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_ACCELERATOR. See also “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetAcceleratorState(\fI\%fpga_properties\fP  prop, \fI\%fpga_accelerator_state\fP  state) 
Set the state of an accelerator resource property
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify \- must be of type FPGA_ACCELERATOR 
.IP \(bu 2
\fBstate\fP – \fB[in]\fP accelerator state of the accelerator resource 
.UNINDENT
.TP
.B Returns
FPGA_INVALID_PARAM if object type is not FPGA_ACCELERATOR. See also “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetObjectID(const  \fI\%fpga_properties\fP  prop, uint64_t  *object_id) 
Get the object ID of a resource
.sp
Returns the object ID of a resource. The object ID is a 64 bit identifier that is unique within a single node or system. It represents a similar concept as the token, but can be used across processes (e.g. passed on the command line).
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query 
.IP \(bu 2
\fBobject_id\fP – \fB[out]\fP Pointer to a 64bit memory location to store the object ID in 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetObjectID(const  \fI\%fpga_properties\fP  prop, uint64_t  object_id) 
Set the object ID of a resource
.sp
Sets the object ID of a resource. The object ID is a 64 bit identifier that is unique within a single node or system. It represents a similar concept as the token, but can be used across processes (e.g. passed on the command line).
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query 
.IP \(bu 2
\fBobject_id\fP – \fB[in]\fP A 64bit value to use as the object ID 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetNumErrors(const  \fI\%fpga_properties\fP  prop, uint32_t  *num_errors) 
Get the number of errors that can be reported by a resource
.sp
Returns the number of error registers understood by a resource.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query 
.IP \(bu 2
\fBnum_errors\fP – \fB[out]\fP Pointer to a 32 bit memory location to store the number of supported errors in 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetNumErrors(const  \fI\%fpga_properties\fP  prop, uint32_t  num_errors) 
Set the number of error registers
.sp
Set the number of error registers understood by a resource to enumerate.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query 
.IP \(bu 2
\fBnum_errors\fP – \fB[in]\fP Number of errors 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetInterface(const  \fI\%fpga_properties\fP  prop, \fI\%fpga_interface\fP  *interface) 
Get the OPAE plugin interface implemented by a resource
.sp
Returns the plugin interface enumerator.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query 
.IP \(bu 2
\fBinterface\fP – \fB[out]\fP Pointer to an fpga_interface location to store the interface in 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetInterface(const  \fI\%fpga_properties\fP  prop, \fI\%fpga_interface\fP  interface) 
Set the OPAE plugin interface implemented by a resource
.sp
Set the plugin interface enumerator.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query 
.IP \(bu 2
\fBinterface\fP – \fB[in]\fP The interface enumerator to set 
.UNINDENT
.TP
.B Returns
See “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetSubsystemVendorID(const  \fI\%fpga_properties\fP  prop, uint16_t  *subsystem_vendor_id) 
Get the subsystem vendor id of an FPGA resource property
.sp
Returns the subsystem vendor id of an FPGA.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query 
.IP \(bu 2
\fBsubsystem_vendor_id\fP – \fB[out]\fP Pointer to a vendor id variable of the FPGA 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. See also “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetSubsystemVendorID(\fI\%fpga_properties\fP  prop, uint16_t  subsystem_vendor_id) 
Set the subsystem vendor id of an FPGA resource property
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify 
.IP \(bu 2
\fBsubsystem_vendor_id\fP – \fB[in]\fP Subsystem Vendor id of the FPGA resource 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. See also “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesGetSubsystemDeviceID(const  \fI\%fpga_properties\fP  prop, uint16_t  *subsystem_device_id) 
Get the subsystem device id of an FPGA resource property
.sp
Returns the subsystem device id of an FPGA.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to query 
.IP \(bu 2
\fBsubsystem_device_id\fP – \fB[out]\fP Pointer to a device id variable of the FPGA 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. See also “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPropertiesSetSubsystemDeviceID(\fI\%fpga_properties\fP  prop, uint16_t  subsystem_device_id) 
Set the subsystem device id of an FPGA resource property
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBprop\fP – \fB[in]\fP Properties object to modify 
.IP \(bu 2
\fBsubsystem_device_id\fP – \fB[in]\fP Subsystem Device id of the FPGA resource 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. See also “Accessor Return Values” in \fI\%properties.h\fP\&. 
.UNINDENT
.UNINDENT
.SS Access API
.sp
The access API provides functions for opening and closing FPGA resources.
Opening a resource yields an fpga_handle, which denotes ownership and can be
used in subsequent API calls to interact with a specific resource. Ownership
can be exclusive or shared.
.SS access.h
.sp
Functions to acquire, release, and reset OPAE FPGA resources. 
.sp
Functions
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaOpen(\fI\%fpga_token\fP  token, \fI\%fpga_handle\fP  *handle, int  flags) 
Open an FPGA object
.sp
Acquires ownership of the FPGA resource referred to by ‘token’.
.sp
Most often this will be used to open an accelerator object to directly interact with an accelerator function, or to open an FPGA object to perform management functions.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBtoken\fP – \fB[in]\fP Pointer to token identifying resource to acquire ownership of 
.IP \(bu 2
\fBhandle\fP – \fB[out]\fP Pointer to preallocated memory to place a handle in. This handle will be used in subsequent API calls. 
.IP \(bu 2
\fBflags\fP – \fB[in]\fP One of the following flags:.INDENT 2.0
.IP \(bu 2
FPGA_OPEN_SHARED allows the resource to be opened multiple times (not supported in ASE) Shared resources (including buffers) are released when all associated handles have been closed (either explicitly with \fI\%fpgaClose()\fP or by process termination). 
.UNINDENT

.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_NOT_FOUND if the resource for ‘token’ could not be found. FPGA_INVALID_PARAM if ‘token’ does not refer to a resource that can be opened, or if either argument is NULL or invalid. FPGA_EXCEPTION if an internal exception occurred while creating the handle. FPGA_NO_DRIVER if the driver is not loaded. FPGA_BUSY if trying to open a resource that has already been opened in exclusive mode. FPGA_NO_ACCESS if the current process’ privileges are not sufficient to open the resource. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaClose(\fI\%fpga_handle\fP  handle) 
Close a previously opened FPGA object
.sp
Relinquishes ownership of a previously \fI\%fpgaOpen()\fPed resource. This enables others to acquire ownership if the resource was opened exclusively. Also deallocates / unmaps MMIO and UMsg memory areas.
.INDENT 7.0
.TP
.B Parameters
\fBhandle\fP – \fB[in]\fP Handle to previously opened FPGA object 
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if handle does not refer to an acquired resource, or if handle is NULL. FPGA_EXCEPTION if an internal error occurred while accessing the handle. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaReset(\fI\%fpga_handle\fP  handle) 
Reset an FPGA object
.sp
Performs an accelerator reset.
.INDENT 7.0
.TP
.B Parameters
\fBhandle\fP – \fB[in]\fP Handle to previously opened FPGA object 
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if handle does not refer to an acquired resource or to a resource that cannot be reset. FPGA_EXCEPTION if an internal error occurred while trying to access the handle or resetting the resource. 
.UNINDENT
.UNINDENT
.SS Event API
.sp
The event API provides functions and types for handling asynchronous events
such as errors or accelerator interrupts.
.sp
To natively support asynchronous event, the driver for the FPGA platform
needs to support events natively (in which case the OPAE C library will
register the event directly with the driver). For some platforms that do not
support interrupt\-driven event delivery, you need to run the FPGA Daemon
(fpgad) to enable asynchronous OPAE events. fpgad will act as a proxy for the
application and deliver asynchronous notifications for registered events.
.SS event.h
.sp
Functions for registering events and managing the lifecycle for \fBfpga_event_handle\fPs. 
.sp
OPAE provides an interface to asynchronous events that can be generated by different FPGA resources. The event API provides functions to register for these events; associated with every event a process has registered for is an fpga_event_handle, which encapsulates the OS\-specific data structure for event objects. On Linux, an fpga_event_handle can be used as a file descriptor and passed to select(), poll(), epoll() and similar functions to wait for asynchronous events. 
.sp
Functions
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaCreateEventHandle(\fI\%fpga_event_handle\fP  *event_handle) 
Initialize an event_handle
.sp
Platform independent way to initialize an event_handle used for notifications from the driver to application. For Linux, this function creates an eventfd and returns the eventfd file descriptor in \fB*event_handle\fP\&.
.INDENT 7.0
.TP
.B Parameters
\fBevent_handle\fP – \fB[out]\fP Pointer to event handle variable.
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if \fBevent_handle\fP is NULL. FPGA_NOT_SUPPORTED if platform does not support events. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaDestroyEventHandle(\fI\%fpga_event_handle\fP  *event_handle) 
Destroy an event_handle
.sp
Destroy handle and free resources. On Linux this corresponds to closing the file descriptor pointed to by handle
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%fpgaDestroyEventHandle()\fP requires the address of an event_handle as created by \fI\%fpgaCreateEventHandle()\fP\&. Passing any other value results in undefined behavior.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
\fBevent_handle\fP – \fB[in]\fP Pointer to handle to be destroyed
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if \fBevent_handle\fP is NULL. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaGetOSObjectFromEventHandle(const  \fI\%fpga_event_handle\fP  eh, int  *fd) 
Get OS object from event handle
.sp
Check validity of event handle, and get the OS object used to subscribe and unsubscribe to events. On Linux, the object corresponds to a file descriptor.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBeh\fP – \fB[in]\fP Event handle to get the descriptor value from 
.IP \(bu 2
\fBfd\fP – \fB[out]\fP integer to store the descriptor value
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if \fBevent_handle\fP is invalid. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaRegisterEvent(\fI\%fpga_handle\fP  handle, \fI\%fpga_event_type\fP  event_type, \fI\%fpga_event_handle\fP  event_handle, uint32_t  flags) 
Register an FPGA event
.sp
This function tells the driver that the caller is interested in notification for the event specified by the type and flags pair.
.sp
The event_handle points to an OS specific mechanism for event notification. An event_handle is associated with only a single event.
.sp
In case of user interrupts, the flags parameter will be used to specify the vector ID. The value of the flags parameter indicates the vector ID, no bit encoding is used.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened FPGA resource. 
.IP \(bu 2
\fBevent_type\fP – \fB[in]\fP Type of event 
.IP \(bu 2
\fBevent_handle\fP – \fB[in]\fP Handle to previously opened resource for event notification. 
.IP \(bu 2
\fBflags\fP – \fB[in]\fP Optional argument for specifying additional information about event. For example irq number for interrupt events. 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if handle does not refer to a resource supporting the requested event, or if event_handle is not valid. FPGA_EXCEPTION if an internal exception occurred while accessing the handle or the event_handle. On Linux: FPGA_NO_DAEMON if the driver does not support the requested event and there is no FPGA Daemon (fpgad) running to proxy it. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaUnregisterEvent(\fI\%fpga_handle\fP  handle, \fI\%fpga_event_type\fP  event_type, \fI\%fpga_event_handle\fP  event_handle) 
Unregister an FPGA event
.sp
This function tells the driver that the caller is no longer interested in notification for the event associated with the event_handle
.sp
The event_handle points to an OS specific mechanism for event notification. An event_handle is associated with only a single event.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened FPGA resource. 
.IP \(bu 2
\fBevent_type\fP – \fB[in]\fP Type of event to unregister. 
.IP \(bu 2
\fBevent_handle\fP – \fB[in]\fP Handle to previously registered resource for event notification. 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if handle does not refer to a resource supporting the requested event, or if event_handle is not valid. FPGA_EXCEPTION if an internal error occurred accessing the handle or the event_handle. 
.UNINDENT
.UNINDENT
.SS MMIO and Shared Memory APIs
.sp
These APIs feature functions for mapping and accessing control registers
through memory\-mapped IO (mmio.h), allocating and sharing system memory
buffers with an accelerator (buffer.h), and using low\-latency notifications
(umsg.h).
.SS mmio.h
.sp
Functions for mapping and accessing MMIO space. 
.sp
Most FPGA accelerators provide access to control registers through memory\-mappable address spaces, commonly referred to as “MMIO spaces”. This file provides functions to map, unmap, read, and write MMIO spaces.
.sp
Note that an accelerator may have multiple MMIO spaces, denoted by the \fBmmio_num\fP argument of the APIs below. The meaning and properties of each MMIO space are up to the accelerator designer. 
.sp
Functions
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaWriteMMIO64(\fI\%fpga_handle\fP  handle, uint32_t  mmio_num, uint64_t  offset, uint64_t  value) 
Write 64 bit value to MMIO space
.sp
This function will write to MMIO space of the target object at a specified offset.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened accelerator resource 
.IP \(bu 2
\fBmmio_num\fP – \fB[in]\fP Number of MMIO space to access 
.IP \(bu 2
\fBoffset\fP – \fB[in]\fP Byte offset into MMIO space 
.IP \(bu 2
\fBvalue\fP – \fB[in]\fP Value to write (64 bit) 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaReadMMIO64(\fI\%fpga_handle\fP  handle, uint32_t  mmio_num, uint64_t  offset, uint64_t  *value) 
Read 64 bit value from MMIO space
.sp
This function will read from MMIO space of the target object at a specified offset.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened accelerator resource 
.IP \(bu 2
\fBmmio_num\fP – \fB[in]\fP Number of MMIO space to access 
.IP \(bu 2
\fBoffset\fP – \fB[in]\fP Byte offset into MMIO space 
.IP \(bu 2
\fBvalue\fP – \fB[out]\fP Pointer to memory where read value is returned (64 bit) 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaWriteMMIO32(\fI\%fpga_handle\fP  handle, uint32_t  mmio_num, uint64_t  offset, uint32_t  value) 
Write 32 bit value to MMIO space
.sp
This function will write to MMIO space of the target object at a specified offset.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened accelerator resource 
.IP \(bu 2
\fBmmio_num\fP – \fB[in]\fP Number of MMIO space to access 
.IP \(bu 2
\fBoffset\fP – \fB[in]\fP Byte offset into MMIO space 
.IP \(bu 2
\fBvalue\fP – \fB[in]\fP Value to write (32 bit) 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaReadMMIO32(\fI\%fpga_handle\fP  handle, uint32_t  mmio_num, uint64_t  offset, uint32_t  *value) 
Read 32 bit value from MMIO space
.sp
This function will read from MMIO space of the target object at a specified offset.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened accelerator resource 
.IP \(bu 2
\fBmmio_num\fP – \fB[in]\fP Number of MMIO space to access 
.IP \(bu 2
\fBoffset\fP – \fB[in]\fP Byte offset into MMIO space 
.IP \(bu 2
\fBvalue\fP – \fB[out]\fP Pointer to memory where read value is returned (32 bit) 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaWriteMMIO512(\fI\%fpga_handle\fP  handle, uint32_t  mmio_num, uint64_t  offset, const  void  *value) 
Write 512 bit value to MMIO space
.sp
512 bit MMIO writes may not be supported on all platforms.
.sp
This function will write to MMIO space of the target object at a specified offset.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened accelerator resource 
.IP \(bu 2
\fBmmio_num\fP – \fB[in]\fP Number of MMIO space to access 
.IP \(bu 2
\fBoffset\fP – \fB[in]\fP Byte offset into MMIO space 
.IP \(bu 2
\fBvalue\fP – \fB[in]\fP Pointer to memory holding value to write (512 bits) 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaMapMMIO(\fI\%fpga_handle\fP  handle, uint32_t  mmio_num, uint64_t  **mmio_ptr) 
Map MMIO space
.sp
This function will return a pointer to the specified MMIO space of the target object in process virtual memory, if supported by the target. Some MMIO spaces may be restricted to privileged processes, depending on the used handle and type.
.sp
After mapping the respective MMIO space, you can access it through direct pointer operations (observing supported access sizes and alignments of the target platform and accelerator).
.sp

If the caller passes in NULL for mmio_ptr, no mapping will be performed, and no virtual address will be returned, though the call will return \fBFPGA_OK\fP\&. This implies that all accesses will be performed through \fI\%fpgaReadMMIO32()\fP, \fI\%fpgaWriteMMIO32()\fP, fpgeReadMMIO64(), and \fI\%fpgaWriteMMIO64()\fP\&. This is the only supported case for ASE.
.sp
The number of available MMIO spaces can be retrieved through the num_mmio property (fpgaPropertyGetNumMMIO()).
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
Some targets (such as the ASE simulator) do not support memory\-mapping of IO register spaces and will not return a pointer to an actually mapped space. Instead, they will return \fBFPGA_NOT_SUPPORTED\fP\&. Usually, these platforms still allow the application to issue MMIO operations using \fI\%fpgaReadMMIO32()\fP, \fI\%fpgaWriteMMIO32()\fP, fpgeReadMMIO64(), and \fI\%fpgaWriteMMIO64()\fP\&.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened resource 
.IP \(bu 2
\fBmmio_num\fP – \fB[in]\fP Number of MMIO space to access 
.IP \(bu 2
\fBmmio_ptr\fP – \fB[out]\fP Pointer to memory where a pointer to the MMIO space will be returned. May be NULL, in which case no pointer is returned. Returned address may be NULL if underlying platform does not support memory mapping for register access. 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. FPGA_NO_ACCESS if the process’ permissions are not sufficient to map the requested MMIO space. FPGA_NOT_SUPPORTED if platform does not support memory mapped IO. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaUnmapMMIO(\fI\%fpga_handle\fP  handle, uint32_t  mmio_num) 
Unmap MMIO space
.sp
This function will unmap a previously mapped MMIO space of the target object, rendering any pointers to it invalid.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This call is only supported by hardware targets, not by ASE simulation.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened resource 
.IP \(bu 2
\fBmmio_num\fP – \fB[in]\fP Number of MMIO space to access 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. 
.UNINDENT
.UNINDENT
.SS buffer.h
.sp
Functions for allocating and sharing system memory with an FPGA accelerator. 
.sp
To share memory between a software application and an FPGA accelerator, these functions set up system components (e.g. an IOMMU) to allow accelerator access to a provided memory region.
.sp
There are a number of restrictions on what memory can be shared, depending on platform capabilities. Usually, FPGA accelerators to not have access to virtual address mappings of the CPU, so they can only access physical addresses. To support this, the OPAE C library on Linux uses hugepages to allocate large, contiguous pages of physical memory that can be shared with an accelerator. It also supports sharing memory that has already been allocated by an application, as long as that memory satisfies the requirements of being physically contigous and page\-aligned. 
.sp
Functions
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaPrepareBuffer(\fI\%fpga_handle\fP  handle, uint64_t  len, void  **buf_addr, uint64_t  *wsid, int  flags) 
Prepare a shared memory buffer
.sp
Prepares a memory buffer for shared access between an accelerator and the calling process. This may either include allocation of physical memory, or preparation of already allocated memory for sharing. The latter case is indicated by supplying the FPGA_BUF_PREALLOCATED flag.
.sp
This function will ask the driver to pin the indicated memory (make it non\-swappable), and program the IOMMU to allow access from the accelerator. If the buffer was not pre\-allocated (flag FPGA_BUF_PREALLOCATED), the function will also allocate physical memory of the requested size and map the memory into the caller’s process’ virtual address space. It returns in ‘wsid’ an fpga_buffer object that can be used to program address registers in the accelerator for shared access to the memory.
.sp
When using FPGA_BUF_PREALLOCATED, the input len must be a non\-zero multiple of the page size, else the function returns FPGA_INVALID_PARAM. When not using FPGA_BUF_PREALLOCATED, the input len is rounded up to the nearest multiple of page size.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
As a special case, when FPGA_BUF_PREALLOCATED is present in flags, if len == 0 and buf_addr == NULL, then the function returns FPGA_OK if pre\-allocated buffers are supported. In this case, a return value other than FPGA_OK indicates that pre\-allocated buffers are not supported. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened accelerator resource 
.IP \(bu 2
\fBlen\fP – \fB[in]\fP Length of the buffer to allocate/prepare in bytes 
.IP \(bu 2
\fBbuf_addr\fP – \fB[inout]\fP Virtual address of buffer. Contents may be NULL (OS will choose mapping) or non\-NULL (OS will take contents as a hint for the virtual address). 
.IP \(bu 2
\fBwsid\fP – \fB[out]\fP Handle to the allocated/prepared buffer to be used with other functions 
.IP \(bu 2
\fBflags\fP – \fB[in]\fP Flags. FPGA_BUF_PREALLOCATED indicates that memory pointed at in ‘*buf_addr’ is already allocated an mapped into virtual memory. FPGA_BUF_READ_ONLY pins pages with only read access from the FPGA. 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_NO_MEMORY if the requested memory could not be allocated. FPGA_INVALID_PARAM if invalid parameters were provided, or if the parameter combination is not valid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaReleaseBuffer(\fI\%fpga_handle\fP  handle, uint64_t  wsid) 
Release a shared memory buffer
.sp
Releases a previously prepared shared buffer. If the buffer was allocated using fpgaPrepareBuffer (FPGA_BUF_PREALLOCATED was not specified), this call will deallocate/free that memory. Otherwise, it will only be returned to it’s previous state (pinned/unpinned, cached/non\-cached).
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened accelerator resource 
.IP \(bu 2
\fBwsid\fP – \fB[in]\fP Handle to the allocated/prepared buffer 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if invalid parameters were provided, or if the parameter combination is not valid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaGetIOAddress(\fI\%fpga_handle\fP  handle, uint64_t  wsid, uint64_t  *ioaddr) 
Retrieve base IO address for buffer
.sp
This function is used to acquire the physical base address (on some platforms called IO Virtual Address or IOVA) for a shared buffer identified by wsid.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This function will disappear once the APIs for secure sharing of buffer addresses is implemented.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened accelerator resource 
.IP \(bu 2
\fBwsid\fP – \fB[in]\fP Buffer handle / workspace ID referring to the buffer for which the IO address is requested 
.IP \(bu 2
\fBioaddr\fP – \fB[out]\fP Pointer to memory where the IO address will be returned 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if invalid parameters were provided, or if the parameter combination is not valid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. FPGA_NOT_FOUND if \fBwsid\fP does not refer to a previously shared buffer. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaBindSVA(\fI\%fpga_handle\fP  handle, uint32_t  *pasid) 
Bind IOMMU shared virtual addressing
.sp
When PCIe PASID, ATS and PRS capabilities are enabled, some platforms support binding the IOMMU to user space virtual addresses.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened accelerator resource 
.IP \(bu 2
\fBpasid\fP – \fB[out]\fP Process address space ID, set if not NULL. 
.UNINDENT
.TP
.B Returns
FPGA_OK on success and FPGA_NOT_SUPPORTED otherwise. 
.UNINDENT
.UNINDENT
.SS umsg.h
.sp
FPGA UMsg API. 
.sp
Functions
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaGetNumUmsg(\fI\%fpga_handle\fP  handle, uint64_t  *value) 
Get number of Umsgs
.sp
Retuns number of umsg supported by AFU.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened accelerator resource 
.IP \(bu 2
\fBvalue\fP – \fB[out]\fP Returns number of UMsgs 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if input parameter combination is not valid. FPGA_EXCEPTION if input parameter fpga handle is not valid. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaSetUmsgAttributes(\fI\%fpga_handle\fP  handle, uint64_t  value) 
Sets Umsg hint
.sp
Writes usmg hint bit.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened accelerator resource 
.IP \(bu 2
\fBvalue\fP – \fB[in]\fP Value to use for UMsg hint, Umsg hit is N wide bitvector where N = number of Umsgs. 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if input parameter combination is not valid. FPGA_EXCEPTION if input parameter fpga handle is not valid. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaTriggerUmsg(\fI\%fpga_handle\fP  handle, uint64_t  value) 
Trigger Umsg
.sp
Writes a 64\-bit value to trigger low\-latency accelerator notification mechanism (UMsgs).
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened accelerator resource 
.IP \(bu 2
\fBvalue\fP – \fB[in]\fP Value to use for UMsg 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if input parameter combination is not valid. FPGA_EXCEPTION if input parameter fpga handle is not valid. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaGetUmsgPtr(\fI\%fpga_handle\fP  handle, uint64_t  **umsg_ptr) 
Access UMsg memory directly
.sp
This function will return a pointer to the memory allocated for low latency accelerator notifications (UMsgs).
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened accelerator resource 
.IP \(bu 2
\fBumsg_ptr\fP – \fB[out]\fP Pointer to memory where a pointer to the virtual address space will be returned 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if input parameter combination is not valid. FPGA_EXCEPTION if input parameter fpga handle is not valid. FPGA_NO_MEMORY if memory allocation fails or system doesn’t configure huge pages. 
.UNINDENT
.UNINDENT
.SS Management API
.sp
The management APIs define functions for reconfiguring an FPGA (writing new
partial bitstreams) as well as assigning accelerators to host interfaces.
.SS manage.h
.sp
Functions for managing FPGA configurations. 
.sp
FPGA accelerators can be reprogrammed at run time by providing new partial bitstreams (“green bitstreams”). This file defines API functions for programming green bitstreams as well as for assigning accelerators to host interfaces for more complex deployment setups, such as virtualized systems. 
.sp
Functions
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaAssignPortToInterface(\fI\%fpga_handle\fP  fpga, uint32_t  interface_num, uint32_t  slot_num, int  flags) 
Assign Port to a host interface.
.sp
This function assign Port to a host interface for subsequent use. Only Port that have been assigned to a host interface can be opened by \fI\%fpgaOpen()\fP\&.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfpga\fP – \fB[in]\fP Handle to an FPGA object previously opened that both the host interface and the slot belong to 
.IP \(bu 2
\fBinterface_num\fP – \fB[in]\fP Host interface number 
.IP \(bu 2
\fBslot_num\fP – \fB[in]\fP Slot number 
.IP \(bu 2
\fBflags\fP – \fB[in]\fP Flags (to be defined) 
.UNINDENT
.TP
.B Returns
FPGA_OK on success FPGA_INVALID_PARAM if input parameter combination is not valid. FPGA_EXCEPTION if an exception occcurred accessing the \fBfpga\fP handle. FPGA_NOT_SUPPORTED if driver does not support assignment. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaAssignToInterface(\fI\%fpga_handle\fP  fpga, \fI\%fpga_token\fP  accelerator, uint32_t  host_interface, int  flags) 
Assign an accelerator to a host interface
.sp
This function assigns an accelerator to a host interface for subsequent use. Only accelerators that have been assigned to a host interface can be opened by \fI\%fpgaOpen()\fP\&.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This function is currently not supported.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfpga\fP – \fB[in]\fP Handle to an FPGA object previously opened that both the host interface and the accelerator belong to 
.IP \(bu 2
\fBaccelerator\fP – \fB[in]\fP accelerator to assign 
.IP \(bu 2
\fBhost_interface\fP – \fB[in]\fP Host interface to assign accelerator to 
.IP \(bu 2
\fBflags\fP – \fB[in]\fP Flags (to be defined) 
.UNINDENT
.TP
.B Returns
FPGA_OK on success 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaReleaseFromInterface(\fI\%fpga_handle\fP  fpga, \fI\%fpga_token\fP  accelerator) 
Unassign a previously assigned accelerator
.sp
This function removes the assignment of an accelerator to an host interface (e.g. to be later assigned to a different host interface). As a consequence, the accelerator referred to by token ‘accelerator’ will be reset during the course of this function.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This function is currently not supported.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfpga\fP – \fB[in]\fP Handle to an FPGA object previously opened that both the host interface and the accelerator belong to 
.IP \(bu 2
\fBaccelerator\fP – \fB[in]\fP accelerator to unassign/release 
.UNINDENT
.TP
.B Returns
FPGA_OK on success 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaReconfigureSlot(\fI\%fpga_handle\fP  fpga, uint32_t  slot, const  uint8_t  *bitstream, size_t  bitstream_len, int  flags) 
Reconfigure a slot
.sp
Sends a green bitstream file to an FPGA to reconfigure a specific slot. This call, if successful, will overwrite the currently programmed AFU in that slot with the AFU in the provided bitstream.
.sp
As part of the reconfiguration flow, all accelerators associated with this slot will be unassigned and reset.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
By default, fpgaReconfigureSlot will not allow reconfiguring a slot with an accelerator in use. Add the flag FPGA_RECONF_FORCE to force reconfiguration without checking for accelerators in use. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfpga\fP – \fB[in]\fP Handle to an FPGA object previously opened 
.IP \(bu 2
\fBslot\fP – \fB[in]\fP Token identifying the slot to reconfigure 
.IP \(bu 2
\fBbitstream\fP – \fB[in]\fP Pointer to memory holding the bitstream 
.IP \(bu 2
\fBbitstream_len\fP – \fB[in]\fP Length of the bitstream in bytes 
.IP \(bu 2
\fBflags\fP – \fB[in]\fP Flags that control behavior of reconfiguration. Value of 0 indicates no flags. FPGA_RECONF_FORCE indicates that the bitstream is programmed into the slot without checking if the resource is currently in use. 
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if the provided parameters are not valid. FPGA_EXCEPTION if an internal error occurred accessing the handle or while sending the bitstream data to the driver. FPGA_BUSY if the accelerator for the given slot is in use. FPGA_RECONF_ERROR on errors reported by the driver (such as CRC or protocol errors).
.UNINDENT
.UNINDENT
.SS Metrics API
.sp
The metrics APIs define functions for discovery/enumeration of metrics information
and reading metrics values.
.SS metrics.h
.sp
Functions for Discover/ Enumerates metrics and retrieves values. 
.sp
Functions
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaGetNumMetrics(\fI\%fpga_handle\fP  handle, uint64_t  *num_metrics) 
Enumerates number of metrics
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened fpga resource 
.IP \(bu 2
\fBnum_metrics\fP – \fB[inout]\fP Number of metrics are discovered in fpga resource
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_NOT_FOUND if the Metrics are not discovered 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaGetMetricsInfo(\fI\%fpga_handle\fP  handle, \fI\%fpga_metric_info\fP  *metric_info, uint64_t  *num_metrics) 
Retrieve metrics information
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened fpga resource 
.IP \(bu 2
\fBmetric_info\fP – \fB[inout]\fP Pointer to array of metric info struct user allocates metrics info array
.IP \(bu 2
\fBnum_metrics\fP – \fB[inout]\fP Size of metric info array
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_NOT_FOUND if the Metrics are not found. FPGA_NO_MEMORY if there was not enough memory to enumerates metrics. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaGetMetricsByIndex(\fI\%fpga_handle\fP  handle, uint64_t  *metric_num, uint64_t  num_metric_indexes, \fI\%fpga_metric\fP  *metrics) 
Retrieve metrics values by index
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened fpga resource 
.IP \(bu 2
\fBmetric_num\fP – \fB[inout]\fP Pointer to array of metric index user allocates metric array 
.IP \(bu 2
\fBnum_metric_indexes\fP – \fB[inout]\fP Size of metric array 
.IP \(bu 2
\fBmetrics\fP – \fB[inout]\fP pointer to array of metric struct
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_NOT_FOUND if the Metrics are not found. FPGA_NO_MEMORY if there was not enough memory to enumerates metrics. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaGetMetricsByName(\fI\%fpga_handle\fP  handle, char  **metrics_names, uint64_t  num_metric_names, \fI\%fpga_metric\fP  *metrics) 
Retrieve metric values by names
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened fpga resource 
.IP \(bu 2
\fBmetrics_names\fP – \fB[inout]\fP Pointer to array of metrics name user allocates metrics name array 
.IP \(bu 2
\fBnum_metric_names\fP – \fB[inout]\fP Size of metric name array 
.IP \(bu 2
\fBmetrics\fP – \fB[inout]\fP Pointer to array of metric struct
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_NOT_FOUND if the Metrics are not found 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaGetMetricsThresholdInfo(\fI\%fpga_handle\fP  handle, struct  \fI\%metric_threshold\fP  *metric_thresholds, uint32_t  *num_thresholds) 
Retrieve metrics / sendor threshold information and values
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle to previously opened fpga resource 
.IP \(bu 2
\fBmetrics_threshold\fP – \fB[inout]\fP pointer to array of metric thresholds user allocates threshold array memory Number of thresholds returns enumerated thresholds if user pass NULL metrics_thresholds 
.IP \(bu 2
\fBnum_thresholds\fP – \fB[inout]\fP number of thresholds
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_NOT_FOUND if the Metrics are not found. FPGA_NO_MEMORY if there was not enough memory to enumerates metrics. 
.UNINDENT
.UNINDENT
.SS SysObject
.sp
The SysObject API can be used to get system objects by name. Names used with
the SysObject API are driver\-specific and may not be compatible across plugins
and/or drivers. For example, SysObject names used with the xfpga plugin will
apply to the OPAE Linux Kernel driver and refer to sysfs nodes under the sysfs
tree for the resource used with the SysObject API.
.SS sysobject.h
.sp
Functions to read/write from system objects. On Linux systems with the OPAE kernel driver, this is used to access sysfs nodes created by the driver. 
.sp
Functions
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaTokenGetObject(\fI\%fpga_token\fP  token, const  char  *name, \fI\%fpga_object\fP  *object, int  flags) 
Create an \fBfpga_object\fP data structures. An \fBfpga_object\fP is a handle to an FPGA resource which can be an attribute, register or a container. This object is read\-only. 
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
Names that begin with ‘.’ or ‘/’ or contain ‘..’ are not allowed and result in FPGA_INVALID_PARAM being returned 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBtoken\fP – \fB[in]\fP Token identifying a resource (accelerator or device) 
.IP \(bu 2
\fBname\fP – \fB[in]\fP A key identifying an object belonging to a resource. 
.IP \(bu 2
\fBobject\fP – \fB[out]\fP Pointer to memory to store the object in 
.IP \(bu 2
\fBflags\fP – \fB[in]\fP Control behavior of object identification and creation. FPGA_OBJECT_GLOB is used to indicate that the name should be treated as a globbing expression. FPGA_OBJECT_RECURSE_ONE indicates that subobjects be created for objects one level down from the object identified by name. FPGA_OBJECT_RECURSE_ALL indicates that subobjects be created for all objects below the current object identified by name.
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_NOT_FOUND if an object cannot be found with the given key. FPGA_NOT_SUPPORTED if this function is not supported by the current implementation of this API.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaHandleGetObject(\fI\%fpga_handle\fP  handle, const  char  *name, \fI\%fpga_object\fP  *object, int  flags) 
Create an \fBfpga_object\fP data structure from a handle. An \fBfpga_object\fP is a handle to an FPGA resource which can be an attribute, register, or container. This object has read/write access.. 
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
Names that begin with ‘.’ or ‘/’ or contain ‘..’ are not allowed and result in FPGA_INVALID_PARAM being returned 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP Handle identifying a resource (accelerator or device) 
.IP \(bu 2
\fBname\fP – \fB[in]\fP A key identifying an object belonging to a resource. 
.IP \(bu 2
\fBobject\fP – \fB[out]\fP Pointer to memory to store the object in 
.IP \(bu 2
\fBflags\fP – \fB[in]\fP Control behavior of object identification and creation FPGA_OBJECT_GLOB is used to indicate that the name should be treated as a globbing expression. FPGA_OBJECT_RECURSE_ONE indicates that subobjects be created for objects one level down from the object identified by name. FPGA_OBJECT_RECURSE_ALL indicates that subobjects be created for all objects below the current object identified by name.
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_NOT_FOUND if an object cannot be found with the given key. FPGA_NOT_SUPPORTED if this function is not supported by the current implementation of this API.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaObjectGetObject(\fI\%fpga_object\fP  parent, const  char  *name, \fI\%fpga_object\fP  *object, int  flags) 
Create an \fBfpga_object\fP data structure from a parent object. An \fBfpga_object\fP is a handle to an FPGA resource which can be an attribute, register, or container. If the parent object was created with a handle, then the new object will inherit the handle allowing it to have read\-write access to the object data. 
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
Names that begin with ‘.’ or ‘/’ or contain ‘..’ are not allowed and result in FPGA_INVALID_PARAM being returned 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBparent\fP – \fB[in]\fP A parent container \fBfpga_object\fP\&. 
.IP \(bu 2
\fBname\fP – \fB[in]\fP A key identifying a sub\-object of the parent container. 
.IP \(bu 2
\fBobject\fP – \fB[out]\fP Pointer to memory to store the object in. 
.IP \(bu 2
\fBflags\fP – \fB[in]\fP Control behavior of object identification and creation. FPGA_OBJECT_GLOB is used to indicate that the name should be treated as a globbing expression. FPGA_OBJECT_RECURSE_ONE indicates that subobjects be created for objects one level down from the object identified by name. FPGA_OBJECT_RECURSE_ALL indicates that subobjects be created for all objects below the current object identified by name.
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid \- this includes a parent object that is not a container object. FPGA_NOT_FOUND if an object cannot be found with the given key. FPGA_NOT_SUPPORTED if this function is not supported by the current implementation of this API.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaObjectGetObjectAt(\fI\%fpga_object\fP  parent, size_t  idx, \fI\%fpga_object\fP  *object) 
Create an \fBfpga_object\fP data structure from a parent object using a given index. An \fBfpga_object\fP is a handle to an FPGA resource which can be an attribute, register, or container. If the parent object was created with a handle, then the new object will inherit the handle allowing it to have read\-write access to the object data. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBparent\fP – \fB[in]\fP A parent container ‘fpga_object’ 
.IP \(bu 2
\fBidx\fP – \fB[in]\fP A positive index less than the size reported by the parent. 
.IP \(bu 2
\fBobject\fP – \fB[out]\fP Pointer to memory to store the object in.
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid \- this includes a parent object that is not a container object. FPGA_NOT_FOUND if an object cannot be found with the given key. FPGA_NOT_SUPPORTED if this function is not supported by the current implementation of this API. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaObjectGetType(\fI\%fpga_object\fP  obj, enum  \fI\%fpga_sysobject_type\fP  *type) 
Get the sysobject type (container or attribute) 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP – \fB[in]\fP An fpga_object instance 
.IP \(bu 2
\fBtype\fP – \fB[out]\fP The type of object (FPGA_OBJECT_CONTAINER or FPGA_OBJECT_ATTRIBUTE)
.UNINDENT
.TP
.B Returns
FPGA_OK on success, FPGA_INVALID_PARAM if any of the supplied parameters are null or invalid 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaDestroyObject(\fI\%fpga_object\fP  *obj) 
Free memory used for the fpga_object data structure. 
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%fpgaDestroyObject()\fP requires the address of an fpga_object as created by \fI\%fpgaTokenGetObject()\fP, \fI\%fpgaHandleGetObject()\fP, or \fI\%fpgaObjectGetObject()\fP\&. Passing any other value results in undefind behavior.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
\fBobj\fP – Pointer to the fpga_object instance to destroy
.TP
.B Returns
FPGA_OK on success, FPGA_INVALID_PARAM if the object is NULL, FPGA_EXCEPTION if an internal error is encountered. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaObjectGetSize(\fI\%fpga_object\fP  obj, uint32_t  *value, int  flags) 
Retrieve the size of the object. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP – \fB[in]\fP An fpga_object instance. 
.IP \(bu 2
\fBvalue\fP – \fB[out]\fP Pointer to variable to store size in. 
.IP \(bu 2
\fBflags\fP – \fB[in]\fP Flags that control how the object is read If FPGA_OBJECT_SYNC is used then object will update its buffered copy before retrieving the size.
.UNINDENT
.TP
.B Returns
FPGA_OK on success. FPGA_INVALID_PARAM if any of supplied parameters is invalid. FPGA_EXCEPTION if error occurred. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaObjectRead(\fI\%fpga_object\fP  obj, uint8_t  *buffer, size_t  offset, size_t  len, int  flags) 
Read bytes from an FPGA object. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP – \fB[in]\fP An fpga_object instance. 
.IP \(bu 2
\fBbuffer\fP – \fB[out]\fP Pointer to a buffer to read bytes into. 
.IP \(bu 2
\fBoffset\fP – \fB[in]\fP Byte offset relative to objects internal buffer where to begin reading bytes from. 
.IP \(bu 2
\fBlen\fP – \fB[in]\fP The length, in bytes, to read from the object. 
.IP \(bu 2
\fBflags\fP – \fB[in]\fP Flags that control how object is read If FPGA_OBJECT_SYNC is used then object will update its buffered copy before retrieving the data.
.UNINDENT
.TP
.B Returns
FPGA_OK on success, FPGA_INVALID_PARAM if any of the supplied parameters is invalid 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaObjectRead64(\fI\%fpga_object\fP  obj, uint64_t  *value, int  flags) 
Read a 64\-bit value from an FPGA object. The value is assumed to be in string format and will be parsed. See flags below for changing that behavior. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP – \fB[in]\fP An fpga_object instance 
.IP \(bu 2
\fBvalue\fP – \fB[out]\fP Pointer to a 64\-bit variable to store the value in 
.IP \(bu 2
\fBflags\fP – \fB[in]\fP Flags that control how the object is read If FPGA_OBJECT_SYNC is used then object will update its buffered copy before retrieving the data. If FPGA_OBJECT_RAW is used, then the data will be read as raw bytes into the uint64_t pointer variable.
.UNINDENT
.TP
.B Returns
FPGA_OK on success, FPGA_INVALID_PARAM if any of the supplied parameters is invalid 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  fpgaObjectWrite64(\fI\%fpga_object\fP  obj, uint64_t  value, int  flags) 
Write 64\-bit value to an FPGA object. The value will be converted to string before writing. See flags below for changing that behavior. 
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
The object must have been created using a handle to a resource. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP – \fB[in]\fP An fpga_object instance. 
.IP \(bu 2
\fBvalue\fP – \fB[in]\fP The value to write to the object 
.IP \(bu 2
\fBflags\fP – \fB[in]\fP Flags that control how the object is written If FPGA_OBJECT_RAW is used, then the value will be written as raw bytes.
.UNINDENT
.TP
.B Returns
FPGA_OK on success, FPGA_INVALID_PARAM if any of the supplied parameters is invalid
.UNINDENT
.UNINDENT
.SS Utilities
.sp
Functions for mapping fpga_result values to meaningful error strings are
provided by the utilities API.
.SS utils.h
.sp
Utility functions and macros for the FPGA API. 
.sp
Functions
.INDENT 0.0
.TP
.B const  char  *fpgaErrStr(\fI\%fpga_result\fP  e) 
Return human\-readable error message
.sp
Returns a pointer to a human\-readable error message corresponding to the provided fpga_error error code.
.INDENT 7.0
.TP
.B Parameters
\fBe\fP – \fB[in]\fP Error code (as returned by another FPGA API function 
.TP
.B Returns
Pointer to a descriptive error message string 
.UNINDENT
.UNINDENT
.SS Samples
.sp
Code samples demonstrate how to use OPAE C API.
.SS hello_fpga.c
.sp
A code sample illustrates the basic usage of the OPAE C API. 
.sp
The sample is a host application that demonstrates the basic steps of interacting with FPGA using the OPAE library. These steps include:
.sp
.INDENT 0.0
.IP \(bu 2
FPGA enumeration
.IP \(bu 2
Resource acquiring and releasing
.IP \(bu 2
Managing shared memory buffer
.IP \(bu 2
MMIO read and write
.UNINDENT

.sp
The sample also demonstrates OPAE’s object model, such as tokens, handles, and properties.
.sp
The sample requires a native loopback mode (NLB) test image to be loaded on the FPGA. Refer to \fI\%Quick Start Guide\fP for full instructions on building, configuring, and running this code sample. 
.sp
Defines
.INDENT 0.0
.TP
.B TEST_TIMEOUT 
.UNINDENT
.INDENT 0.0
.TP
.B CL(x) 
.UNINDENT
.INDENT 0.0
.TP
.B LOG2_CL 
.UNINDENT
.INDENT 0.0
.TP
.B MB(x) 
.UNINDENT
.INDENT 0.0
.TP
.B CACHELINE_ALIGNED_ADDR(p) 
.UNINDENT
.INDENT 0.0
.TP
.B LPBK1_BUFFER_SIZE 
.UNINDENT
.INDENT 0.0
.TP
.B LPBK1_BUFFER_ALLOCATION_SIZE 
.UNINDENT
.INDENT 0.0
.TP
.B LPBK1_DSM_SIZE 
.UNINDENT
.INDENT 0.0
.TP
.B CSR_SRC_ADDR 
.UNINDENT
.INDENT 0.0
.TP
.B CSR_DST_ADDR 
.UNINDENT
.INDENT 0.0
.TP
.B CSR_CTL 
.UNINDENT
.INDENT 0.0
.TP
.B CSR_STATUS1 
.UNINDENT
.INDENT 0.0
.TP
.B CSR_CFG 
.UNINDENT
.INDENT 0.0
.TP
.B CSR_NUM_LINES 
.UNINDENT
.INDENT 0.0
.TP
.B DSM_STATUS_TEST_COMPLETE 
.UNINDENT
.INDENT 0.0
.TP
.B CSR_AFU_DSM_BASEL 
.UNINDENT
.INDENT 0.0
.TP
.B NLB0_AFUID 
.UNINDENT
.INDENT 0.0
.TP
.B N3000_AFUID 
.UNINDENT
.INDENT 0.0
.TP
.B FPGA_NLB0_UUID_H 
.UNINDENT
.INDENT 0.0
.TP
.B FPGA_NLB0_UUID_L 
.UNINDENT
.INDENT 0.0
.TP
.B ON_ERR_GOTO(res, label, desc) 
.UNINDENT
.INDENT 0.0
.TP
.B GETOPT_STRING 
.UNINDENT
.sp
Functions
.INDENT 0.0
.TP
.B int  usleep(unsigned) 
.UNINDENT
.INDENT 0.0
.TP
.B void  print_err(const  char  *s, \fI\%fpga_result\fP  res) 
.UNINDENT
.INDENT 0.0
.TP
.B void  help(void) 
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  parse_args(int  argc, char  *argv[]) 
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  find_fpga(\fI\%fpga_properties\fP  device_filter, \fI\%fpga_guid\fP  afu_guid, \fI\%fpga_token\fP  *accelerator_token, uint32_t  *num_matches_accelerators) 
.UNINDENT
.INDENT 0.0
.TP
.B bool  probe_for_ase(void) 
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  find_nlb_n3000(\fI\%fpga_handle\fP  accelerator_handle, uint64_t  *afu_baddr) 
.UNINDENT
.INDENT 0.0
.TP
.B int  main(int  argc, char  *argv[]) 
.UNINDENT
.sp
Variables
.INDENT 0.0
.TP
.B struct config config  = {.open_flags = 0,.run_n3000 = 0}
.UNINDENT
.INDENT 0.0
.TP
.B struct  cache_line 
.UNINDENT
.INDENT 0.0
.TP
.B struct  config 
.sp
Public Members
.INDENT 7.0
.TP
.B int  open_flags 
.UNINDENT
.INDENT 7.0
.TP
.B int  run_n3000 
.UNINDENT
.UNINDENT
.SS hello_events.c
.sp
A code sample of using OPAE event API. 
.sp
This sample starts two processes. One process injects an artificial fatal error to sysfs; while the other tries to asynchronously capture and handle the event. This sample code exercises all major functions of the event API, including creating and destroying event handles, register and unregister events, polling on event file descriptor, and getting the OS object associated with an event. For a full discussion of OPAE event API, refer to event.h\&. 
.sp
Defines
.INDENT 0.0
.TP
.B FME_SYSFS_INJECT_ERROR 
.UNINDENT
.INDENT 0.0
.TP
.B ON_ERR_GOTO(res, label, desc) 
.UNINDENT
.INDENT 0.0
.TP
.B GETOPT_STRING 
.UNINDENT
.sp
Functions
.INDENT 0.0
.TP
.B int  usleep(unsigned) 
.UNINDENT
.INDENT 0.0
.TP
.B void  print_err(const  char  *s, \fI\%fpga_result\fP  res) 
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  inject_ras_fatal_error(\fI\%fpga_token\fP  fme_token, uint8_t  err) 
.UNINDENT
.INDENT 0.0
.TP
.B void  *error_thread(void  *arg) 
.UNINDENT
.INDENT 0.0
.TP
.B void  help(void) 
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  parse_args(int  argc, char  *argv[]) 
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%fpga_result\fP  find_fpga(\fI\%fpga_properties\fP  device_filter, \fI\%fpga_token\fP  *fpga, uint32_t  *num_matches) 
.UNINDENT
.INDENT 0.0
.TP
.B int  main(int  argc, char  *argv[]) 
.UNINDENT
.INDENT 0.0
.TP
.B struct  ras_inject_error 
.sp
Public Members
.INDENT 7.0
.TP
.B union  \fI\%ras_inject_error\fP::[anonymous]  [anonymous] 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B ras_inject_error.__unnamed88__
.
Public Members
.INDENT 7.0
.TP
.B uint64_t  csr 
.UNINDENT
.INDENT 7.0
.TP
.B struct  \fI\%ras_inject_error\fP::[anonymous]::[anonymous]  [anonymous] 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B ras_inject_error.__unnamed88__.__unnamed90__
.
Public Members
.INDENT 7.0
.TP
.B uint64_t  catastrophicr_error 
.UNINDENT
.INDENT 7.0
.TP
.B uint64_t  fatal_error 
.UNINDENT
.INDENT 7.0
.TP
.B uint64_t  nonfatal_error 
.UNINDENT
.INDENT 7.0
.TP
.B uint64_t  rsvd 
.UNINDENT
.UNINDENT
.SH OPAE C++ CORE API REFERENCE
.sp
The reference documentation for the OPAE C++ Core API is grouped into the following
sections:
.INDENT 0.0
.IP \(bu 2
\fI\%Overview\fP
.IP \(bu 2
\fI\%Goals\fP
.INDENT 2.0
.IP \(bu 2
\fI\%Simplicity\fP
.IP \(bu 2
\fI\%Extensibility and Interoperability\fP
.IP \(bu 2
\fI\%Modern C++ Coding Practices\fP
.IP \(bu 2
\fI\%Error Handling\fP
.IP \(bu 2
\fI\%Coding Style\fP
.UNINDENT
.IP \(bu 2
\fI\%Fundamental Types\fP
.INDENT 2.0
.IP \(bu 2
\fI\%Properties\fP
.IP \(bu 2
\fI\%pvalue.h\fP
.IP \(bu 2
\fI\%properties.h\fP
.IP \(bu 2
\fI\%Resource Classes\fP
.IP \(bu 2
\fI\%token.h\fP
.IP \(bu 2
\fI\%handle.h\fP
.IP \(bu 2
\fI\%shared_buffer.h\fP
.IP \(bu 2
\fI\%errors.h\fP
.IP \(bu 2
\fI\%events.h\fP
.IP \(bu 2
\fI\%sysobject.h\fP
.IP \(bu 2
\fI\%Exceptions\fP
.IP \(bu 2
\fI\%except.h\fP
.IP \(bu 2
\fI\%Misc\fP
.IP \(bu 2
\fI\%version.h\fP
.UNINDENT
.UNINDENT
.SS Overview
.sp
The OPAE C++ API enables C++ developers with the means to use FPGA resources
by integrating the OPAE software stack into C++ applications.
.SS Goals
.SS Simplicity
.sp
Keep the API as small and lightweight as possible. Although features such as
system validation and orchestration are beyond the scope of this API, using
this API for their development should be relatively easy.
.SS Extensibility and Interoperability
.sp
While keeping to the goal of simplicity, the OPAE C++ API is designed to allow
for better reuse by either extending the API or by integrating with other
languages.
.SS Modern C++ Coding Practices
.sp
The OPAE C++ API uses the C++ 11 standard library and makes use of its features
whenever practical. The OPAE C++ API is also designed to require the minimum
number of third\-party libraries/dependencies.
.SS Error Handling
.sp
The OPAE C++ API is designed to throw exceptions when appropriate. The
structure of OPAE C++ exceptions is similar to the error codes in the
OPAE C API. This gives users of the API more freedom on error handling
while providing better debug information in cases of failure.
.SS Coding Style
.sp
For formatting of the OPAE C++ API complies with most of the recommendations
of the Google C++ style. For example, the OPAE C++ API uses:
.INDENT 0.0
.IP \(bu 2
opening braces on the same line as their scope definition
.IP \(bu 2
spaces instead of tabs for indentation
.IP \(bu 2
indentation of two spaces
.UNINDENT
.SS Fundamental Types
.sp
Basic types for the OPAE C++ API are found in the \fIopae::fpga::types\fP
namespace. They serve as an adapter layer between the OPAE C API and
the OPAE C++ layer. Aside from providing a C++ binding to the C
fundamental types, these types also:
.INDENT 0.0
.IP \(bu 2
manage the lifetime and scope of the corresponding C struct.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
For example a C++ destructor will take care of calling the
appropriate C function to release the data structure being
wrapped.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
provide a friendly syntax for using the OPAE C type.
.UNINDENT
.sp
Most classes in this namespace have a \fIc_type()\fP method that returns
the C data structure being wrapped, making it easy to use the OPAE C++
type with the OPAE C API. Alternatively, most classes in this namespace
have implicit conversion operators that enable interoperability with
the OPAE C API.
.SS Properties
.sp
C++ class \fIproperties\fP wraps \fIfpga_properties\fP and uses \fIpvalue\fP
and \fIguid_t\fP to get and set properties stored in an instance of
an \fIfpga_properties\fP\&. \fIpvalue\fP and \fIguid_t\fP are designed to call
an accessor method in the OPAE C API to either read property
values or write them. Most accessor methods in the OPAE C API
share a similar signature, so \fIpvalue\fP generalizes them into
common operations that translate into calling the corresponding
C API function. \fIguid_t\fP follows similar patterns when reading
or assigning values.
.SS pvalue.h
.INDENT 0.0
.TP
.B namespace  opae 
.INDENT 7.0
.TP
.B namespace  fpga 
.INDENT 7.0
.TP
.B namespace  types 
.INDENT 7.0
.TP
.B struct  guid_t 
\fI#include <opae/cxx/core/pvalue.h>\fP
.sp
Representation of the guid member of a properties object. 
.sp
Public Functions
.INDENT 7.0
.TP
.B inline  guid_t(\fI\%fpga_properties\fP  *p) 
Construct the \fI\%guid_t\fP given its containing fpga_properties. 
.UNINDENT
.INDENT 7.0
.TP
.B inline  void  update() 
Update the local cached copy of the guid. 
.UNINDENT
.INDENT 7.0
.TP
.B inline  operator  uint8_t*() 
Return a raw pointer to the guid. 
.INDENT 7.0
.TP
.B Return values
\fBnullptr\fP – if the guid could not be queried. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B inline  const  uint8_t  *c_type()  const 
Return a raw pointer to the guid. 
.UNINDENT
.INDENT 7.0
.TP
.B inline  \fI\%guid_t\fP  &operator=(\fI\%fpga_guid\fP  g) 
Assign from fpga_guid Sets the guid field of the associated properties object using the OPAE properties API. 
.INDENT 7.0
.TP
.B Parameters
\fBg\fP – \fB[in]\fP The given fpga_guid. 
.TP
.B Returns
a reference to this \fI\%guid_t\fP\&. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B inline  bool  operator==(const  \fI\%fpga_guid\fP  &g) 
Compare contents with an fpga_guid. 
.INDENT 7.0
.TP
.B Return values
\fBThe\fP – result of memcmp of the two objects. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B inline  void  parse(const  char  *str) 
Convert a string representation of a guid to binary. 
.INDENT 7.0
.TP
.B Parameters
\fBstr\fP – \fB[in]\fP The guid string. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B inline  bool  is_set()  const 
Tracks whether the cached local copy of the guid is valid. 
.UNINDENT
.INDENT 7.0
.TP
.B inline  void  invalidate() 
Invalidate the cached local copy of the guid. 
.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B \fI\%fpga_properties\fP  *props_ 
.UNINDENT
.INDENT 7.0
.TP
.B bool  is_set_ 
.UNINDENT
.INDENT 7.0
.TP
.B std::array<uint8_t,  16>  data_ 
.UNINDENT
.sp
Friends
.INDENT 7.0
.TP
.B inline  friend  std::ostream  &operator<<(std::ostream  &ostr, const  \fI\%guid_t\fP  &g) 
Send the string representation of the \fI\%guid_t\fP to the given stream. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B template<typename  T> struct  pvalue 
\fI#include <opae/cxx/core/pvalue.h>\fP
.sp
Wraps OPAE properties defined in the OPAE C API by associating an \fBfpga_properties\fP reference with the getters and setters defined for a property. 
.INDENT 7.0
.TP
.B Template Parameters
\fBT\fP – The type of the property value being wrapped 
.UNINDENT
.sp
Public Types
.INDENT 7.0
.TP
.B typedef  std::conditional<std::is_same<\fI\%T\fP,  char*>::value,  \fI\%fpga_result\fP  (*)(\fI\%fpga_properties\fP,  \fI\%T\fP),  \fI\%fpga_result\fP  (*)(\fI\%fpga_properties\fP,  \fI\%T\fP*)>::type  getter_t 
Define getter function as getter_t For \fBchar*\fP types, do not use T* as the second argument but instead use T. 
.UNINDENT
.INDENT 7.0
.TP
.B typedef  \fI\%fpga_result\fP  (*setter_t)(\fI\%fpga_properties\fP,  \fI\%T\fP) 
Define the setter function as setter_t. 
.UNINDENT
.INDENT 7.0
.TP
.B typedef  std::conditional<std::is_same<\fI\%T\fP,  char*>::value,  typename  std::string,  \fI\%T\fP>::type  copy_t 
Define the type of our copy variable For \fBchar*\fP types use std::string as the copy. 
.UNINDENT
.sp
Public Functions
.INDENT 7.0
.TP
.B inline  pvalue() 
.UNINDENT
.INDENT 7.0
.TP
.B inline  pvalue(\fI\%fpga_properties\fP  *p, \fI\%getter_t\fP  g, \fI\%setter_t\fP  s) 
pvalue contructor that takes in a reference to fpga_properties and corresponding accessor methods for a property 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBp\fP – A reference to an fpga_properties 
.IP \(bu 2
\fBg\fP – The getter function 
.IP \(bu 2
\fBs\fP – The setter function 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B inline  \fI\%pvalue\fP<\fI\%T\fP>  &operator=(const  \fI\%T\fP  &v) 
Overload of \fB=\fP operator that calls the wrapped setter. 
.INDENT 7.0
.TP
.B Parameters
\fBv\fP – The value to set
.TP
.B Returns
A reference to itself 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B inline  bool  operator==(const  \fI\%T\fP  &other) 
Compare a property for equality with a value. 
.INDENT 7.0
.TP
.B Parameters
\fBother\fP – The value being compared to
.TP
.B Returns
Whether or not the property is equal to the value 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B inline  void  update() 
.UNINDENT
.INDENT 7.0
.TP
.B inline  operator  \fI\%copy_t\fP() 
Implicit converter operator \- calls the wrapped getter. 
.INDENT 7.0
.TP
.B Returns
The property value after calling the getter or a default value of the value type 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B inline  \fI\%fpga_result\fP  get_value(\fI\%T\fP  &value)  const 
.UNINDENT
.INDENT 7.0
.TP
.B inline  bool  is_set()  const 
Tracks whether the cached local copy of the pvalue is valid. 
.UNINDENT
.INDENT 7.0
.TP
.B inline  void  invalidate() 
Invalidate the cached local copy of the pvalue. 
.UNINDENT
.INDENT 7.0
.TP
.B inline  void  update() 
Template specialization of \fBchar*\fP type property updater. 
.INDENT 7.0
.TP
.B Returns
The result of the property getter function. 
.UNINDENT
.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B \fI\%fpga_properties\fP  *props_ 
.UNINDENT
.INDENT 7.0
.TP
.B bool  is_set_ 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%getter_t\fP  get_ 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%setter_t\fP  set_ 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%copy_t\fP  copy_ 
.UNINDENT
.sp
Friends
.INDENT 7.0
.TP
.B inline  friend  std::ostream  &operator<<(std::ostream  &ostr, const  \fI\%pvalue\fP<\fI\%T\fP>  &p) 
Stream overalod operator. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBostr\fP – The output stream 
.IP \(bu 2
\fBp\fP – A reference to a pvalue<T> object
.UNINDENT
.TP
.B Returns
The stream operator after streaming the property value 
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS properties.h
.INDENT 0.0
.TP
.B namespace  opae 
.INDENT 7.0
.TP
.B namespace  fpga 
.INDENT 7.0
.TP
.B namespace  types 
.INDENT 7.0
.TP
.B class  properties 
\fI#include <opae/cxx/core/properties.h>\fP
.sp
Wraps an OPAE fpga_properties object.
.sp
properties are information describing an accelerator resource that is identified by its token. The properties are used during enumeration to narrow the search for an accelerator resource, and after enumeration to provide the configuration of that resource. 
.sp
Public Types
.INDENT 7.0
.TP
.B typedef  std::shared_ptr<\fI\%properties\fP>  ptr_t 
.UNINDENT
.sp
Public Functions
.INDENT 7.0
.TP
.B properties(const  \fI\%properties\fP  &p)  =  delete 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%properties\fP  &operator=(const  \fI\%properties\fP  &p)  =  delete 
.UNINDENT
.INDENT 7.0
.TP
.B ~properties() 
.UNINDENT
.INDENT 7.0
.TP
.B inline  \fI\%fpga_properties\fP  c_type()  const 
Get the underlying fpga_properties object. 
.UNINDENT
.INDENT 7.0
.TP
.B inline  operator  \fI\%fpga_properties\fP()  const 
Get the underlying fpga_properties object. 
.UNINDENT
.sp
Public Members
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<\fI\%fpga_objtype\fP>  type 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint32_t>  num_errors 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint16_t>  segment 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint8_t>  bus 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint8_t>  device 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint8_t>  function 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint8_t>  socket_id 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint32_t>  num_slots 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint64_t>  bbs_id 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<\fI\%fpga_version\fP>  bbs_version 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint16_t>  vendor_id 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint16_t>  device_id 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint16_t>  subsystem_vendor_id 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint16_t>  subsystem_device_id 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<char*>  model 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint64_t>  local_memory_size 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint64_t>  capabilities 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint32_t>  num_mmio 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint32_t>  num_interrupts 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<\fI\%fpga_accelerator_state\fP>  accelerator_state 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint64_t>  object_id 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<\fI\%fpga_token\fP>  parent 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<\fI\%fpga_interface\fP>  interface 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%guid_t\fP  guid 
.UNINDENT
.sp
Public Static Functions
.INDENT 7.0
.TP
.B static  \fI\%properties\fP::\fI\%ptr_t\fP  get() 
Create a new properties object. 
.INDENT 7.0
.TP
.B Returns
A properties smart pointer. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B static  \fI\%properties\fP::\fI\%ptr_t\fP  get(\fI\%fpga_guid\fP  guid_in) 
Create a new properties object from a guid. 
.INDENT 7.0
.TP
.B Parameters
\fBguid_in\fP – A guid to set in the properties 
.TP
.B Returns
A properties smart pointer with its guid initialized to guid_in 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B static  \fI\%properties\fP::\fI\%ptr_t\fP  get(\fI\%fpga_objtype\fP  objtype) 
Create a new properties object from an fpga_objtype. 
.INDENT 7.0
.TP
.B Parameters
\fBobjtype\fP – An object type to set in the properties 
.TP
.B Returns
A properties smart pointer with its object type set to objtype. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B static  \fI\%properties\fP::\fI\%ptr_t\fP  get(std::shared_ptr<\fI\%token\fP>  t) 
Retrieve the properties for a given token object. 
.INDENT 7.0
.TP
.B Parameters
\fBt\fP – \fB[in]\fP A token identifying the accelerator resource. 
.TP
.B Returns
A properties smart pointer for the given token. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B static  \fI\%properties\fP::\fI\%ptr_t\fP  get(\fI\%fpga_token\fP  t) 
Retrieve the properties for a given fpga_token. 
.INDENT 7.0
.TP
.B Parameters
\fBt\fP – \fB[in]\fP An fpga_token identifying the accelerator resource. 
.TP
.B Returns
A properties smart pointer for the given fpga_token. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B static  \fI\%properties\fP::\fI\%ptr_t\fP  get(std::shared_ptr<\fI\%handle\fP>  h) 
Retrieve the properties for a given handle object. 
.INDENT 7.0
.TP
.B Parameters
\fBh\fP – \fB[in]\fP A handle identifying the accelerator resource. 
.TP
.B Returns
A properties smart pointer for the given handle. 
.UNINDENT
.UNINDENT
.sp
Public Static Attributes
.INDENT 7.0
.TP
.B static  const  std::vector<\fI\%properties\fP::\fI\%ptr_t\fP>  none 
An empty vector of properties. Useful for enumerating based on a “match all” criteria. 
.UNINDENT
.sp
Private Functions
.INDENT 7.0
.TP
.B properties(bool  alloc_props  =  true) 
.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B \fI\%fpga_properties\fP  props_ 
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Resource Classes
.sp
The \fItoken\fP, \fIhandle\fP, and \fIshared_buffer\fP classes are used to
enumerate and access FPGA resources. \fIproperties\fP are used to
narrow the search space for \fItoken\fP’s. Before enumerating the
accelerator resources in the system, applications can produce
one or more \fIproperties\fP objects whose values are set to the
desired characteristics for the resource. For example, an
application may search for an accelerator resource based on
its guid.
.sp
Once one or more \fItoken\fP’s have been enumerated, the application
must choose which \fItoken\fP’s to request. The \fItoken\fP is then
converted to a \fIhandle\fP by requesting that a \fIhandle\fP object
be allocated and opened for it.
.sp
Once a \fIhandle\fP has been successfully opened, the application
can read and write the associated configuration and status
space. Additionally, the application may use the \fIhandle\fP to
allocate \fIshared_buffer\fP’s or to register \fIevent\fP’s. The
\fIshared_buffer\fP and \fIevent\fP objects retain a reference to
their owning \fIhandle\fP so that the \fIhandle\fP does not lose
scope before freeing the \fIshared_buffer\fP and \fIevent\fP objects.
.SS token.h
.INDENT 0.0
.TP
.B namespace  opae 
.INDENT 7.0
.TP
.B namespace  fpga 
.INDENT 7.0
.TP
.B namespace  types 
.INDENT 7.0
.TP
.B class  token 
\fI#include <opae/cxx/core/token.h>\fP
.sp
Wraps the OPAE fpga_token primitive. token’s are created from an enumeration operation that uses properties describing an accelerator resource as search criteria. 
.sp
Public Types
.INDENT 7.0
.TP
.B typedef  std::shared_ptr<\fI\%token\fP>  ptr_t 
.UNINDENT
.sp
Public Functions
.INDENT 7.0
.TP
.B ~token() 
.UNINDENT
.INDENT 7.0
.TP
.B inline  \fI\%fpga_token\fP  c_type()  const 
Retrieve the underlying fpga_token primitive. 
.UNINDENT
.INDENT 7.0
.TP
.B inline  operator  \fI\%fpga_token\fP()  const 
Retrieve the underlying fpga_token primitive. 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%ptr_t\fP  get_parent()  const 
Retrieve the parent token, or an empty pointer if there is none. 
.UNINDENT
.sp
Public Static Functions
.INDENT 7.0
.TP
.B static  std::vector<\fI\%token\fP::\fI\%ptr_t\fP>  enumerate(const  std::vector<\fI\%properties\fP::\fI\%ptr_t\fP>  &props) 
Obtain a vector of token smart pointers for given search criteria. 
.INDENT 7.0
.TP
.B Parameters
\fBprops\fP – \fB[in]\fP The search criteria. 
.TP
.B Returns
A set of known tokens that match the search. 
.UNINDENT
.UNINDENT
.sp
Private Functions
.INDENT 7.0
.TP
.B token(\fI\%fpga_token\fP  tok) 
.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B \fI\%fpga_token\fP  token_ 
.UNINDENT
.sp
Friends
.INDENT 7.0
.TP
.B friend class handle
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS handle.h
.INDENT 0.0
.TP
.B namespace  opae 
.INDENT 7.0
.TP
.B namespace  fpga 
.INDENT 7.0
.TP
.B namespace  types 
.INDENT 7.0
.TP
.B class  handle 
\fI#include <opae/cxx/core/handle.h>\fP
.sp
An allocated accelerator resource
.sp
Represents an accelerator resource that has been allocated by OPAE. Depending on the type of resource, its register space may be read/written using a handle object. 
.sp
Public Types
.INDENT 7.0
.TP
.B typedef  std::shared_ptr<\fI\%handle\fP>  ptr_t 
.UNINDENT
.sp
Public Functions
.INDENT 7.0
.TP
.B handle(const  \fI\%handle\fP&)  =  delete 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%handle\fP  &operator=(const  \fI\%handle\fP&)  =  delete 
.UNINDENT
.INDENT 7.0
.TP
.B virtual  ~handle() 
.UNINDENT
.INDENT 7.0
.TP
.B inline  \fI\%fpga_handle\fP  c_type()  const 
Retrieve the underlying OPAE handle. 
.UNINDENT
.INDENT 7.0
.TP
.B inline  operator  \fI\%fpga_handle\fP()  const 
Retrieve the underlying OPAE handle. 
.UNINDENT
.INDENT 7.0
.TP
.B void  reconfigure(uint32_t  slot, const  uint8_t  *bitstream, size_t  size, int  flags) 
Load a bitstream into an FPGA slot. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBslot\fP – The slot number to program 
.IP \(bu 2
\fBbitstream\fP – The bitstream binary data 
.IP \(bu 2
\fBsize\fP – The size of the bitstream 
.IP \(bu 2
\fBflags\fP – Flags that control behavior of reconfiguration. Value of 0 indicates no flags. FPGA_RECONF_FORCE indicates that the bitstream is programmed into the slot without checking if the resource is currently in use.
.UNINDENT
.TP
.B Throws
.INDENT 7.0
.IP \(bu 2
\fI\%invalid_param\fP – if the handle is not an FPGA device handle or if the other parameters are not valid. 
.IP \(bu 2
\fI\%exception\fP – if an internal error is encountered. 
.IP \(bu 2
\fI\%busy\fP – if the accelerator for the given slot is in use. 
.IP \(bu 2
\fI\%reconf_error\fP – if errors are reported by the driver (CRC or protocol errors). 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B uint32_t  read_csr32(uint64_t  offset, uint32_t  csr_space  =  0)  const 
Read 32 bits from a CSR belonging to a resource associated with a handle. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoffset\fP – \fB[in]\fP The register offset 
.IP \(bu 2
\fBcsr_space\fP – \fB[in]\fP The CSR space to read from. Default is 0.
.UNINDENT
.TP
.B Returns
The 32\-bit value read from the CSR 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B void  write_csr32(uint64_t  offset, uint32_t  value, uint32_t  csr_space  =  0) 
Write 32 bit to a CSR belonging to a resource associated with a handle. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoffset\fP – \fB[in]\fP The register offset. 
.IP \(bu 2
\fBvalue\fP – \fB[in]\fP The 32\-bit value to write to the register. 
.IP \(bu 2
\fBcsr_space\fP – \fB[in]\fP The CSR space to read from. Default is 0. 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B uint64_t  read_csr64(uint64_t  offset, uint32_t  csr_space  =  0)  const 
Read 64 bits from a CSR belonging to a resource associated with a handle. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoffset\fP – \fB[in]\fP The register offset 
.IP \(bu 2
\fBcsr_space\fP – \fB[in]\fP The CSR space to read from. Default is 0.
.UNINDENT
.TP
.B Returns
The 64\-bit value read from the CSR 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B void  write_csr64(uint64_t  offset, uint64_t  value, uint32_t  csr_space  =  0) 
Write 64 bits to a CSR belonging to a resource associated with a handle. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoffset\fP – \fB[in]\fP The register offset. 
.IP \(bu 2
\fBvalue\fP – \fB[in]\fP The 64\-bit value to write to the register. 
.IP \(bu 2
\fBcsr_space\fP – \fB[in]\fP The CSR space to read from. Default is 0. 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B void  write_csr512(uint64_t  offset, const  void  *value, uint32_t  csr_space  =  0) 
Write 512 bits to a CSR belonging to a resource associated with a handle. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoffset\fP – \fB[in]\fP The register offset. 
.IP \(bu 2
\fBvalue\fP – \fB[in]\fP Pointer to the 512\-bit value to write to the register. 
.IP \(bu 2
\fBcsr_space\fP – \fB[in]\fP The CSR space to read from. Default is 0. 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B uint8_t  *mmio_ptr(uint64_t  offset, uint32_t  csr_space  =  0)  const 
Retrieve a pointer to the MMIO region. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoffset\fP – \fB[in]\fP The byte offset to add to MMIO base. 
.IP \(bu 2
\fBcsr_space\fP – \fB[in]\fP The desired CSR space. Default is 0. 
.UNINDENT
.TP
.B Returns
MMIO base + offset 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B virtual  void  reset() 
Reset the accelerator identified by this handle 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%fpga_result\fP  close() 
Close an accelerator resource (if opened)
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This is available for explicitly closing a handle. The destructor for handle will call close. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Returns
fpga_result indication the result of closing the handle or FPGA_EXCEPTION if handle is not opened
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%token\fP::\fI\%ptr_t\fP  get_token()  const 
Retrieve the token corresponding to this handle object. 
.UNINDENT
.INDENT 7.0
.TP
.B uint32_t  bind_sva() 
Bind IOMMU shared virtual addressing
.INDENT 7.0
.TP
.B Returns
the non\-zero process address space ID on success or zero on failure. 
.UNINDENT
.UNINDENT
.sp
Public Static Functions
.INDENT 7.0
.TP
.B static  \fI\%handle\fP::\fI\%ptr_t\fP  open(\fI\%fpga_token\fP  token, int  flags) 
Open an accelerator resource, given a raw fpga_token
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBtoken\fP – \fB[in]\fP A token describing the accelerator resource to be allocated.
.IP \(bu 2
\fBflags\fP – \fB[in]\fP The flags parameter to \fI\%fpgaOpen()\fP\&.
.UNINDENT
.TP
.B Returns
pointer to the mmio base + offset for the given csr space 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B static  \fI\%handle\fP::\fI\%ptr_t\fP  open(\fI\%token\fP::ptr_t  token, int  flags) 
Open an accelerator resource, given a token object
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBtoken\fP – \fB[in]\fP A token object describing the accelerator resource to be allocated.
.IP \(bu 2
\fBflags\fP – \fB[in]\fP The flags parameter to \fI\%fpgaOpen()\fP\&.
.UNINDENT
.TP
.B Returns
shared ptr to a handle object 
.UNINDENT
.UNINDENT
.sp
Private Functions
.INDENT 7.0
.TP
.B handle(\fI\%fpga_handle\fP  h) 
.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B \fI\%fpga_handle\fP  handle_ 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%fpga_token\fP  token_ 
.UNINDENT
.INDENT 7.0
.TP
.B uint32_t  pasid_ 
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS shared_buffer.h
.INDENT 0.0
.TP
.B namespace  opae 
.INDENT 7.0
.TP
.B namespace  fpga 
.INDENT 7.0
.TP
.B namespace  types 
.INDENT 7.0
.TP
.B class  shared_buffer 
\fI#include <opae/cxx/core/shared_buffer.h>\fP
.sp
Host/AFU shared memory blocks
.sp
\fI\%shared_buffer\fP abstracts a memory block that may be shared between the host cpu and an accelerator. The block may be allocated by the \fI\%shared_buffer\fP class itself (see allocate), or it may be allocated elsewhere and then attached to a \fI\%shared_buffer\fP object via attach. 
.sp
Public Types
.INDENT 7.0
.TP
.B typedef  std::size_t  size_t 
.UNINDENT
.INDENT 7.0
.TP
.B typedef  std::shared_ptr<\fI\%shared_buffer\fP>  ptr_t 
.UNINDENT
.sp
Public Functions
.INDENT 7.0
.TP
.B shared_buffer(const  \fI\%shared_buffer\fP&)  =  delete 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%shared_buffer\fP  &operator=(const  \fI\%shared_buffer\fP&)  =  delete 
.UNINDENT
.INDENT 7.0
.TP
.B virtual  ~shared_buffer() 
\fI\%shared_buffer\fP destructor. 
.UNINDENT
.INDENT 7.0
.TP
.B void  release() 
Disassociate the \fI\%shared_buffer\fP object from the resource used to create it. If the buffer was allocated using the allocate function then the buffer is freed. 
.UNINDENT
.INDENT 7.0
.TP
.B inline  uint8_t  *c_type()  const 
Retrieve the virtual address of the buffer base.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
Instances of a shared buffer can only be created using either ‘allocate’ or ‘attach’ static factory function. Because these functions return a shared pointer (std::shared_ptr) to the instance, references to an instance are counted automatically by design of the shared_ptr class. Calling ‘\fI\%c_type()\fP’ function is provided to get access to the raw data but isn’t used in tracking its reference count. Assigning this to a variable should be done in limited scopes as this variable can be defined in an outer scope and may outlive the \fI\%shared_buffer\fP object. Once the reference count in the shared_ptr reaches zero, the \fI\%shared_buffer\fP object will be released and deallocated, turning any variables assigned from a call to ‘\fI\%c_type()\fP’ into dangling pointers. 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B inline  \fI\%handle\fP::\fI\%ptr_t\fP  owner()  const 
Retrieve the handle smart pointer associated with this buffer. 
.UNINDENT
.INDENT 7.0
.TP
.B inline  \fI\%size_t\fP  size()  const 
Retrieve the length of the buffer in bytes. 
.UNINDENT
.INDENT 7.0
.TP
.B inline  uint64_t  wsid()  const 
Retrieve the underlying buffer’s workspace id. 
.UNINDENT
.INDENT 7.0
.TP
.B inline  uint64_t  io_address()  const 
Retrieve the address of the buffer suitable for programming into the accelerator device. 
.UNINDENT
.INDENT 7.0
.TP
.B void  fill(int  c) 
Write c to each byte location in the buffer. 
.UNINDENT
.INDENT 7.0
.TP
.B int  compare(\fI\%ptr_t\fP  other, \fI\%size_t\fP  len)  const 
Compare this \fI\%shared_buffer\fP (the first len bytes) to that held in other, using memcmp(). 
.UNINDENT
.INDENT 7.0
.TP
.B template<typename  T> inline  \fI\%T\fP  read(\fI\%size_t\fP  offset)  const 
Read a T\-sized block of memory at the given location. 
.INDENT 7.0
.TP
.B Parameters
\fBoffset\fP – \fB[in]\fP The byte offset from the start of the buffer. 
.TP
.B Returns
A T from buffer base + offset. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B template<typename  T> inline  void  write(const  \fI\%T\fP  &value, \fI\%size_t\fP  offset) 
Write a T\-sized block of memory to the given location. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBvalue\fP – \fB[in]\fP The value to write. 
.IP \(bu 2
\fBoffset\fP – \fB[in]\fP The byte offset from the start of the buffer. 
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Public Static Functions
.INDENT 7.0
.TP
.B static  \fI\%shared_buffer\fP::\fI\%ptr_t\fP  allocate(\fI\%handle\fP::ptr_t  handle, \fI\%size_t\fP  len, bool  read_only  =  false) 
\fI\%shared_buffer\fP factory method \- allocate a \fI\%shared_buffer\fP\&. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP The handle used to allocate the buffer. 
.IP \(bu 2
\fBlen\fP – \fB[in]\fP The length in bytes of the requested buffer. 
.UNINDENT
.TP
.B Returns
A valid \fI\%shared_buffer\fP smart pointer on success, or an empty smart pointer on failure. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B static  \fI\%shared_buffer\fP::\fI\%ptr_t\fP  attach(\fI\%handle\fP::ptr_t  handle, uint8_t  *base, \fI\%size_t\fP  len, bool  read_only  =  false) 
Attach a pre\-allocated buffer to a \fI\%shared_buffer\fP object.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhandle\fP – \fB[in]\fP The handle used to attach the buffer. 
.IP \(bu 2
\fBbase\fP – \fB[in]\fP The base of the pre\-allocated memory. 
.IP \(bu 2
\fBlen\fP – \fB[in]\fP The size of the pre\-allocated memory, which must be a multiple of the page size. 
.UNINDENT
.TP
.B Returns
A valid \fI\%shared_buffer\fP smart pointer on success, or an empty smart pointer on failure. 
.UNINDENT
.UNINDENT
.sp
Protected Functions
.INDENT 7.0
.TP
.B shared_buffer(\fI\%handle\fP::ptr_t  handle, \fI\%size_t\fP  len, uint8_t  *virt, uint64_t  wsid, uint64_t  io_address) 
.UNINDENT
.sp
Protected Attributes
.INDENT 7.0
.TP
.B \fI\%handle\fP::\fI\%ptr_t\fP  handle_ 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%size_t\fP  len_ 
.UNINDENT
.INDENT 7.0
.TP
.B uint8_t  *virt_ 
.UNINDENT
.INDENT 7.0
.TP
.B uint64_t  wsid_ 
.UNINDENT
.INDENT 7.0
.TP
.B uint64_t  io_address_ 
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS errors.h
.INDENT 0.0
.TP
.B namespace  opae 
.INDENT 7.0
.TP
.B namespace  fpga 
.INDENT 7.0
.TP
.B namespace  types 
.INDENT 7.0
.TP
.B class  error 
\fI#include <opae/cxx/core/errors.h>\fP
.sp
An error object represents an error register for a resource. This is used to read out the raw value in the register. No parsing is done by this class. 
.sp
Public Types
.INDENT 7.0
.TP
.B typedef  std::shared_ptr<\fI\%error\fP>  ptr_t 
.UNINDENT
.sp
Public Functions
.INDENT 7.0
.TP
.B error(const  \fI\%error\fP  &e)  =  delete 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%error\fP  &operator=(const  \fI\%error\fP  &e)  =  delete 
.UNINDENT
.INDENT 7.0
.TP
.B inline  std::string  name() 
Get the error register name. 
.INDENT 7.0
.TP
.B Returns
A std::string object set to the error name. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B inline  bool  can_clear() 
Indicates whether an error register can be cleared. 
.INDENT 7.0
.TP
.B Returns
A boolean value indicating if the error register can be cleared. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B uint64_t  read_value() 
Read the raw value contained in the associated error register. 
.INDENT 7.0
.TP
.B Returns
A 64\-bit value (unparsed) read from the error register 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B inline  ~error() 
.UNINDENT
.INDENT 7.0
.TP
.B inline  \fI\%fpga_error_info\fP  c_type()  const 
Get the C data structure. 
.INDENT 7.0
.TP
.B Returns
The \fI\%fpga_error_info\fP that contains the name and the can_clear boolean. 
.UNINDENT
.UNINDENT
.sp
Public Static Functions
.INDENT 7.0
.TP
.B static  \fI\%error\fP::\fI\%ptr_t\fP  get(\fI\%token\fP::\fI\%ptr_t\fP  tok, uint32_t  num) 
Factory function for creating an error object. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBtok\fP – The token object representing a resource. 
.IP \(bu 2
\fBnum\fP – The index of the error register. This must be lower than the num_errors property of the resource.
.UNINDENT
.TP
.B Returns
A shared_ptr containing the error object 
.UNINDENT
.UNINDENT
.sp
Private Functions
.INDENT 7.0
.TP
.B error(\fI\%token\fP::ptr_t  token, uint32_t  num) 
.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B \fI\%token\fP::\fI\%ptr_t\fP  token_ 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%fpga_error_info\fP  error_info_ 
.UNINDENT
.INDENT 7.0
.TP
.B uint32_t  error_num_ 
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS events.h
.INDENT 0.0
.TP
.B namespace  opae 
.INDENT 7.0
.TP
.B namespace  fpga 
.INDENT 7.0
.TP
.B namespace  types 
.INDENT 7.0
.TP
.B class  event 
\fI#include <opae/cxx/core/events.h>\fP
.sp
Wraps fpga event routines in OPAE C. 
.sp
Public Types
.INDENT 7.0
.TP
.B typedef  std::shared_ptr<\fI\%event\fP>  ptr_t 
.UNINDENT
.sp
Public Functions
.INDENT 7.0
.TP
.B virtual  ~event() 
Destroy event and associated resources. 
.UNINDENT
.INDENT 7.0
.TP
.B inline  \fI\%fpga_event_handle\fP  get() 
Get the fpga_event_handle contained in this object. 
.INDENT 7.0
.TP
.B Returns
The fpga_event_handle contained in this object 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B operator  \fI\%fpga_event_handle\fP() 
Coversion operator for converting to fpga_event_handle objects. 
.INDENT 7.0
.TP
.B Returns
The fpga_event_handle contained in this object 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B int  os_object()  const 
Get OS Object from the event object. 
.sp
Get an OS specific object from the event which can be used to subscribe for events. On Linux, the object corresponds to a file descriptor that can be used with select/poll/epoll calls.
.INDENT 7.0
.TP
.B Returns
An integer object representing the OS object 
.UNINDENT
.UNINDENT
.sp
Public Static Functions
.INDENT 7.0
.TP
.B static  \fI\%event\fP::\fI\%ptr_t\fP  register_event(\fI\%handle\fP::\fI\%ptr_t\fP  h, \fI\%event\fP::\fI\%type_t\fP  t, int  flags  =  0) 
Factory function to create event objects. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBh\fP – A shared ptr of a resource handle 
.IP \(bu 2
\fBt\fP – The resource type 
.IP \(bu 2
\fBflags\fP – Event registration flags passed on to fpgaRegisterEvent
.UNINDENT
.TP
.B Returns
A shared ptr to an event object 
.UNINDENT
.UNINDENT
.sp
Private Functions
.INDENT 7.0
.TP
.B event(\fI\%handle\fP::\fI\%ptr_t\fP  h, \fI\%event\fP::type_t  t, \fI\%fpga_event_handle\fP  event_h) 
.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B \fI\%handle\fP::\fI\%ptr_t\fP  handle_ 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%event\fP::\fI\%type_t\fP  type_ 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%fpga_event_handle\fP  event_handle_ 
.UNINDENT
.INDENT 7.0
.TP
.B int  os_object_ 
.UNINDENT
.INDENT 7.0
.TP
.B struct  type_t 
\fI#include <opae/cxx/core/events.h>\fP
.sp
C++ struct that is interchangeable with fpga_event_type enum. 
.sp
Public Functions
.INDENT 7.0
.TP
.B inline  type_t(\fI\%fpga_event_type\fP  c_type) 
.UNINDENT
.INDENT 7.0
.TP
.B inline  operator  \fI\%fpga_event_type\fP() 
.UNINDENT
.sp
Public Static Attributes
.INDENT 7.0
.TP
.B static  constexpr  \fI\%fpga_event_type\fP  interrupt  =  \fI\%FPGA_EVENT_INTERRUPT\fP 
.UNINDENT
.INDENT 7.0
.TP
.B static  constexpr  \fI\%fpga_event_type\fP  error  =  \fI\%FPGA_EVENT_ERROR\fP 
.UNINDENT
.INDENT 7.0
.TP
.B static  constexpr  \fI\%fpga_event_type\fP  power_thermal  =  \fI\%FPGA_EVENT_POWER_THERMAL\fP 
.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B \fI\%fpga_event_type\fP  type_ 
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS sysobject.h
.INDENT 0.0
.TP
.B namespace  opae 
.INDENT 7.0
.TP
.B namespace  fpga 
.INDENT 7.0
.TP
.B namespace  types 
.INDENT 7.0
.TP
.B class  sysobject 
\fI#include <opae/cxx/core/sysobject.h>\fP
.sp
Wraps the OPAE fpga_object primitive. sysobject’s are created from a call to fpgaTokenGetObject, fpgaHandleGetObject, or fpgaObjectGetObject 
.sp
Public Types
.INDENT 7.0
.TP
.B typedef  std::shared_ptr<\fI\%sysobject\fP>  ptr_t 
.UNINDENT
.sp
Public Functions
.INDENT 7.0
.TP
.B sysobject()  =  delete 
.UNINDENT
.INDENT 7.0
.TP
.B sysobject(const  \fI\%sysobject\fP  &o)  =  delete 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%sysobject\fP  &operator=(const  \fI\%sysobject\fP  &o)  =  delete 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%sysobject\fP::\fI\%ptr_t\fP  get(const  std::string  &name, int  flags  =  0) 
Get a sysobject from an object. This will be read\-write if its parent was created from a handle.. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBname\fP – \fB[in]\fP An identifier representing an object belonging to this object. 
.IP \(bu 2
\fBflags\fP – \fB[in]\fP Control behavior of object identification and creation. FPGA_OBJECT_GLOB is used to indicate that the name should be treated as a globbing expression. FPGA_OBJECT_RECURSE_ONE indicates that subobjects be created for objects one level down from the object identified by name. FPGA_OBJECT_RECURSE_ALL indicates that subobjects be created for all objects. Flags are defaulted to 0 meaning no flags.
.UNINDENT
.TP
.B Returns
A shared_ptr to a sysobject instance. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%sysobject\fP::\fI\%ptr_t\fP  get(int  index) 
Get a sysobject from a container object. This will be read\-write if its parent was created from a handle.. 
.INDENT 7.0
.TP
.B Parameters
\fBindex\fP – \fB[in]\fP An index number to get.
.TP
.B Returns
A shared_ptr to a sysobject instance. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B virtual  ~sysobject() 
.UNINDENT
.INDENT 7.0
.TP
.B uint32_t  size()  const 
Get the size (in bytes) of the object. 
.INDENT 7.0
.TP
.B Returns
The number of bytes that the object occupies in memory. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B uint64_t  read64(int  flags  =  0)  const 
Read a 64\-bit value from an FPGA object. The value is assumed to be in string format and will be parsed. See flags below for changing that behavior. 
.INDENT 7.0
.TP
.B Parameters
\fBflags\fP – \fB[in]\fP Flags that control how the object is read If FPGA_OBJECT_SYNC is used then object will update its buffered copy before retrieving the data. If FPGA_OBJECT_RAW is used, then the data will be read as raw bytes into the uint64_t pointer variable. Flags are defaulted to 0 meaning no flags.
.TP
.B Returns
A 64\-bit value from the object. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B void  write64(uint64_t  value, int  flags  =  0)  const 
Write 64\-bit value to an FPGA object. The value will be converted to string before writing. See flags below for changing that behavior. 
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This operation will force a sync operation to update its cached buffer 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBvalue\fP – \fB[in]\fP The value to write to the object. 
.IP \(bu 2
\fBflags\fP – \fB[in]\fP Flags that control how the object is written If FPGA_OBJECT_RAW is used, then the value will be written as raw bytes. Flags are defaulted to 0 meaning no flags.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B std::vector<uint8_t>  bytes(int  flags  =  0)  const 
Get all raw bytes from the object. 
.INDENT 7.0
.TP
.B Parameters
\fBflags\fP – \fB[in]\fP Flags that control how object is read If FPGA_OBJECT_SYNC is used then object will update its buffered copy before retrieving the data.
.TP
.B Returns
A vector of all bytes in the object. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B std::vector<uint8_t>  bytes(uint32_t  offset, uint32_t  size, int  flags  =  0)  const 
Get a subset of raw bytes from the object. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoffset\fP – \fB[in]\fP The bytes offset for the start of the returned vector. 
.IP \(bu 2
\fBsize\fP – \fB[in]\fP The number of bytes for the returned vector. 
.IP \(bu 2
\fBflags\fP – \fB[in]\fP Flags that control how object is read If FPGA_OBJECT_SYNC is used then object will update its buffered copy before retrieving the data.
.UNINDENT
.TP
.B Returns
A vector of size bytes in the object starting at offset. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B enum  \fI\%fpga_sysobject_type\fP  type()  const 
Get the object type (attribute or container) 
.UNINDENT
.INDENT 7.0
.TP
.B inline  \fI\%fpga_object\fP  c_type()  const 
Retrieve the underlying fpga_object primitive. 
.UNINDENT
.INDENT 7.0
.TP
.B inline  operator  \fI\%fpga_object\fP()  const 
Retrieve the underlying fpga_object primitive. 
.UNINDENT
.sp
Public Static Functions
.INDENT 7.0
.TP
.B static  \fI\%sysobject\fP::\fI\%ptr_t\fP  get(\fI\%token\fP::\fI\%ptr_t\fP  t, const  std::string  &name, int  flags  =  0) 
Get a sysobject from a token. This will be read\-only. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBt\fP – \fB[in]\fP Token object representing a resource. 
.IP \(bu 2
\fBname\fP – \fB[in]\fP An identifier representing an object belonging to a resource represented by the token. 
.IP \(bu 2
\fBflags\fP – \fB[in]\fP Control behavior of object identification and creation. FPGA_OBJECT_GLOB is used to indicate that the name should be treated as a globbing expression. FPGA_OBJECT_RECURSE_ONE indicates that subobjects be created for objects one level down from the object identified by name. FPGA_OBJECT_RECURSE_ALL indicates that subobjects be created for all objects below the current object identified by name.
.UNINDENT
.TP
.B Returns
A shared_ptr to a sysobject instance. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B static  \fI\%sysobject\fP::\fI\%ptr_t\fP  get(\fI\%handle\fP::\fI\%ptr_t\fP  h, const  std::string  &name, int  flags  =  0) 
Get a sysobject from a handle. This will be read\-write. 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBh\fP – \fB[in]\fP Handle object representing an open resource. 
.IP \(bu 2
\fBname\fP – \fB[in]\fP An identifier representing an object belonging to a resource represented by the handle. 
.IP \(bu 2
\fBflags\fP – \fB[in]\fP Control behavior of object identification and creation. FPGA_OBJECT_GLOB is used to indicate that the name should be treated as a globbing expression. FPGA_OBJECT_RECURSE_ONE indicates that subobjects be created for objects one level down from the object identified by name. FPGA_OBJECT_RECURSE_ALL indicates that subobjects be created for all objects below the current object identified by name.
.UNINDENT
.TP
.B Returns
A shared_ptr to a sysobject instance. 
.UNINDENT
.UNINDENT
.sp
Private Functions
.INDENT 7.0
.TP
.B sysobject(\fI\%fpga_object\fP  sysobj, \fI\%token\fP::ptr_t  token, \fI\%handle\fP::\fI\%ptr_t\fP  hnd) 
.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B \fI\%fpga_object\fP  sysobject_ 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%token\fP::\fI\%ptr_t\fP  token_ 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%handle\fP::\fI\%ptr_t\fP  handle_ 
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Exceptions
.sp
When the OPAE C++ API encounters an error from the OPAE C
API, it captures the current source code location and
the error code into an object of type \fIexcept\fP, then
throws the \fIexcept\fP\&. Applications should implement the
appropriate catch blocks required to respond to runtime
exceptions.
.SS except.h
.sp
Defines
.INDENT 0.0
.TP
.B OPAECXX_HERE 
Construct a src_location object for the current source line. 
.UNINDENT
.INDENT 0.0
.TP
.B ASSERT_FPGA_OK(r) 
Macro to check of result is FPGA_OK If not, throw exception that corresponds to the result code. 
.UNINDENT
.INDENT 0.0
.TP
.B namespace  opae 
.INDENT 7.0
.TP
.B namespace  fpga 
.INDENT 7.0
.TP
.B namespace  types 
.INDENT 7.0
.TP
.B class  src_location 
\fI#include <opae/cxx/core/except.h>\fP
.sp
Identify a particular line in a source file. 
.sp
Public Functions
.INDENT 7.0
.TP
.B src_location(const  char  *file, const  char  *fn, int  line)  noexcept 
\fI\%src_location\fP constructor 
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfile\fP – \fB[in]\fP The source file name, typically \fBFILE\fP\&. 
.IP \(bu 2
\fBfn\fP – \fB[in]\fP The current function, typically \fBfunc\fP\&. 
.IP \(bu 2
\fBline\fP – \fB[in]\fP The current line number, typically \fBLINE\fP\&. 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B src_location(const  \fI\%src_location\fP  &other)  noexcept 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%src_location\fP  &operator=(const  \fI\%src_location\fP  &other)  noexcept 
.UNINDENT
.INDENT 7.0
.TP
.B const  char  *file()  const  noexcept 
Retrieve the file name component of the location. 
.UNINDENT
.INDENT 7.0
.TP
.B inline  const  char  *fn()  const  noexcept 
Retrieve the function name component of the location. 
.UNINDENT
.INDENT 7.0
.TP
.B inline  int  line()  const  noexcept 
Retrieve the line number component of the location. 
.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B const  char  *file_ 
.UNINDENT
.INDENT 7.0
.TP
.B const  char  *fn_ 
.UNINDENT
.INDENT 7.0
.TP
.B int  line_ 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class  except  :  public  std::exception 
\fI#include <opae/cxx/core/except.h>\fP
.sp
Generic OPAE exception
.sp
An except tracks the source line of origin and an optional fpga_result. If no fpga_result is given, then FPGA_EXCEPTION is used. 
.sp
Subclassed by \fI\%opae::fpga::types::busy\fP, \fI\%opae::fpga::types::exception\fP, \fI\%opae::fpga::types::invalid_param\fP, \fI\%opae::fpga::types::no_access\fP, \fI\%opae::fpga::types::no_daemon\fP, \fI\%opae::fpga::types::no_driver\fP, \fI\%opae::fpga::types::no_memory\fP, \fI\%opae::fpga::types::not_found\fP, \fI\%opae::fpga::types::not_supported\fP, \fI\%opae::fpga::types::reconf_error\fP
.sp
Public Functions
.INDENT 7.0
.TP
.B except(\fI\%src_location\fP  loc)  noexcept 
except constructor The fpga_result value is FPGA_EXCEPTION.
.INDENT 7.0
.TP
.B Parameters
\fBloc\fP – \fB[in]\fP Location where the exception was constructed. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B except(\fI\%fpga_result\fP  res, \fI\%src_location\fP  loc)  noexcept 
except constructor
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBres\fP – \fB[in]\fP The fpga_result value associated with this exception. 
.IP \(bu 2
\fBloc\fP – \fB[in]\fP Location where the exception was constructed. 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B except(\fI\%fpga_result\fP  res, const  char  *msg, \fI\%src_location\fP  loc)  noexcept 
except constructor
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBres\fP – \fB[in]\fP The fpga_result value associated with this exception. 
.IP \(bu 2
\fBmsg\fP – \fB[in]\fP The error message as a string 
.IP \(bu 2
\fBloc\fP – \fB[in]\fP Location where the exception was constructed. 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B virtual  const  char  *what()  const  noexcept  override 
Convert this except to an informative string. 
.UNINDENT
.INDENT 7.0
.TP
.B inline  operator  \fI\%fpga_result\fP()  const  noexcept 
Convert this except to its fpga_result. 
.UNINDENT
.sp
Public Static Attributes
.INDENT 7.0
.TP
.B static  const  std::size_t  MAX_EXCEPT  =  256 
.UNINDENT
.sp
Protected Attributes
.INDENT 7.0
.TP
.B \fI\%fpga_result\fP  res_ 
.UNINDENT
.INDENT 7.0
.TP
.B const  char  *msg_ 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%src_location\fP  loc_ 
.UNINDENT
.INDENT 7.0
.TP
.B mutable  char  buf_[\fI\%MAX_EXCEPT\fP] 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class  invalid_param  :  public  \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
\fI\%invalid_param\fP exception
.sp
\fI\%invalid_param\fP tracks the source line of origin for exceptions thrown when the error code FPGA_INVALID_PARAM is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B inline  invalid_param(\fI\%src_location\fP  loc)  noexcept 
\fI\%invalid_param\fP constructor
.INDENT 7.0
.TP
.B Parameters
\fBloc\fP – \fB[in]\fP Location where the exception was constructed. 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class  busy  :  public  \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
busy exception
.sp
busy tracks the source line of origin for exceptions thrown when the error code FPGA_BUSY is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B inline  busy(\fI\%src_location\fP  loc)  noexcept 
busy constructor
.INDENT 7.0
.TP
.B Parameters
\fBloc\fP – \fB[in]\fP Location where the exception was constructed. 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class  exception  :  public  \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
exception exception
.sp
exception tracks the source line of origin for exceptions thrown when the error code FPGA_EXCEPTION is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B inline  exception(\fI\%src_location\fP  loc)  noexcept 
exception constructor
.INDENT 7.0
.TP
.B Parameters
\fBloc\fP – \fB[in]\fP Location where the exception was constructed. 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class  not_found  :  public  \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
\fI\%not_found\fP exception
.sp
\fI\%not_found\fP tracks the source line of origin for exceptions thrown when the error code FPGA_NOT_FOUND is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B inline  not_found(\fI\%src_location\fP  loc)  noexcept 
\fI\%not_found\fP constructor
.INDENT 7.0
.TP
.B Parameters
\fBloc\fP – \fB[in]\fP Location where the exception was constructed. 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class  no_memory  :  public  \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
\fI\%no_memory\fP exception
.sp
\fI\%no_memory\fP tracks the source line of origin for exceptions thrown when the error code FPGA_NO_MEMORY is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B inline  no_memory(\fI\%src_location\fP  loc)  noexcept 
\fI\%no_memory\fP constructor
.INDENT 7.0
.TP
.B Parameters
\fBloc\fP – \fB[in]\fP Location where the exception was constructed. 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class  not_supported  :  public  \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
\fI\%not_supported\fP exception
.sp
\fI\%not_supported\fP tracks the source line of origin for exceptions thrown when the error code FPGA_NOT_SUPPORTED is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B inline  not_supported(\fI\%src_location\fP  loc)  noexcept 
\fI\%not_supported\fP constructor
.INDENT 7.0
.TP
.B Parameters
\fBloc\fP – \fB[in]\fP Location where the exception was constructed. 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class  no_driver  :  public  \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
\fI\%no_driver\fP exception
.sp
\fI\%no_driver\fP tracks the source line of origin for exceptions thrown when the error code FPGA_NO_DRIVER is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B inline  no_driver(\fI\%src_location\fP  loc)  noexcept 
\fI\%no_driver\fP constructor
.INDENT 7.0
.TP
.B Parameters
\fBloc\fP – \fB[in]\fP Location where the exception was constructed. 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class  no_daemon  :  public  \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
\fI\%no_daemon\fP exception
.sp
\fI\%no_daemon\fP tracks the source line of origin for exceptions thrown when the error code FPGA_NO_DAEMON is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B inline  no_daemon(\fI\%src_location\fP  loc)  noexcept 
\fI\%no_daemon\fP constructor
.INDENT 7.0
.TP
.B Parameters
\fBloc\fP – \fB[in]\fP Location where the exception was constructed. 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class  no_access  :  public  \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
\fI\%no_access\fP exception
.sp
\fI\%no_access\fP tracks the source line of origin for exceptions thrown when the error code FPGA_NO_ACCESS is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B inline  no_access(\fI\%src_location\fP  loc)  noexcept 
\fI\%no_access\fP constructor
.INDENT 7.0
.TP
.B Parameters
\fBloc\fP – \fB[in]\fP Location where the exception was constructed. 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class  reconf_error  :  public  \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
\fI\%reconf_error\fP exception
.sp
\fI\%reconf_error\fP tracks the source line of origin for exceptions thrown when the error code FPGA_RECONF_ERROR is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B inline  reconf_error(\fI\%src_location\fP  loc)  noexcept 
\fI\%reconf_error\fP constructor
.INDENT 7.0
.TP
.B Parameters
\fBloc\fP – \fB[in]\fP Location where the exception was constructed. 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B namespace  detail 
.sp
Typedefs
.INDENT 7.0
.TP
.B typedef  bool  (*exception_fn)(\fI\%fpga_result\fP,  const  \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%src_location\fP  &loc) 
typedef function pointer that returns bool if result is FPGA_OK 
.UNINDENT
.sp
Functions
.INDENT 7.0
.TP
.B template<typename  T> constexpr  bool  is_ok(\fI\%fpga_result\fP  result, const  \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%src_location\fP  &loc) 
is_ok is a template function that throws an excpetion of its template argument type if the result code is not FPGA_OK. Otherwise it returns true. 
.UNINDENT
.INDENT 7.0
.TP
.B static  inline  void  assert_fpga_ok(\fI\%fpga_result\fP  result, const  \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%src_location\fP  &loc) 
.UNINDENT
.sp
Variables
.INDENT 7.0
.TP
.B static  \fI\%exception_fn\fP  opae_exceptions[12]  =  {\fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%invalid_param\fP>,  \fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%busy\fP>,  \fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%exception\fP>,  \fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%not_found\fP>,  \fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%no_memory\fP>,  \fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%not_supported\fP>,  \fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%no_driver\fP>,  \fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%no_daemon\fP>,  \fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%no_access\fP>,  \fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%reconf_error\fP>} 
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Misc
.sp
The \fIversion\fP class wraps the OPAE C version API.
.SS version.h
.INDENT 0.0
.TP
.B namespace  opae 
.INDENT 7.0
.TP
.B namespace  fpga 
.INDENT 7.0
.TP
.B namespace  types 
.INDENT 7.0
.TP
.B class  version 
\fI#include <opae/cxx/core/version.h>\fP
.sp
Public Static Functions
.INDENT 7.0
.TP
.B static  \fI\%fpga_version\fP  as_struct() 
Get the package version information as a struct. 
.INDENT 7.0
.TP
.B Returns
The package version as an \fB\fI\%fpga_version\fP\fP struct 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B static  std::string  as_string() 
Get the package version information as a string. 
.INDENT 7.0
.TP
.B Returns
The package version as an \fBstd::string\fP object 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B static  std::string  build() 
Get the package build information as a string. 
.INDENT 7.0
.TP
.B Returns
The package build as an \fBstd::string\fP object 
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SH OPAE PYTHON API REFERENCE
.sp
The reference documentation for the OPAE Python API and is grouped into the
following sections:
.INDENT 0.0
.IP \(bu 2
\fI\%Module Types, Methods, and Constants\fP
.IP \(bu 2
\fI\%Fundamental Types\fP
.INDENT 2.0
.IP \(bu 2
\fI\%Properties\fP
.IP \(bu 2
\fI\%Token\fP
.IP \(bu 2
\fI\%Handle\fP
.IP \(bu 2
\fI\%Event\fP
.IP \(bu 2
\fI\%Shared Buffer\fP
.IP \(bu 2
\fI\%Error\fP
.IP \(bu 2
\fI\%SysObject\fP
.UNINDENT
.UNINDENT
.SS Module Types, Methods, and Constants
.INDENT 0.0
.TP
.B opae.fpga.allocate_shared_buffer(arg0:  \fI\%opae.fpga._opae.handle\fP, arg1:  int) -> opae::fpga::types::shared_buffer
shared_buffer factory method \- allocate a shared buffer object.
Args:
.INDENT 7.0
.INDENT 3.5
handle: An accelerator handle object that identifies an open accelerator
obect to share the buffer with.
len: The length in bytes of the requested buffer.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B opae.fpga.enumerate(*args, **kwargs)
Overloaded function.
.INDENT 7.0
.IP 1. 3
enumerate(arg0: List[opae.fpga._opae.properties]) \-> List[opae::fpga::types::token]
.INDENT 3.0
.INDENT 3.5
Get a list of tokens for the given search criteria.
.sp
Args:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B props(list): A list of properties objects that define the search criteria.
All OPAE properties in each properties object make up one filter.
All properties objects are combined in a union.
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.IP 2. 3
enumerate(
.nf
**
.fi
kwargs) \-> List[opae::fpga::types::token]
.INDENT 3.0
.INDENT 3.5
Get a list of tokens from zero or one filters as defined by kwargs.
If kwargs is empty, then no filter is used.
If kwargs is not empty, then one properties object is created using the kwargs.
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B opae.fpga.errors(arg0:  \fI\%opae.fpga._opae.token\fP) -> List[\fI\%opae.fpga._opae.error\fP]
Get a list of error objects in an FPGA resource.
Each error object represents an error register contained in the resource.
.INDENT 7.0
.TP
.B Args:
tok(token): Token representing an FPGA resource.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B opae.fpga.open(tok:  \fI\%opae.fpga._opae.token\fP, flags:  int  =  0) -> opae::fpga::types::handle
Create a new handle object from a token.
.UNINDENT
.INDENT 0.0
.TP
.B opae.fpga.register_event(handle:  \fI\%opae.fpga._opae.handle\fP, event_type:  opae.fpga._opae.fpga_event_type, flags:  int  =  0) -> opae::fpga::types::event
Factory method used to create events registered to a particular event type.
.INDENT 7.0
.TP
.B Args:
handle: A handle to an OPAE resource.
type(fpga_event_type): The event type to register for. Valid event types are:
.INDENT 7.0
.INDENT 3.5
EVENT_ERROR, EVENT_INTERRUPT, EVENT_POWER_THERMAL
.UNINDENT
.UNINDENT
.sp
flags: Event registration flags that control registration behavior.
.UNINDENT
.UNINDENT
.SS Fundamental Types
.SS Properties
.INDENT 0.0
.TP
.B class  opae.fpga.properties
properties class is a container class for OPAE resource properties.
.INDENT 7.0
.TP
.B __init__(*args, **kwargs)
Overloaded function.
.INDENT 7.0
.IP 1. 3
__init__(self: opae.fpga._opae.properties, 
.nf
**
.fi
kwargs) \-> None
.INDENT 3.0
.INDENT 3.5
Create a new properties object. If kwargs is not included then the
properties object is created with no property values set.
If one of the kwargs keys is an OPAE property name then the kwargs
value is used to initialize the corresponding value in the
properties object.
.sp
Kwargs:
.INDENT 0.0
.INDENT 3.5
parent (token): Token object representing parent resource.
.sp
guid (str): GUID (as a string) of the resource.
.sp
type (fpga_objtype): The object type \- DEVICE or ACCELERATOR.
.sp
segment (uint16_t) : The PCIe segment (or domain) number.
.sp
bus (uint8_t) : The PCIe bus number.
.sp
device (uint8_t) : The PCIe device number.
.sp
function (uint8_t) : The PCIe function number.
.sp
socket_id (uint8_t): The socket ID encoded in the FIM.
.sp
num_slots (uint32_t): Number of slots available in the FPGA.
.sp
num_errors (uint32_t): Number of error registers in the resource.
.sp
bbs_id (uint64_t): The BBS ID encoded in the FIM.
.sp
bbs_version (tuple): The version of the BBS.
.sp
vendor_id (uint16_t): The vendor ID in PCI config space.
.sp
device_id (uint16_t): The device ID in PCI config space.
.sp
subsystem_vendor_id (uint16_t): The subsystem vendor ID in PCI config space.
.sp
subsystem_device_id (uint16_t): The subsystem device ID in PCI config space.
.sp
model (str): The model of the FPGA.
.sp
local_memory_size (uint64_t): The size (in bytes) of the FPGA local memory.
.sp
num_mmio (uint32_t): The number of mmio spaces.
.sp
num_interrupts (uint32_t): The number of interrupts supported by an accelerator.
.sp
accelerator_state (fpga_accelerator_state): The state of the accelerator \- ASSIGNED or UNASSIGNED.
.sp
object_id (uint64_t): The 64\-bit number unique within a single node or system.
.sp
interface (fpga_interface): The interface type \- IFC_DFL, IFC_VFIO, IFC_SIM_DFL, IFC_SIM_VFIO, or IFC_UIO.
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.IP 2. 3
__init__(self: opae.fpga._opae.properties, arg0: opae::fpga::types::token) \-> None
.INDENT 3.0
.INDENT 3.5
Get properties from a token object.
Args:
.INDENT 0.0
.INDENT 3.5
tok (token): The token to read properties from.
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.IP 3. 3
__init__(self: opae.fpga._opae.properties, arg0: opae::fpga::types::handle) \-> None
.INDENT 3.0
.INDENT 3.5
Get properties from a handle object.
Args:
.INDENT 0.0
.INDENT 3.5
h (handle): The handle to read properties from.
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B property  accelerator_state
Get or set the state of an accelerator.
The accelerator state is of type fpga_accelerator_state.
.UNINDENT
.INDENT 7.0
.TP
.B property  bbs_id
Get or set the BBS ID property of a resource.
The resource must be of type DEVICE
.UNINDENT
.INDENT 7.0
.TP
.B property  bbs_version
Get or set the BBS version property of a resource.
The resource must be of type DEVICE
.UNINDENT
.INDENT 7.0
.TP
.B property  bus
Get or set the PCIe bus property of a resource.
.UNINDENT
.INDENT 7.0
.TP
.B property  capabilities
Get or set the capabilities property of a resource.
This is taken directly from the capabilities CSR in the FIM.
.UNINDENT
.INDENT 7.0
.TP
.B property  device
Get or set the PCIe device property of a resource.
.UNINDENT
.INDENT 7.0
.TP
.B property  function
Get or set the PCIe function property of a resource.
.UNINDENT
.INDENT 7.0
.TP
.B property  model
Get or set the model property of a resource.
.UNINDENT
.INDENT 7.0
.TP
.B property  num_interrupts
Get or set the number of interrupt vectors supported by a resource.
.UNINDENT
.INDENT 7.0
.TP
.B property  num_mmio
Get or set the number of mmio spaces in a resource.
.UNINDENT
.INDENT 7.0
.TP
.B property  num_slots
Get or set the number of slots property of a resource.
The resource must be of type DEVICE
.UNINDENT
.INDENT 7.0
.TP
.B property  object_id
Get or set the Object ID  property of a resource. The object id is
a 64\-bit identifier that is unique within a single node or system.
I represents a similar concept as the token but can be serialized
for use across processes
.UNINDENT
.INDENT 7.0
.TP
.B property  parent
Get or set the token representing a parent object of a resource.
The resource must be of type ACCELERATOR
.UNINDENT
.INDENT 7.0
.TP
.B property  socket_id
Get or set the Socket ID  property of a resource. The socket id is
encoded in of the FIM CSRs
.UNINDENT
.INDENT 7.0
.TP
.B property  vendor_id
Get or set the vendor ID  property of a resource.
The vendor ID is part of the PCI ID and is assigned by the
PCI SIG consortium.
.UNINDENT
.UNINDENT
.SS Token
.INDENT 0.0
.TP
.B class  opae.fpga.token
Token for referencing an OPAE resource.
.sp
A token object serves as a reference so a specific resource in the system.
Holding a token does not constitute ownership of an OPAE resource.
It is used to query information about a resource,
or to acquire ownership by calling fpga.open module method.
.INDENT 7.0
.TP
.B find(self: opae.fpga._opae.token, name: str, flags: int = <fpga_sysobject_flags.SYSOBJECT_GLOB: 2>) -> opae::fpga::types::sysobject
Find a sysobject instance from a valid token object.
Args:
.INDENT 7.0
.INDENT 3.5
flags: Flags that control behavior of finding sub\-objects.
SYSOBJECT_GLOB is used to indicate that wildcard patterns (*) are allowed.
SYSOBJECT_RECURSE_ONE is used to indicate that the find routine should recurse one level.
SYSOBJECT_RECURSE_ALL is used to indicate that the find routine should recurse to all children.
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Handle
.INDENT 0.0
.TP
.B class  opae.fpga.handle
.INDENT 7.0
.TP
.B __enter__(self:  \fI\%opae.fpga._opae.handle\fP) -> \fI\%opae.fpga._opae.handle\fP
Context manager protocol enter function.
Simply returns the handle object.
.UNINDENT
.INDENT 7.0
.TP
.B __exit__(self:  \fI\%opae.fpga._opae.handle\fP, *args) -> None
Context manager protocol exit function.
Closes the resource identified by this handle and currently does nothing with the exit arguments.
.UNINDENT
.INDENT 7.0
.TP
.B close(self:  \fI\%opae.fpga._opae.handle\fP) -> opae.fpga._opae.fpga_result
“Close an accelerator associated with handle.”
.UNINDENT
.INDENT 7.0
.TP
.B read_csr32(self:  \fI\%opae.fpga._opae.handle\fP, offset:  int, csr_space:  int  =  0) -> int
Read 32 bits from a CSR belonging to a resource associated with a handle.
Args:
.INDENT 7.0
.INDENT 3.5
offset: The register offset.
csr_space: The CSR space to read from. Default is 0.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B read_csr64(self:  \fI\%opae.fpga._opae.handle\fP, offset:  int, csr_space:  int  =  0) -> int
Read 64 bits from a CSR belonging to a resource associated with a handle.
Args:
.INDENT 7.0
.INDENT 3.5
offset: The register offset.
csr_space: The CSR space to read from. Default is 0.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B reset(self:  \fI\%opae.fpga._opae.handle\fP) -> None
Reset the accelerator associated with this handle.
The accelerator must be opened.
.UNINDENT
.INDENT 7.0
.TP
.B write_csr32(self:  \fI\%opae.fpga._opae.handle\fP, offset:  int, value:  int, csr_space:  int  =  0) -> None
Write 32 bits to a CSR belonging to a resource associated with a handle.
Args:
.INDENT 7.0
.INDENT 3.5
offset: The register offset.
value: The 32\-bit value to write to the register.
csr_space: The CSR space to write from. Default is 0.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B write_csr64(self:  \fI\%opae.fpga._opae.handle\fP, offset:  int, value:  int, csr_space:  int  =  0) -> None
Write 64 bits to a CSR belonging to a resource associated with a handle.
Args:
.INDENT 7.0
.INDENT 3.5
offset: The register offset.
value: The 64\-bit value to write to the register.
csr_space: The CSR space to write from. Default is 0.
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Event
.INDENT 0.0
.TP
.B class  opae.fpga.event
event object are used to register for OPAE events.
Currently, the event types are:
.INDENT 7.0
.INDENT 3.5
EVENT_ERROR
EVENT_INTERRUPT
EVENT_POWER_THERMAL
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B os_object(self:  \fI\%opae.fpga._opae.event\fP) -> int
Get an OS specific object from the event which can be used to subscribe for
events. On Linux, the object corresponds to a file descriptor that can be
used with select/poll/epoll calls.
.UNINDENT
.UNINDENT
.SS Shared Buffer
.INDENT 0.0
.TP
.B class  opae.fpga.shared_buffer
shared_buffer represents a system memory buffer that can be shared with the accelerator.
It implements the Python buffer protocol and can be converted to a native bytearray object.
.INDENT 7.0
.TP
.B compare(self:  \fI\%opae.fpga._opae.shared_buffer\fP, arg0:  \fI\%opae.fpga._opae.shared_buffer\fP, arg1:  int) -> int
Compare this shared_buffer (the first len bytes)  object with another one.
Returns 0 if the two buffers (up to len) are equal.
.UNINDENT
.INDENT 7.0
.TP
.B fill(self:  \fI\%opae.fpga._opae.shared_buffer\fP, arg0:  int) -> None
Fill the buffer with a given value.
.INDENT 7.0
.TP
.B Args:
value: The value to use when filling the buffer.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B io_address(self:  \fI\%opae.fpga._opae.shared_buffer\fP) -> int
Get the address of the buffer suitable for programming into the
accelerator device.
.UNINDENT
.INDENT 7.0
.TP
.B size(self:  \fI\%opae.fpga._opae.shared_buffer\fP) -> int
Get the length of the buffer in bytes.
.UNINDENT
.INDENT 7.0
.TP
.B wsid(self:  \fI\%opae.fpga._opae.shared_buffer\fP) -> int
Get the underlying buffer’s workspace ID.
.UNINDENT
.UNINDENT
.SS Error
.INDENT 0.0
.TP
.B class  opae.fpga.error
error object is used to represent an error register in an FPGA resource.
It holds two read\-only properties, \fIname\fP and \fIcan_clear\fP and it can also
be used to read the raw register value from its corresponding error register.
.INDENT 7.0
.TP
.B property  can_clear
Indicates if the error register can be cleared \- read\-only property
.UNINDENT
.INDENT 7.0
.TP
.B property  name
Error register name \- read\-only property
.UNINDENT
.INDENT 7.0
.TP
.B read_value(self:  \fI\%opae.fpga._opae.error\fP) -> int
Read the raw value from the error register.
.UNINDENT
.UNINDENT
.SS SysObject
.INDENT 0.0
.TP
.B class  opae.fpga.sysobject
Wraps the OPAE fpga_object primitive as a Python object.
.INDENT 7.0
.TP
.B __getattr__(self:  \fI\%opae.fpga._opae.sysobject\fP, arg0:  str) -> \fI\%opae.fpga._opae.sysobject\fP
Get a sysobject instance from a valid sysobject.
The parent sysobject must be a container type object.
.UNINDENT
.INDENT 7.0
.TP
.B __getitem__(*args, **kwargs)
Overloaded function.
.INDENT 7.0
.IP 1. 3
__getitem__(self: opae.fpga._opae.sysobject, arg0: str) \-> opae.fpga._opae.sysobject
.INDENT 3.0
.INDENT 3.5
Get a sysobject instance from a valid sysobject.
The parent sysobject must be a container type object.
.UNINDENT
.UNINDENT
.IP 2. 3
__getitem__(self: opae.fpga._opae.sysobject, arg0: int) \-> object
.INDENT 3.0
.INDENT 3.5
Get a byte from the sysobject at a given index.
Raises \fIRuntimeError\fP if the sysobject instance is a container type.
.UNINDENT
.UNINDENT
.IP 3. 3
__getitem__(self: opae.fpga._opae.sysobject, arg0: slice) \-> str
.INDENT 3.0
.INDENT 3.5
Get a slice of bytes from the sysobject at a given offset.
Raises \fIRuntimeError\fP if the sysobject instance is a container type.
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B bytes(self:  \fI\%opae.fpga._opae.sysobject\fP) -> str
Get bytes from the sysobject.
Raises \fIRuntimeError\fP if the sysobject instance is a container type.
.UNINDENT
.INDENT 7.0
.TP
.B find(self:  \fI\%opae.fpga._opae.sysobject\fP, name:  str, flags:  int  =  0) -> \fI\%opae.fpga._opae.sysobject\fP
Find a sysobject instance from a valid sysobject.
The parent sysobject must be a container type object.
.UNINDENT
.INDENT 7.0
.TP
.B read64(self:  \fI\%opae.fpga._opae.sysobject\fP) -> int
.UNINDENT
.INDENT 7.0
.TP
.B size(self:  \fI\%opae.fpga._opae.sysobject\fP) -> int
.UNINDENT
.INDENT 7.0
.TP
.B write64(self:  \fI\%opae.fpga._opae.sysobject\fP, arg0:  int, arg1:  int) -> None
.UNINDENT
.UNINDENT
.SH PLUGIN DEVELOPER’S GUIDE
.SS Overview
.sp
Beginning with OPAE C library version 1.2.0, OPAE implements a plugin\-centric
model. This guide serves as a reference to define the makeup of an OPAE C API
plugin and to describe a sequence of steps that one may follow when constructing
an OPAE C API plugin.
.SS Plugin Required Functions
.sp
An OPAE C API plugin is a runtime\-loadable shared object library, also known as
a module. On Linux systems, the \fIdl\fP family of APIs from libdl are used to
interact with shared objects. Refer to “man dlopen” and “man dlsym” for examples
of using the libdl API.
.sp
An OPAE C API plugin implements one required function. This function is required
to have C linkage, so that its name is not mangled.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    int opae_plugin_configure(opae_api_adapter_table *table, const char *config);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
During initialization, the OPAE plugin manager component loads each plugin,
searching for its \fBopae_plugin_configure\fP function. If none is found, then
the plugin manager rejects that plugin. When it is found, \fBopae_plugin_configure\fP
is called passing a pointer to a freshly\-created \fBopae_api_adapter_table\fP and
a buffer consisting of configuration data for the plugin.
.sp
The job of the \fBopae_plugin_configure\fP function is to populate the given adapter
table with each of the plugin’s API entry points and to consume and comprehend
the given configuration data in preparation for initialization.
.SS OPAE API Adapter Table
.sp
The adapter table is a data structure that contains function pointer entry points
for each of the OPAE APIs implemented by a plugin. In this way, it adapts the
plugin\-specific behavior to the more general case of a flat C API. Note that
OPAE applications are only required to link with opae\-c. In other words, the
name of the plugin library should not appear on the linker command line. In this
way, plugins are truly decoupled from the OPAE C API, and they are required to
adapt to the strict API specification by populating the adapter table only. No
other linkage is required nor recommended.
.sp
\fBadapter.h\fP contains the definition of the \fBopae_api_adapter_table\fP\&. An abbreviated
version is depicted below, along with supporting type \fBopae_plugin\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    typedef struct _opae_plugin {
        char *path;
        void *dl_handle;
    } opae_plugin;

    typedef struct _opae_api_adapter_table {

        struct _opae_api_adapater_table *next;
        opae_plugin plugin;

        fpga_result (*fpgaOpen)(fpga_token token, fpga_handle *handle,
                                int flags);

        fpga_result (*fpgaClose)(fpga_handle handle);

        ...

        fpga_result (*fpgaEnumerate)(const fpga_properties *filters,
                                     uint32_t num_filters, fpga_token *tokens,
                                     uint32_t max_tokens,
                                     uint32_t *num_matches);

        ...

        // configuration functions
        int (*initialize)(void);
        int (*finalize)(void);

        // first\-level query
        bool (*supports_device)(const char *device_type);
        bool (*supports_host)(const char *hostname);

    } opae_api_adapter_table;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Some points worth noting are that the adapter tables are organized in memory by
adding them to a linked list data structure. This is the use of the \fBnext\fP
structure member. (The list management is handled by the plugin manager.)
The \fBplugin\fP structure member contains the handle to the shared object instance,
as created by \fBdlopen\fP\&. This handle is used in the plugin’s \fBopae_plugin_configure\fP
to load plugin entry points. A plugin need only implement the portion of the
OPAE C API that a target application needs. Any API entry points that are not
supported should be left as NULL pointers (the default) in the adapter table.
When an OPAE API that has no associated entry point in the adapter table is
called, the result for objects associated with that plugin will be
\fBFPGA_NOT_SUPPORTED\fP\&.
.sp
The following code illustrates a portion of the \fBopae_plugin_configure\fP for
a theoretical OPAE C API plugin libfoo.so:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    /* foo_plugin.c */

    int opae_plugin_configure(opae_api_adapter_table *table, const char *config)
    {
        adapter\->fpgaOpen = dlsym(adapter\->plugin.dl_handle, "foo_fpgaOpen");
        adapter\->fpgaClose =
                dlsym(adapter\->plugin.dl_handle, "foo_fpgaClose");

        ...

        adapter\->fpgaEnumerate =
                dlsym(adapter\->plugin.dl_handle, "foo_fpgaEnumerate");

        ...

        return 0;
    }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Notice that the implementations of the API entry points for plugin libfoo.so
are prefixed with \fBfoo_\fP\&. This is the recommended practice to avoid name
collisions and to enhance the debugability of the application. Upon successful
configuration, \fBopae_plugin_configure\fP returns 0 to indicate success. A
non\-zero return value indicates failure and causes the plugin manager to
reject the plugin from futher consideration.
.SS Plugin Optional Functions
.sp
Once the plugin manager loads and configures each plugin, it uses the adapter
table to call back into the plugin so that it can be made ready for runtime.
This is the job of the \fBopae_plugin_initialize\fP entry point, whose signature
is defined as:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    int opae_plugin_initialize(void);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The function takes no parameters, as the configuration data was already given
to the plugin by \fBopae_plugin_configure\fP\&. \fBopae_plugin_initialize\fP returns 0
if no errors were encountered during initialization. A non\-zero return code
indicates that plugin initialization failed. A plugin makes its
\fBopae_plugin_initialize\fP available to the plugin manager by populating the
adapter table’s \fBinitialize\fP entry point as shown:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    /* foo_plugin.c */

    int foo_plugin_initialize(void)
    {
        ...

        return 0; /* success */
    }

    int opae_plugin_configure(opae_api_adapter_table *table, const char *config)
    {
        ... 

        adapter\->initialize =
                dlsym(adapter\->plugin.dl_handle, "foo_plugin_initialize");

        ...

        return 0;
    }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If a plugin does not implement an \fBopae_plugin_initialize\fP entry point, then
the \fBinitialize\fP member of the adapter table should be left uninitialized.
During plugin initialization, if a plugin has no \fBopae_plugin_initialize\fP
entry in its adapter table, the plugin initialization step will be skipped,
and the plugin will be considered to have initialized successfully.
.sp
Once plugin initialization is complete for all loaded plugins, the system
is considered to be running and fully functional.
.sp
During teardown, the plugin manager uses the adapter table to call into each
plugin’s \fBopae_plugin_finalize\fP entry point, whose signature is defined as:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    int opae_plugin_finalize(void);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBopae_plugin_finalize\fP returns 0 if no errors were encountered during teardown.
A non\-zero return code indicates that plugin teardown failed. A plugin makes
its \fBopae_plugin_finalize\fP available to the plugin manager by populating the
adapter table’s \fBfinalize\fP entry point as shown:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    /* foo_plugin.c */

    int foo_plugin_finalize(void)
    {
        ...

        return 0; /* success */
    }

    int opae_plugin_configure(opae_api_adapter_table *table, const char *config)
    {
        ... 

        adapter\->finalize =
                dlsym(adapter\->plugin.dl_handle, "foo_plugin_finalize");

        ...

        return 0;
    }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If a plugin does not implement an \fBopae_plugin_finalize\fP entry point, then
the \fBfinalize\fP member of the adapter table should be left uninitialized.
During plugin cleanup, if a plugin has no \fBopae_plugin_finalize\fP entry
point in its adapter table, the plugin finalize step will be skipped, and
the plugin will be considered to have finalized successfully.
.sp
In addition to \fBinitialize\fP and \fBfinalize\fP, an OPAE C API plugin has two
further optional entry points that relate to device enumeration. During
enumeration, when a plugin is being considered for a type of device, the
plugin may provide input on that decision by exporting an
\fBopae_plugin_supports_device\fP entry point in the adapter table:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    bool opae_plugin_supports_device(const char *device_type);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBopae_plugin_supports_device\fP returns true if the given device type is
supported and false if it is not. A false return value from
\fBopae_plugin_supports_device\fP causes device enumeration to skip the
plugin.
.sp
Populating the \fBopae_plugin_supports_device\fP is done as:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    /* foo_plugin.c */

    bool foo_plugin_supports_device(const char *device_type)
    {
        if (/* device_type is supported */)
            return true;

        ...

        return false;
    }

    int opae_plugin_configure(opae_api_adapter_table *table, const char *config)
    {
        ... 

        adapter\->supports_device =
                dlsym(adapter\->plugin.dl_handle, "foo_plugin_supports_device");

        ...

        return 0;
    }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
The \fIopae_plugin_supports_device\fP mechanism serves as a placeholder only.
It is not implemented in the current version of the OPAE C API.
.UNINDENT
.UNINDENT
.sp
Similarly to determining whether a plugin supports a type of device, a plugin
may also answer questions about network host support by populating an
\fBopae_plugin_supports_host\fP entry point in the adapter table:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    bool opae_plugin_supports_host(const char *hostname);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBopae_plugin_supports_host\fP returns true if the given hostname is supported
and false if it is not. A false return value from \fBopae_plugin_supports_host\fP
causes device enumeration to skip the plugin.
.sp
Populating the \fBopae_plugin_supports_host\fP is done as:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    /* foo_plugin.c */

    bool foo_plugin_supports_host(const char *hostname)
    {
        if (/* hostname is supported */)
            return true;

        ...

        return false;
    }

    int opae_plugin_configure(opae_api_adapter_table *table, const char *config)
    {
        ... 

        adapter\->supports_host =
                dlsym(adapter\->plugin.dl_handle, "foo_plugin_supports_host");

        ...

        return 0;
    }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
The \fIopae_plugin_supports_host\fP mechanism serves as a placeholder only.
It is not implemented in the current version of the OPAE C API.
.UNINDENT
.UNINDENT
.SS Plugin Construction
.sp
The steps required to implement an OPAE C API plugin, libfoo.so, are:
.INDENT 0.0
.IP \(bu 2
Create foo_plugin.c: implements \fBopae_plugin_configure\fP,
\fBopae_plugin_initialize\fP, \fBopae_plugin_finalize\fP, \fBopae_plugin_supports_device\fP,
and \fBopae_plugin_supports_host\fP as described in the previous sections.
.IP \(bu 2
Create foo_plugin.h: implements function prototypes for each of the
plugin\-specific OPAE C APIs.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    /* foo_plugin.h */

    fpga_result foo_fpgaOpen(fpga_token token, fpga_handle *handle,
                             int flags);

    fpga_result foo_fpgaClose(fpga_handle handle);

    ...

    fpga_result foo_fpgaEnumerate(const fpga_properties *filters,
                                  uint32_t num_filters, fpga_token *tokens,
                                  uint32_t max_tokens,
                                  uint32_t *num_matches);
    ...
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
Create foo_types.h: implements plugin\-specific types for opaque data
structures.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    /* foo_types.h */

    struct _foo_token {
        ...
    };

    struct _foo_handle {
        ...
    };

    struct _foo_event_handle {
        ...
    };

    struct _foo_object {
        ...
    };
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
Create foo_enum.c: implements \fBfoo_fpgaEnumerate\fP,
\fBfoo_fpgaCloneToken\fP, and \fBfoo_fpgaDestroyToken\fP\&.
.IP \(bu 2
Create foo_open.c: implements \fBfoo_fpgaOpen\fP\&.
.IP \(bu 2
Create foo_close.c: implements \fBfoo_fpgaClose\fP\&.
.IP \(bu 2
Create foo_props.c: implements \fBfoo_fpgaGetProperties\fP,
\fBfoo_fpgaGetPropertiesFromHandle\fP, \fBfoo_fpgaUpdateProperties\fP
.IP \(bu 2
Create foo_mmio.c: implements \fBfoo_fpgaMapMMIO\fP, \fBfoo_fpgaUnmapMMIO\fP
\fBfoo_fpgaWriteMMIO64\fP, \fBfoo_fpgaReadMMIO64\fP, \fBfoo_fpgaWriteMMIO32\fP,
\fBfoo_fpgaReadMMIO32\fP\&.
.IP \(bu 2
Create foo_buff.c: implements \fBfoo_fpgaPrepareBuffer\fP,
\fBfoo_fpgaReleaseBuffer\fP, \fBfoo_fpgaGetIOAddress\fP\&.
.IP \(bu 2
Create foo_error.c: implements \fBfoo_fpgaReadError\fP, \fBfoo_fpgaClearError\fP,
\fBfoo_fpgaClearAllErrors\fP, \fBfoo_fpgaGetErrorInfo\fP\&.
.IP \(bu 2
Create foo_event.c: implements \fBfoo_fpgaCreateEventHandle\fP,
\fBfoo_fpgaDestroyEventHandle\fP, \fBfoo_fpgaGetOSObjectFromEventHandle\fP,
\fBfoo_fpgaRegisterEvent\fP, \fBfoo_fpgaUnregisterEvent\fP\&.
.IP \(bu 2
Create foo_reconf.c: implements \fBfoo_fpgaReconfigureSlot\fP\&.
.IP \(bu 2
Create foo_obj.c: implements \fBfoo_fpgaTokenGetObject\fP,
\fBfoo_fpgaHandleGetObject\fP, \fBfoo_fpgaObjectGetObject\fP,
\fBfoo_fpgaDestroyObject\fP, \fBfoo_fpgaObjectGetSize\fP, \fBfoo_fpgaObjectRead\fP,
\fBfoo_fpgaObjectRead64\fP, \fBfoo_fpgaObjectWrite64\fP\&.
.IP \(bu 2
Create foo_clk.c: implements \fBfoo_fpgaSetUserClock\fP,
\fBfoo_fpgaGetUserClock\fP\&.
.UNINDENT
.SH OPEN PROGRAMMABLE ACCELERATOR ENGINE (OPAE) LINUX DEVICE DRIVER ARCHITECTURE
.sp
The OPAE FPGA Linux Device Driver provides interfaces for user\-space applications to
configure, enumerate, open, and access FPGA accelerators on platforms equipped
with Intel FPGA solutions. The OPAE FPGA driver also enables system\-level management functions such
as FPGA reconfiguration and virtualization.
.SS Hardware Architecture
.sp
The Linux Operating System treats the FPGA hardware as a PCIe* device. A predefined data structure,
Device Feature List (DFL), allows for dynamic feature discovery in an Intel
FPGA solution.
.sp
[image: FPGA PCIe Device]
[image]

.sp
The Linux Device Driver implements PCIe Single Root I/O Virtualization (SR\-IOV) for the creation of
Virtual Functions (VFs). The device driver can release individual accelerators
for assignment to virtual machines (VMs).
.sp
[image: Virtualized FPGA PCIe Device]
[image]

.SS FPGA Management Engine (FME)
.sp
The FPGA Management Engine provides error reporting, reconfiguration, performance reporting, and other
infrastructure functions. Each FPGA has one FME which is always accessed through the Physical
Function (PF). The Intel Xeon® Processor with Integrated FPGA also performs power and thermal management.
These functions are not available on the Intel Programmable Acceleration Card (PAC).
.sp
User\-space applications can acquire exclusive access to the FME using \fBopen()\fP,
and release it using \fBclose()\fP\&. Device access may be managed by standard Linux
interfaces and tools.
.sp
\&.. Note::
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    If an application terminates without freeing the FME or Port resources, Linux closes all
    file descriptors owned by the terminating process, freeing those resources.
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Port
.sp
A Port represents the interface between two components:
.INDENT 0.0
.IP \(bu 2
The FPGA Interface Manager (FIM) which is part of the static FPGA fabric
.IP \(bu 2
The Accelerator Function Unit (AFU) which is the partially reconfigurable region
.UNINDENT
.sp
The Port controls the communication from software to the AFU and makes features such as reset and debug available.
.SS Accelerator Function Unit (AFU)
.sp
An AFU attaches to a Port. The AFU provides a 256 KB memory mapped I/O (MMIO) region for accelerator\-specific control registers.
.INDENT 0.0
.IP \(bu 2
Use \fBopen()\fP on the Port device to acquire access to an AFU associated with the Port device.
.IP \(bu 2
Use \fBclose()\fPon the Port device to release the AFU associated with the Port device.
.IP \(bu 2
Use \fBmmap()\fP on the Port device to map accelerator MMIO regions.
.UNINDENT
.SS Partial Reconfiguration (PR)
.sp
Use PR to reconfigure an AFU from a bitstream file. Successful reconfiguration has the following requirement:
.INDENT 0.0
.IP \(bu 2
You must generate the reconfiguration AFU for the exact FIM. The AFU and FIM are compatible if their interface IDs match.
You can verify this match by comparing the interface ID in the bitstream header against the interface ID that is
exported by the driver in sysfs.
.UNINDENT
.sp
In all other cases PR fails and may cause system instability.
.sp
\&.. note::
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    Platforms that support 512\-bit Partial Reconfiguration require
    binutils >= version 2.25.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Close any software programs accessing the FPGA, including those running in a virtualized host before
initiating PR. For virtualized environments, the recommended sequence is as
follows:
.INDENT 0.0
.IP \(bu 2
Unload the driver from the guest
.IP \(bu 2
Release the VF from the guest
.UNINDENT
.sp
\&.. note::
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    NOTE: Releasing the VF from the guest while an application on the guest is
    still accessing its resources may lead to VM instabilities. We recommend
    closing all applications accessing the VF in the guest before releasing the
    VF.
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
Disable SR\-IOV
.IP \(bu 2
Perform PR
.IP \(bu 2
Enable SR\-IOV
.IP \(bu 2
Assign the VF to the guest
.IP \(bu 2
Load the driver in the guest
.UNINDENT
.SS FPGA Virtualization
.sp
To enable accelerator access from applications running on a VM, create a VF for
the port using the following process:
.INDENT 0.0
.IP \(bu 2
Release the Port from the PF using the associated ioctl on the FME device.
.IP \(bu 2
Use the following command to enable SR\-IOV and VFs. Each VF can own a single Port with an AFU. In the following command,
N is the number of Port released from the PF.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    echo N > $PCI_DEVICE_PATH/sriov_numvfs
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\&.. note::
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    NOTE: The number, \(aqN\(aq, cannot be greater than the number of supported VFs.
    This can be read from $PCI_DEVICE_PATH/sriov_totalvfs.
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
Pass the VFs through to VMs using hypervisor interfaces.
.IP \(bu 2
Access the AFU on a VF from applications running on the VM using the same driver inside the VM.
.UNINDENT
.sp
\&.. Note::
.sp
\(ga\(ga
Creating VFs is only supported for port devices. Consequently, PR and other management functions are only available through
the PF.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
## Driver Organization ##

### PCIe Module Device Driver ###

!## Driver Organization ##

### PCIe Module Device Driver ###

![Driver Organization](Driver_Organization.png "Driver Organization")




FPGA devices appear as a PCIe devices. Once enumeration detects a PCIe PF or VF, the Linux OS loads the FPGA PCIe
device driver. The device driver performs the following functions:

1. Walks through the Device Feature List in PCIe device base address register (BAR) memory to discover features
and their sub\-features and creates necessary platform devices.
2. Enables SR\-IOV.
3. Introduces the feature device infrastructure, which abstracts operations for sub\-features and provides common functions
to feature device drivers.

### PCIe Module Device Driver Functions ###

The PCIe Module Device Driver performs the following functions:

1. PCIe discovery, device enumeration, and feature discovery.
2. Creates sysfs directories for the device, FME, and Port.
3. Creates the platform driver instances, causing the Linux kernel to load their respective drivers.

### FME Platform Module Device Driver ###

The FME Platform Module Device Driver loads automatically after the PCIe driver creates the
FME Platform Module. It provides the following features for FPGA management:

1. Power and thermal management, error reporting, performance reporting, and other infrastructure functions. You can access
these functions via sysfs interfaces the FME driver provides.

2. Partial Reconfiguration. During PR sub\-feature initialization, the FME driver registers the FPGA Manager framework
to support PR. When the FME receives the relevant ioctl request from user\-space, it invokes the common interface
function from the FPGA Manager to reconfigure the AFU using PR.

3. Port management for virtualization (releasing/assigning port device).

After a port device is released, you can use the PCIe driver SR\-IOV interfaces to create/destroy VFs.

For more information, refer to "FPGA Virtualization".

### FME Platform Module Device Driver Functions ###

The FME Platform Module Device Driver performs the the following functions:

* Creates the FME character device node.
* Creates the FME sysfs files and implements the FME sysfs file accessors.
* Implements the FME private feature sub\-drivers.
* FME private feature sub\-drivers:
    * FME Header
    * Partial Reconfiguration
    * Global Error
    * Global Performance

### Port Platform Module Device Driver ###

After the PCIe Module Device Driver creates the Port Platform Module device,
the FPGA Port and AFU driver are loaded.  This module provides an
interface for user\-space applications to access the individual
accelerators, including basic reset control on the Port, AFU MMIO region
export, DMA buffer mapping service, and remote debug functions.

### Port Platform Module Device Driver Functions ###

The Port Platform Module Device Driver performs the the following functions:

* Creates the Port character device node.
* Creates the Port sysfs files and implements the Port sysfs file accessors.
* Implements the following Port private feature sub\-drivers.
    * Port Header
    * AFU
    * Port Error
    * Signal Tap

### OPAE FPGA Driver Interface ###
The user\-space interface consists of a sysfs hierarchy and ioctl requests. Most
kernel attributes can be accessed/modified via sysfs nodes in this hierarchy.
More complex I/O operations are controlled via ioctl requests. The OPAE API
implementation, libopae\-c, has been designed to use this interface to
interact with the OPAE FPGA kernel drivers.


.ft P
.fi
.UNINDENT
.UNINDENT
.SH FPGACONF
.SS SYNOPSIS
.sp
\fBfpgaconf [\-hvVn] [\-S <segment>] [\-B <bus>] [\-D <device>] [\-F <function>] [PCI_ADDR] <gbs>\fP
.SS DESCRIPTION
.sp
\fBfpgaconf\fP configures the FPGA with the accelerator function (AF). It also checks the AF for compatibility with
the targeted FPGA and the FPGA Interface Manager (FIM). \fBfpgaconf\fP takes the following arguments:
.sp
\fB\-h, \-\-help\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Prints usage information.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-v, \-\-version\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Prints version information and exits.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-V, \-\-verbose\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Prints more verbose messages while enumerating and configuring. Can be
requested more than once.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-n, \-\-dry\-run\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Performs enumeration. Skips any operations with side\-effects such as the
actual AF configuration. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-S, \-\-segment\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
PCIe segment number of the target FPGA.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-B, \-\-bus\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
PCIe bus number of the target FPGA.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-D, \-\-device\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
PCIe device number of the target FPGA. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-F, \-\-function\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
PCIe function number of the target FPGA.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-force\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Reconfigure the AFU even if it is in use.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBfpgaconf\fP enumerates available FPGA devices in the system and selects
compatible FPGAs for configuration. If more than one FPGA is
compatible with the AF, \fBfpgaconf\fP exits and asks you to be
more specific in selecting the target FPGAs by specifying a
a PCIe BDF.
.SS EXAMPLES
.sp
\fBfpgaconf my_af.gbs\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Program "my_af.gbs" to a compatible FPGA.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBfpgaconf \-V \-B 0x3b my_af.gbs\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Program "my_af.gbs" to the FPGA in bus 0x3b, if compatible,
while printing out slightly more verbose information.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBfpgaconf 0000:3b:00.0 my_af.gbs\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Program "my_af.gbs" to the FPGA at address 0000:3b:00.0.
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Revision History
.sp
| Document Version |  Intel Acceleration Stack Version  | Changes  |
| —————\- |————————————|———\-|
|2018.05.21 | 1.1 Beta. (Supported with Intel Quartus Prime Pro Edition 17.1.1.) | Corrected typos. |
.SH FPGAD
.SS SYNOPSIS
.sp
\fBfpgad \-\-daemon [\-\-version] [\-\-directory=<dir>] [\-\-logfile=<file>] [\-\-pidfile=<file>] [\-\-umask=<mode>] [\-\-socket=<sock>] [\-\-null\-bitstream=<file>]\fP
\fBfpgad [\-\-socket=<sock>] [\-\-null\-bitstream=<file>]\fP
.SS DESCRIPTION
.sp
fpgad monitors the device sensors, checking for sensor values that are out of the prescribed range.
.sp
When any of the sensors is detected to be out of bounds, fpgad will focus on keeping the server from rebooting by masking PCIE AER, and send a message to system administrator. System administrator can take further actions like stop the application and stop the FPGA, but fpgad just focus on monitor the sensors and will not take any cooling actions.
.sp
Note: fpgad must be running (as root) and actively monitoring devices when a sensor anomaly occurs in order to initiate Graceful Shutdown.  If fpgad is not loaded during such a sensor anomaly, the out\-of\-bounds scenario will not be detected, and the resulting effect on the hardware is undefined.
.SS ARGUMENTS
.sp
\fB\-v, \-\-version\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Prints version information and exits.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-d, \-\-daemon\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
When specified, fpgad executes as a system daemon process.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-D, \-\-directory <dir>\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
When running in daemon mode, run from the specified directory.
If omitted when daemonizing, \(gafpgad\(ga uses /tmp.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-l, \-\-logfile <file>\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
When running in daemon mode, send output to file. When not in daemon mode, the output goes to stdout.
If omitted when daemonizaing, fpgad uses /tmp/fpgad.log.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-p, \-\-pidfile <file>\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
When running in daemon mode, write the daemon\(aqs process id to a file.
If omitted when daemonizing, fpgad uses /tmp/fpgad.pid.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-m, \-\-umask <mode>\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
When running in daemon mode, use the mode value as the file mode creation mask passed to umask.
If omitted when daemonizing, fpgad uses 0.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-s, \-\-socket <sock>\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Listen for event API registration requests on the UNIX domain socket on the specified path. 
The default=/tmp/fpga_event_socket. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-n, \-\-null\-bitstream <file>\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specify the NULL bitstream to program when an AP6 event occurs. This option may be specified multiple
times. The AF, if any, that matches the FPGA\(aqs PR interface ID is programmed when an AP6
event occurs.
.ft P
.fi
.UNINDENT
.UNINDENT
.SS TROUBLESHOOTING
.sp
If you encounter any issues, you can get debug information in two ways:
.INDENT 0.0
.IP \(bu 2
By examining the log file when in daemon mode.
.IP \(bu 2
By running in non\-daemon mode and viewing stdout.
.UNINDENT
.SS EXAMPLES
.sp
\fBfpgad \-\-daemon \-\-null\-bitstream=my_null_bits.gbs\fP
.sp
This command starts fpgad as a system daemon process:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sudo systemctl start fpgad
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Revision History
.sp
| Document Version |  Intel Acceleration Stack Version  | Changes  |
| —————\- |————————————|———\-|
|2018.05.21 | 1.1 Beta. (Supported with Intel Quartus Prime Pro Edition 17.1.1.) | No changes from previous release. |
|2020.09.02 | 2.0                                                                                                        |
.SH FPGADIAG
.SS SYNOPSIS
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
fpgadiag [\-m | \-\-mode=] <mode> [\-t | \-\-target=] <target> [options]
.ft P
.fi
.UNINDENT
.UNINDENT
.SS DESCRIPTION
.sp
Includes several tests to diagnose, test, and report on the FPGA hardware.
.sp
\fB<mode>\fP chooses which test to run.
\fB<target>\fP specifies the platform that runs the test.
\fB<target>\fP can be either \fBfpga\fP or \fBase\fP where \fBase\fP\&.
\fB<ase>\fP is the abbreviation for Accelerator Simulation Environment.
.sp
The \fB<mode>\fP selects from the  following tests:
.sp
\fBlpbk1\fP
.sp
This test runs a loopback test on the number of cachelines specified with
the \fBBEGIN\fP option. \fBfpgadiag\fP sets up source and  destination buffers in
main memory. The FPGA then performs a \fBmemcpy\fP from a source buffer to the
destination buffer, one cacheline at a time.
.sp
A cacheline is 64 bytes. When \fBBEGIN = END\fP, the test performs one iteration. When
\fBBEGIN = END + x\fP, the test performs \fBx\fP iterations. The first iteration consists
of copying \fBBEGIN\fP cachelines; the second iteration consists of copying
\fBBEGIN+1\fP cache lines. The third iteration consists of copying \fBBEGIN+2\fP
cache lines, and so on.
.sp
The latency is shown as the number of clock cycles.
.sp
When you specify \fBMULTI\-CL\fP, you copy \fBMULTI\-CL\fP cache lines at a time.
The WR\-FENCE chooses on which virtual channel the WrFence occurs.
.sp
If you specify continuous mode with \fB\-\-cont\fP, the program iterates
until the timeout specified in \fBTIMEOUT\fP completes.
.sp
\fBread\fP
.sp
This test performs reads. Use this test to measure read bandwidth.
.sp
\fBwrite\fP
.sp
This test performs writes. Use it to measure write bandwidth.
.sp
\fBtrput\fP
.sp
This test measures both read and write bandwidth by performing 50% read and
50% write tests.
.sp
\fBsw\fP
.sp
This is a send\-and\-respond (ping\-pong) test. One side sends data and
waits for response.
.sp
Each test requires a particular AF. Before running a test,
make sure the required AF is properly configured
on the platform.
.INDENT 0.0
.IP \(bu 2
The lpbk1 test requires the nlb mode 0 AF.
.IP \(bu 2
The trput test requires the nlb mode 3 AF.
.IP \(bu 2
The sw test requires the nlb mode 7 AF. This AF is only available for the integrated FPGA platform.
You cannot run it on the PCIe accelerator card (PAC).
.UNINDENT
.sp
\fBfpgalpbk\fP
.sp
This enable/disable FPGA loopback.
.sp
\fBfpgastats\fP
.sp
This get fpga mac statistics.
.sp
\fBmactest\fP
.sp
This compare mac addresses that read from MAC ROM with mac addresses read from Host side.
.SS OPTIONS
.SS Common options
.sp
\fB\-\-help, \-h\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Print help information and exit.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-target=, \-t\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
This switch specifies fpga (hardware) or ase (simulation). The default=fpga.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-mode=, \-m\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
The test to run. The valid values are \(galpbk1\(ga, \(garead\(ga,
\(gawrite\(ga, \(gatrput\(ga, and \(gasw\(ga.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-config=, \-c\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
A configuration file in the JSON format that specifies options for a test.
If an option is specified both in the configuration file and on the command 
line, the value in the configuration file takes precedence.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-dsm\-timeout\-usec\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Timeout in microseconds for test completion. The test fails if not completed by 
specified timeout. The default=1000000.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-socket\-id=, \-s\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Socket ID encoded in FPGA Interface Manager (FIM). The default=0. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-bus=, \-B\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Bus number of the PCIe device. The default=0. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-device=, \-D\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Device number of the PCIe device. The default=0. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-function=, \-F\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Function number of the PCIe device. The default=0. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-freq=, \-T\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Clock frequency (in Hz) used for bandwidth calculation. The default=400000000 Hz (400 MHz). 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
This frequency is used only when the software cannot infer the frequency from the accelerator.
.UNINDENT
.UNINDENT
.sp
\fB\-\-suppress\-hdr, \-S\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Suppress column headers for text output. The default=off.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-csv, \-V\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Comma separated value format. The default=off. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-suppress\-stats\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Suppress statistics output at the end of test. The default=off.
.ft P
.fi
.UNINDENT
.UNINDENT
.SS \fBlpbk1\fP test options
.sp
\fB\-\-guid=, \-g\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
AFU ID to enumerate. The default=D8424DC4\-A4A3\-C413\-F89E\-433683F9040B. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-begin=B, \-b\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
1 <= B <= 65535. The default=1, B = number of cache lines. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-end=E, \-e\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
1 <= E <= 65535. The default=B, B and E designate number of cache lines. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-multi\-cl=M, \-u\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
M can equal 1, 2, or 4. The default=1. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-cont, \-L\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Continuous mode. The default=off. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-timeout\-usec=, \-\-timeout\-msec=, \-\-timeout\-sec=, \-\-timeout\-min=, \-\-timeout\-hour=\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
timeout for \-\-cont mode. The default for all options is 0. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-cache\-policy=, \-p\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be wrline\-I, wrline\-M, or wrpush\-I The default=wrline\-M.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-cache\-hint=, \-i\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be rdline\-I or rdline\-S. The default=rdline\-I.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-read\-vc=, \-r\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be auto, vl0, vh0, vh1, random. The default=auto. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-write\-vc=, \-w\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be auto, vl0, vh0, vh1, random. The default=auto. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-wrfence\-vc=, \-f\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be auto, vl0, vh0, vh1. The default=auto. 
.ft P
.fi
.UNINDENT
.UNINDENT
.SS \fBread\fP test options
.sp
\fB\-\-guid=, \-g\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
AFU ID to enumerate. The default=F7DF405C\-BD7A\-CF72\-22F1\-44B0B93ACD18. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-begin=B, \-b\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
1 <= B <= 65535. The default=1, B = number of cache lines. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-end=E, \-e\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
1 <= E <= 65535. The default=B, B and E designate number of cache lines. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-multi\-cl=M, \-u\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
M can equal 1, 2, or 4. The default=1. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-strided\-access=S, \-a\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
1<= S <= 64. The default=1. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-cont, \-L\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Continuous mode. The default=off. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-timeout\-usec=, \-\-timeout\-msec=, \-\-timeout\-sec=, \-\-timeout\-min=, \-\-timeout\-hour=\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
timeout for \-\-cont mode. The default for all options is 0.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-cache\-hint=, \-i\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be rdline\-I or rdline\-S. The default=rdline\-I. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-warm\-fpga\-cache \-H; \-\-cool\-fpga\-cache \-M\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Try to prime the cache with hits. The default=off. Try to prime the 
cache with misses. The default=off.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-cool\-cpu\-cache, \-C\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Try to prime the cpu cache with misses. The default=off. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-read\-vc=, \-r\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be auto, vl0, vh0, vh1, random. The default=auto 
.ft P
.fi
.UNINDENT
.UNINDENT
.SS \fBwrite\fP test options
.sp
\fB\-\-guid=, \-g\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
AFU ID to enumerate. The default=F7DF405C\-BD7A\-CF72\-22F1\-44B0B93ACD18 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-begin=B, \-b\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
1 <= E <= 65535. The default=B, B and E designate number of cache lines. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-multi\-cl=M, \-u\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
M can equal 1, 2, or 4. The default=1.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-strided\-access=S, \-a\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
1<= S <= 64. The default=1.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-cont, \-L\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Continuous mode. The default=off.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-timeout\-usec=, \-\-timeout\-msec=, \-\-timeout\-sec=, \-\-timeout\-min=, \-\-timeout\-hour=\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
timeout for \-\-cont mode. The default for all options is 0.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-cache\-policy=, \-p\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be wrline\-I, wrline\-M, or wrpush\-I The default=wrline\-M 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-warm\-fpga\-cache \-H; \-\-cool\-fpga\-cache \-M\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Try to prime the cache with hits. The default=off. Try to prime the 
cache with misses. The default=off. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-cool\-cpu\-cache, \-C\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Try to prime the cpu cache with misses. The default=off. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-write\-vc=, \-w\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be auto, vl0, vh0, vh1, random. The default=auto. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-wrfence\-vc=, \-f\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be auto, vl0, vh0, vh1, random. The default=\(gaWRITE\-VC\(ga.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-alt\-wr\-pattern, \-l\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Alternate Write Pattern. The default=off. 
.ft P
.fi
.UNINDENT
.UNINDENT
.SS \fBtrput\fP test options
.sp
\fB\-\-guid=, \-g\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
AFU ID to enumerate. The default=F7DF405C\-BD7A\-CF72\-22F1\-44B0B93ACD18.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-begin=B, \-b\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
1 <= B <= 65535. The default=1, B = number of cache lines. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-end=E, \-e\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
1 <= E <= 65535. The default=B, B and E designate number of cache lines. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-multi\-cl=M, \-u\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
M can equal 1, 2, or 4. The default=1. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-strided\-access=S, \-a\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
1<= S <= 64. The default=1 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-cont, \-L\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Continuous mode. The default=off. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-timeout\-usec=, \-\-timeout\-msec=, \-\-timeout\-sec=, \-\-timeout\-min=, \-\-timeout\-hour=\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
timeout for \-\-cont mode. The default for all options is 0.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-cache\-policy=, \-p\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be wrline\-I, wrline\-M, or wrpush\-I The default=wrline\-M. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-cache\-hint=, \-i\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be rdline\-I or rdline\-S. The default=rdline\-I. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-read\-vc=, \-r\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be auto, vl0, vh0, vh1, random. The default=auto. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-write\-vc=, \-w\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be auto, vl0, vh0, vh1, random. The default=auto. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-wrfence\-vc=, \-f\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be  auto, vl0, vh0, vh1. The default=\(gaWRITE\-VC\(ga.
.ft P
.fi
.UNINDENT
.UNINDENT
.SS \fBsw\fP test options
.sp
\fB\-\-guid=, \-g\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
AFU ID to enumerate. The default=7BAF4DEA\-A57C\-E91E\-168A\-455D9BDA88A3. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-begin=B, \-b\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
1 <= B <= 65535. The default=1, B = number of cache lines. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-end=E, \-e\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
1 <= E <= 65535. The default=B, B and E designate number of cache lines. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-cache\-policy=, \-p\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be wrline\-I, wrline\-M, or wrpush\-I. The default=wrline\-M. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-cache\-hint= \-i\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be rdline\-I or rdline\-S. The default=rdline\-I. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-read\-vc=, \-r\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be auto, vl0, vh0, vh1, random The default=auto. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-write\-vc=, \-w\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be auto, vl0, vh0, vh1, random The default=auto.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-wrfence\-vc=, \-f\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be auto, vl0, vh0, vh1. The default=\(gaWRITE\-VC\(ga.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-notice=, \-N\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be poll or csr\-write. The default=poll. 
.ft P
.fi
.UNINDENT
.UNINDENT
.SS \fBEnable FPGA N3000 Ethernet group VFIO mdev\fP
.sp
FPGA DFL driver does not support any ioctls to read/write ethernet group info and registers.
Users can read/write eth group registers by enabling VFIO mdev. Unbind the dfl_eth_group driver and bind vfio\-mdev\-dfl
driver for ethernet group dfl\-device; then userspace can take full control of ethernet group feature id 10.
.sp
Ethernet group must be enabled before running fpgalpbk, mactest tools.
.SS \fBSteps to enable/create vfio mdev\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
unbind eth group feature id 10:
    echo dfl\-fme.0.8 > /sys/bus/dfl/drivers/dfl\-eth\-group/unbind
    echo dfl\-fme.0.7 > /sys/bus/dfl/drivers/dfl\-eth\-group/unbind
bind to vfio\-mdev\-dfl:
    echo vfio\-mdev\-dfl > /sys/bus/dfl/devices/dfl\-fme.0.7/driver_override
    echo vfio\-mdev\-dfl > /sys/bus/dfl/devices/dfl\-fme.0.8/driver_override
load vfio driver:
    modprobe vfio_pci
    modprobe vfio_iommu_type1
    modprobe vfio_mdev
    modprobe vfio_mdev_dfl
trigger mdev:
    echo dfl\-fme.0.7 >/sys/bus/dfl/drivers_probe
    echo dfl\-fme.0.8 >/sys/bus/dfl/drivers_probe
    echo 83b8f4f2\-509f\-382f\-3c1e\-e6bfe0fa1001 > /sys/bus/dfl/devices/dfl\-fme.0.7/mdev_supported_types/vfio\-mdev\-dfl\-1/create
    echo 83b8f4f2\-509f\-382f\-3c1e\-e6bfe0fa1002 > /sys/bus/dfl/devices/dfl\-fme.0.8/mdev_supported_types/vfio\-mdev\-dfl\-1/create

linux kerenl msg after enabling mdev:
    i40e 0000:b3:00.0 eth1: NIC Link is Down
    i40e 0000:b1:00.1 eth0: NIC Link is Down
    vfio\-mdev\-dfl dfl\-fme.2.7: MDEV: Registered
    vfio\-mdev\-dfl dfl\-fme.2.8: MDEV: Registered
    vfio_mdev 83b8f4f2\-509f\-382f\-3c1e\-e6bfe0fa1005: Adding to iommu group 140
    vfio_mdev 83b8f4f2\-509f\-382f\-3c1e\-e6bfe0fa1005: MDEV: group_id = 140
    vfio_mdev 83b8f4f2\-509f\-382f\-3c1e\-e6bfe0fa1006: Adding to iommu group 141
    vfio_mdev 83b8f4f2\-509f\-382f\-3c1e\-e6bfe0fa1006: MDEV: group_id = 141
.ft P
.fi
.UNINDENT
.UNINDENT
.SS \fBRemove vfio mdev\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    echo 1 | sudo tee /sys/bus/mdev/devices/83b8f4f2\-509f\-382f\-3c1e\-e6bfe0fa1002/remove
    echo 1 | sudo tee /sys/bus/mdev/devices/83b8f4f2\-509f\-382f\-3c1e\-e6bfe0fa1001/remove

    rmmod vfio_mdev_dfl
    modprobe dfl_eth_group

    echo dfl\-fme.0.7 >/sys/bus/dfl/drivers_probe
    echo dfl\-fme.0.8 >/sys/bus/dfl/drivers_probe

    echo dfl\-eth\-group > /sys/bus/dfl/devices/dfl\-fme.0.7/driver_override
    echo dfl\-eth\-group > /sys/bus/dfl/devices/dfl\-fme.0.8/driver_override
.ft P
.fi
.UNINDENT
.UNINDENT
.SS \fBfpgalpbk\fP test options
.sp
\fB\-\-enable\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Enable fpga phy loopback.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-disable\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Disable fpga phy loopback.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-direction\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be local, remote.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-type\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be serial, precdr, postcdr.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-side\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Can be line, host.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-port\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
0 <= port <= 7, the default is all.
.ft P
.fi
.UNINDENT
.UNINDENT
.SS \fBmactest\fP test options
.sp
\fB\-\-offset\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Read mac addresses from an offset, The default=0.
.ft P
.fi
.UNINDENT
.UNINDENT
.SS EXAMPLES
.sp
This command starts a \fBlpbk1\fP test for the FPGA on bus \fB0x5e\fP\&. The test
copies 57535, 57536, 57537 … up to 65535 cache lines, one line at a time.
The test prints output in the comma separated values (CSV) format with the
header suppressed.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&./fpgadiag \-\-mode=lpbk1 \-\-target=fpga \-V \-\-bus=0x5e \-\-begin=57535
\-\-end=65535 \-\-cache\-hint=rdline\-I \-\-cache\-policy=wrpush\-I \-\-multi\-cl=1
\-\-write\-vc=vl0 \-\-read\-vc=vh1 \-\-wrfence\-vc=auto
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command starts a \fBread\fP test on the FPGA located on bus \fB0xbe\fP\&. The test
reads 2045 cache lines in the continuous mode with a 15\-second timeout period.
The reads use a strided pattern with a 10\-byte stride length.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&./fpgadiag \-\-mode=read \-\-target=fpga \-V \-\-bus=0xbe \-\-begin=2045 \-\-cont
\-\-timeout\-sec=15 \-\-cache\-hint=rdline\-I \-\-multi\-cl=1 \-a=10 
\-\-read\-vc=auto \-\-wrfence\-vc=auto
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command starts a \fBsw\fP test on the FPGA located on bus \fB0xbe\fP\&. The test
signals completion using a CSR write.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&./fpgadiag \-\-mode=sw \-\-target=fpga \-V \-\-bus=0xbe \-\-begin=4 \-\-end=8192
\-\-cache\-hint=rdline\-I \-\-cache\-policy=wrline\-I \-\-notice=csr\-write \-\-write\-vc=vl0
\-\-wrfence\-vc=auto \-\-read\-vc=random 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command enable a \fBfpgalpbk\fP on the FPGA located on bus \fB0xbe\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&./fpgadiag \-m fpgalpbk \-\-bus 0xbe \-\-enable \-\-direction local \-\-type postcdr
\-\-side host
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command show \fBfpgastats\fP on the FPGA located on bus \fB0xbe\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&./fpgadiag \-m fpgastats \-\-bus 0xbe
.ft P
.fi
.UNINDENT
.UNINDENT
.SS TROUBLESHOOTING
.sp
When a test fails to run or gives errors, check the following:
.INDENT 0.0
.IP \(bu 2
Is the Intel FPGA driver properly installed?
See \fI\%Installation Guide\fP
for driver installation instructions.
.IP \(bu 2
Are FPGA port permissions set properly? Check the permission bits of the
port, for example, \fB/dev/intel\-fpga\-port\-0\fP\&. You need READ and WRITE
permissions to run \fBfpgadiag\fP tests.
.IP \(bu 2
Is hugepage properly configured on the system?
See \fI\%Installation Guide\fP
for hugepage configuration steps. In particular, \fBfpgadiag\fP requires a few 1 GB
pages.
.IP \(bu 2
Is the required AFU loaded? See \fI\%DESCRIPTION\fP for
information about what AFU the test requires.
.IP \(bu 2
Are \fB\-\-begin\fP and \fB\-\-end\fP values set properly? \fB\-\-end\fP must be larger
than the \fB\-\-begin\fP\&. Also, \fB\-\-begin\fP must be a multiple of the
\fB\-\-multi\-cl\fP value.
.IP \(bu 2
The \fB\-\-warm\-fpga\-cache\fP and \fB\-\-cool\-fpga\-cache\fP options in the \fBread\fP
and \fBwrite\fP tests are mutually exclusive.
.IP \(bu 2
The timeout options are only meaningful for the continuous mode
(with the \fB\-\-cont\fP option).
.UNINDENT
.SS Revision History
.sp
| Date | Intel Acceleration Stack Version | Changes Made |
|:——|—————————\-|:————–|
|2018.05.21| DCP 1.1 Beta (works with Quartus Prime Pro 17.1.1) | fpgadiag now reports the correct values for bandwidth. |
.SH FPGAINFO
.SS SYNOPSIS
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
   fpgainfo [\-h] [\-S <segment>] [\-B <bus>] [\-D <device>] [\-F <function>] [PCI_ADDR]
            {errors,power,temp,fme,port,bmc,mac,phy,security}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS DESCRIPTION
.sp
fpgainfo displays FPGA information derived from sysfs files. The command argument is one of the following:
\fBerrors\fP, \fBpower\fP, \fBtemp\fP, \fBport\fP, \fBfme\fP, \fBbmc\fP, \fBphy\fP or \fBmac\fP,\fBsecurity\fP,\fBevents\fP\&.
Some commands may also have other arguments or options that control their behavior.
.sp
For systems with multiple FPGA devices, you can specify the BDF to limit the output to the FPGA resource
with the corresponding PCIe configuration. If not specified, information displays for all resources for
the given command.
.SS FPGAINFO COMMANDS
.sp
\fBerrors\fP
.sp
Show/clear errors of an FPGA resource that the first argument specifies.
\fBfpgainfo\fP displays information in human readable form.
.sp
\fBpower\fP
.sp
Show total the power in watts that the FPGA hardware consumes.
.sp
\fBtemp\fP
.sp
Show FPGA temperature values in degrees Celcius.
.sp
\fBport\fP
.sp
Show information about the port such as the AFU ID of currently loaded AFU.
.sp
\fBfme\fP
.sp
Show information about the FPGA platform including the partial reconfiguration (PR) Interface ID, the OPAE version,
and the FPGA Interface Manager (FIM) ID.
.sp
\fBbmc\fP
.sp
Show all Board Management Controller sensor values for the FPGA resource, if available.
.sp
\fBphy\fP
.sp
Show information about the PHY integrated in the FPGA, if available.
.sp
\fBmac\fP
.sp
Show information about the MAC address in ROM attached to the FPGA, if available.
.sp
\fBsecurity\fP
.sp
Show information about the security keys, hashs and flash count, if available.
.sp
\fBevents\fP
.sp
Show information about events and sensors, if available.
.SS OPTIONAL ARGUMENTS
.sp
\fB\-\-help, \-h\fP
.sp
Prints help information and exit.
.sp
\fB\-\-version, \-v\fP
.sp
Prints version information and exit.
.SS COMMON ARGUMENTS
.sp
The following arguments are common to all commands and are optional.
.sp
\fB\-S, \-\-segment\fP
.sp
PCIe segment number of resource.
.sp
\fB\-B, \-\-bus\fP
.sp
PCIe bus number of resource.
.sp
\fB\-D, \-\-device\fP
.sp
PCIe device number of resource.
.sp
\fB\-F, \-\-function\fP
.sp
PCIe function number of resource.
.SS ERRORS ARGUMENTS
.sp
The first argument to the \fBerrors\fP command specifies the resource type. It must be one of the following:
\fBfme\fP,\fBport\fP,\fBall\fP
.sp
\fBfme\fP
.sp
Show/clear FME errors.
.sp
\fBport\fP
.sp
Show/clear PORT errors.
.sp
\fBall\fP
.sp
Show/clear errors for all resources.
.sp
The optional \fB<command\-args>\fP arguments are:
.sp
\fB\-\-clear, \-c\fP
.sp
Clear errors for the given FPGA resource.
.SS PHY ARGUMENTS
.sp
The optional \fB<command\-args>\fP argument is:
.sp
\fB\-\-group, \-G\fP
.sp
Select which PHY group(s) information to show.
.SS EVENTS ARGUMENTS
.sp
The optional \fB<command\-args>\fP argument is:
.sp
\fB\-\-list,\-l\fP
.sp
List boots (implies –all).
.sp
\fB\-\-boot,\-b\fP
.sp
Boot index to use, i.e:
\ \ \ \ 0 for current boot (default).
\ \ \ \ 1 for previous boot, etc.
.sp
\fB\-\-count,\-c\fP
.sp
Number of events to print.
.sp
\fB\-\-all,\-a\fP
.sp
Print all events.
.sp
\fB\-\-sensors,\-s\fP
.sp
Print sensor data too.
.sp
\fB\-\-bits,\-i\fP
.sp
Print bit values too.
.sp
\fB\-\-help,\-h\fP
.sp
Print this help.
.SS EXAMPLES
.sp
This command shows the current power telemetry:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&./fpgainfo power
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command shows the current temperature readings:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&./fpgainfo temp
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command shows FME resource errors:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&./fpgainfo errors fme
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command clears all errors on all resources:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&./fpgainfo errors all \-c
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command shows information of the FME on bus 0x5e
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&./fpgainfo fme \-B 0x5e
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command shows information of the FPGA security on bus 0x5e
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&./fpgainfo security \-B 0x5e
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command shows all events and sensors information including sensor bits:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&./fpgainfo events \-asi
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Revision History
.sp
| Document Version |  Intel Acceleration Stack Version  | Changes  |
| —————\- |————————————|———\-|
| 2018.05.21 | 1.1 Beta. (Supported with Intel Quartus Prime Pro Edition 17.1.) | Updated description of the \fBfme\fP command |
.SH FPGASUPDATE
.SS SYNOPSIS
.sp
\fBfpgasupdate [\-\-log\-level=<level>] file [bdf]\fP
.SS DESCRIPTION
.sp
The \fBfpgasupdate\fP command implements a secure firmware update for the following programmable accelerator cards (PACs):
.INDENT 0.0
.IP \(bu 2
Intel® PAC with Intel Arria® 10 GX FPGA
.IP \(bu 2
Intel FPGA PAC D5005
.IP \(bu 2
Intel PAC N3000
.UNINDENT
.sp
\fB\-\-log\-level <level>\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specifies the \(galog\-level\(ga which is the level of information output to your command tool.
The following seven levels  are available: \(gastate\(ga, \(gaioctl\(ga, \(gadebug\(ga, \(gainfo\(ga, \(gawarning\(ga,
\(gaerror\(ga, \(gacritical\(ga. Setting \(ga\-\-log\-level=state\(ga provides the most verbose output.
Setting \(ga\-\-log\-level=ioctl\(ga provides the second most information, and so on. The default
level is \(gainfo\(ga. 
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBfile\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specifies the secure update firmware file to be programmed. This file may be to program a
static region (SR), programmable region (PR), root entry hash, key cancellation, or other
device\-specific firmware.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBbdf\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
The PCIe&reg; address of the PAC to program. \(gabdf\(ga is of the form \(ga[ssss:]bb:dd:f\(ga,
corresponding to PCIe segment, bus, device, function. The segment is optional. If
you do not specify a segment, the segment defaults to \(ga0000\(ga. If the system has only
one PAC you can omit the \(gabdf\(ga and let \(gafpgasupdate\(ga  determine the address
automatically.
.ft P
.fi
.UNINDENT
.UNINDENT
.SS TROUBLESHOOTING
.sp
To gather more debug output, decrease the \fB\-\-log\-level\fP parameter.
.SS EXAMPLES
.sp
\fBfpgasupdate firmware.bin\fP
\fBfpgasupdate firmware.bin 05:00.0\fP
\fBfpgasupdate firmware.bin 0001:04:02.0 \-\-log\-level=ioctl\fP
.SS Revision History
.sp
| Document Version |  Intel Acceleration Stack Version  | Changes  |
| —————\- |————————————|———\-|
|2019.07.26 | 1.2.1 Beta | Initial release. |
|2019.10.04 | 2.0.1 Beta  (Supported with Intel Quartus Prime Pro Edition 19.2.) | Editorial changes only. |
.SH MMLINK
.SS Synopsis
.sp
\fBmmlink [\-v] [\-B <bus>] [\-D <device>] [\-F <function>] [\-S <socket>] [\-P <TCP port>] [\-I <IP Address>]\fP
.SS Description
.sp
The Remote Signal Tap logic analyzer provides real\-time hardware debugging for the Accelerator Function Unit (AFU).
It provides a signal trace capability that the Quartus Prime software adds to the AFU. The Remote Signal Tap logic
analyzer provides access to the Remote Signal Tap part of the Port MMIO space and then runs the remote protocol.
.SS Examples
.sp
\fB\&./mmlink  \-B 0x5e \-P 3333\fP
.sp
MMLink app starts and listens for connection.
.SS Options
.sp
\fB\-v,\-\-version\fP
.sp
Prints version information and exits.
.sp
\fB\-B,\-\-bus\fP
.sp
FPGA Bus number.
.sp
\fB\-D,\-\-device\fP
.sp
FPGA Device number.
.sp
\fB\-F,\-\-function\fP
.sp
FPGA function number.
.sp
\fB\-S,\-\-socket\fP
.sp
FPGA socket number.
.sp
\fB\-P,\-\-port\fP
.sp
TCP port number.
.sp
\fB\-I,\-\-ip \fP
.sp
IP address of FPGA system.
.SS Notes
.sp
Driver privilege:
.sp
Change AFU driver privilege to user:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ chmod 777 /dev/intel\-fpga\-port.0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Change locked memory size:
.sp
edit the file /etc/security/limits.conf
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo vi /etc/security/limits.conf

user    hard   memlock           10000

user    soft   memlock           10000
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Exit terminal and log into a new terminal.
.sp
Verify that the locked memory is now set:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ ulimit \-l 10000

## Revision History ##

 | Document Version |  Intel Acceleration Stack Version  | Changes  |
 | \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-|
 | 2018.05.21 | 1.1 Beta. <br>(Supported with Intel Quartus Prime Pro Edition 17.1.) | No changes from previous release.  | 


.ft P
.fi
.UNINDENT
.UNINDENT
.SH PACKAGER
.SS SYNOPSIS
.sp
\fBpackager <cmd> [arguments]\fP
.SS Description
.sp
The packager provides tools that Accelerator Functional Unit (AFU) developers use to create Accelerator Function (AF)
files. The AF file is the programming file for an AFU on Intel® FPGA platforms. The packager tool concatenates
the metadata from the JSON file to a raw binary file \fB(.rbf)\fP that the Intel Quartus® Prime software generates.
.sp
The packager’s only function is to create an AF file. Refer to \fI\%Packager Command Syntax\fP for more information
about invoking the packager. The packager depends on a JSON file to describe AFU metadata. Refer to
\fI\%Accelerator Description File\fP for more information about the JSON file.
.sp
\fBThe packager requires Python 2.7.1 and Python 2.7.3. The tool indicates if it is being called with a compatible
of Python.\fP
.SS Packager Command Syntax
.sp
The packager is a command line tool with the following syntax:
.sp
\fB$ packager <cmd> [arguments]\fP
.sp
The following table describes the \fB<CMD>\fP arguments:
.sp
| Command | Arguments       | Description |
|———| —————\-| ————|
| \fBcreate\-gbs\fP  | \fB\-\-rbf=<RBF_PATH>\fP \fB\-\-afu=<AFU_JSON_PATH>\fP \fB\-\-gbs=<GBS_PATH>\fP \fB\-\-set\-value=<key>.<value>\fP| Creates the AF file. The engineering name for this file is the green bit stream, abbreviated gbs. The \fB\-\-rbf\fP and \fB\-\-afu\fP   arguments are required.  \fB<RBF_PATH>\fP is the path to the RBF file for the AFU. The Quartus® Prime software generates this RBF by compiling the AFU design. \fB<AFU_JSON_PATH>\fP is the path to the Accelerator Description file. This is a JSON file that describes the metadata that \fBcreate\-gbs\fP appends to the RBF. \fB<GBS_PATH>\fP is the path to the RBF file for the FPGA Interface Manager (FIM) that contains the FPGA interface unit and other interfaces. If you do not specify the \fB\-\-gbs\fP, the command defaults to \fB<rbf_name>.gbs\fP\&. You can use the optional \fB\-\-set\-value=<key>.<value>\fP argument to set values for JSON metadata. To set more than one JSON value, list a series of \fB<key>.<value>\fP  pairs.|
|\fBmodify\-gbs\fP | \fB\-\-gbs=<gbs_PATH>\fP| Modifies the AF file. The \fB\-\-input\-gbs\fPargument is required. If you do not provide the \fB\-\-output\-gbs\fP argument, \fBmodify\-gbs\fP overwrites the \fB\-\-input\-gbs\fP file. Use the \fB\-\-set\-value=<key>.<value>\fP argument to set values for JSON metadata. To set more than one JSON value, list a series of \fB<key>.<value>\fP  pairs.|
|\fBgbs\-info\fP | \fB\-\-input\-gbs=<gbs_PATH>\fP| Prints information about the AF file. The \fB\-\-input\-gbs\fP argument is required.|
|\fBget\-rbf\fP | \fB\-\-gbs=<GBS_PATH>\fP \fB\-\-rbf=<RBF_PATH>\fP| Creates the RBF by extracting it from the AF file. The \fB\-\-gbs\fPargument is required. If you do not specify the \fB\-\-rbf\fP argument, the command defaults to \fB<gbs_name.rbf\fP . |
| None, or any \fB<CMD>\fP  | \fB\-\-help\fP | Summarizes the \fB<CMD>\fP options. Typing \fBpackager \-\-help\fP gives a list of \fB<CMD>\fP values. Typing \fBpackager <CMD> \-\-help\fP provides detailed help for \fB<CMD>\fP |
.SS Examples
.sp
To generate an AF file, run:
.sp
\fB$ packager create\-gbs \-\-rbf=<RBF_PATH> \-\-afu=<AFU_JSON_PATH> \-\-gbs=<GBS_PATH>\fP
.sp
\fBTIP\fP: JSON files are very particular about syntax such as trailing commas. If you are getting errors, use \fBjsonlint.com\fP to
validate that your JSON is formatted correctly.
.sp
To modify metadata in an existing AF, run the following command:
.sp
\fB$ packager modify\-gbs \-\-input\-gbs=<PATH_TO_GBS_TO_BE_MODIFIED> \-\-outputgbs=<NAME_FOR_NEW_GBS> \-\-set\-value <key>:<value>\fP
.sp
You can pass in a number of : pairs with –set\-value to update values in an AF.
.sp
To print the metadata of an existing AF:
.sp
\fB$ packager get\-info \-\-gbs=<GBS_PATH>\fP
.sp
To extract the RBF from the AF:
.sp
\fB$ packager get\-rbf \-\-gbs=<GBS_PATH> \-\-rbf=<NAME_FOR_RBF>\fP
.SS Accelerator Description File
.sp
The Accelerator Description File is a JSON file that describes the metadata associated with an AFU.
The Open Progammable Accelerator Engine (OPAE) uses this metadata during reconfiguration. Here is an example file:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
   "version": 1,
   "platform\-name": "DCP",
   "afu\-image": {
      "magic\-no": 488605312,
      "interface\-uuid": "01234567\-89AB\-CDEF\-0123\-456789ABCDEF",
      "power": 0,
      "accelerator\-clusters": [{
         "name": "dma_test_afu",
         "total\-contexts": 1,   
         "accelerator\-type\-uuid": "331DB30C\-9885\-41EA\-9081\-F88B8F655CAA"
      }
      ]  
   }
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The packager stores these parameter values in the resultant AF. After reprogramming the AFU using partial reconfiguration (PR), the
software driver reconfigures the PLLs by writing the clock\-frequency\-high and clock\-frequency\-low values (if present) over the
PCIe® and CCI interfaces.
.sp
\&.. note::
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
The JSON file format may change as the architecture evolves. Any changes to the current format trigger an update
to the version number.  
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
CATEGORY | NAME | TYPE | DESCRIPTION | MANDATORY
———|——|——|————\-|:———\-:|
Per\-AFU  | version | Integer | Version of the metadata format. | Yes
Per\-AFU  | magic\-no (to be deprecated)| Integer | Magic no. Associated with the FPGA Interface Manager. | No
Per\-AFU  | platform\-name | String | Name of the platform for which the metadata is intended. The field value is “DCP” for Intel  Acceleration Stack for FPGAs. | No
Per\-AFU  | interface\-uuid | UUID | Interface id associated with the FPGA Interface Manager. | Yes
Per\-AFU  | power | Integer | Accelerator Function power consumption, in watts. Set to 0 for Intel Acceleration Stack for FPGAs platforms. | Yes
Per\-AFU  | clock\-frequency\-low | Float | Clock frequency for 1st PLL (Clock network)1 in MHz. | No
Per\-AFU  | clock\-frequency\-high | Float | Clock frequency for 2nd PLL (0 if absent) in MHz. | No
Per\-AFC Cluster | total\-contexts | Integer | Number of AFCs in this cluster. Always be 1 in current architectures. | Yes
Per\-AFC Cluster | afc\-type\-uuid |  UUID | AFC type = AFU ID in current architectures. | Yes
Per\-AFC Cluster | name | string | AFC name = AFU name in current architectures. | Yes
.sp
| Date | Intel Acceleration Stack Version | Changes Made |
|:——|—————————\-|:————–|
|2018.05.21| DCP 1.1 Beta (works with Quartus Prime Pro 17.1.1) |  Fixed typos. |
.SH USERCLK
.SS SYNOPSIS
.sp
\fBuserclk [\-hv] [\-S <segment>] [\-B <bus>] [\-D <device>] [\-F <function>] [PCI_ADDR] [\-H <User clock high frequency>] \-L <User clock low frequency>]\fP
.SS DESCRIPTION
.sp
userclk sets the frequency range for an AFU.
.SS EXAMPLES
.sp
\fB\&./userclk \-B 0x5e \-H 400 \-L 200\fP
.sp
Sets AFU frequency.
.SS OPTIONS
.sp
\fB\-v,\-\-version\fP
.sp
Prints version information and exits.
.sp
\fB\-S,\-\-segment\fP
.sp
FPGA segment number.
.sp
\fB\-B,\-\-bus\fP
.sp
FPGA Bus number.
.sp
\fB\-D,\-\-device\fP
.sp
FPGA Device number.
.sp
\fB\-F,\-\-function\fP
.sp
FPGA function number.
.sp
\fB\-H,\-\-freq\-high \fP
.sp
User clock high frequency.
.sp
\fB\-L,\-\-freq\-low \fP
.sp
User clock low frequency.
.sp
| Date | Intel Acceleration Stack Version | Changes Made |
|:——|—————————\-|:————–|
|2018.05.21| DCP 1.1 Beta (works with Quartus Prime Pro 17.1.1) |  Fixed typos. |
.SH HSSI
.SS SYNOPSIS
.sp
\fBhssi COMMON_OPTIONS MODE MODE_OPTIONS\fP
.SS DESCRIPTION
.sp
The \fBhssi\fP application provides a means of interacting with the 10G and
with the 100G HE\-HSSI AFUs. In both 10G and 100G operating modes, the application
initializes the AFU and completes the desired transfer as described by the mode\-
specific options.
.sp
COMMON_OPTIONS \- application options common to both 10G and 100G modes.
.sp
\fB\-h, \-\-help\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Display common command\-line help and exit.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-p, \-\-pci\-address ADDR\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
The PCIe address of the desired accelerator in ssss:bb:dd.f format.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-s, \-\-shared on|off\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Whether to open the accelerator in shared mode. The default is off.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-t, \-\-timeout VALUE\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
The application timeout value in milliseconds. The default timeout is 60000 msec.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
MODE \- select AFU. Valid values are hssi_10g and hssi_100g.
.sp
MODE_OPTIONS [hssi_10g] \- application options specific to the 10G AFU.
.sp
\fB\-h, \-\-help\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Display 10G AFU specific command\-line help and exit.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-port PORT\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Select the QSFP port in the range 0\-7. The default is port 0.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-eth\-loopback on|off\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Whether to enable loopback on the ethernet interface. Valid values are
on and off. The default is on.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-num\-packets PACKETS\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
The number of packets to transfer. The default is 1 packet.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-random\-length fixed|random\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specify packet length randomization. Valid values are fixed and
random. The default is fixed (no randomization).
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-random\-payload incremental|random\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specify payload randomization. Valid values are incremental and
random. The default is incremental.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-packet\-length LENGTH\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specify packet length. The default is 64 bytes.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-src\-addr ADDR\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specify the source MAC address. The default value is 11:22:33:44:55:66.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-dest\-addr ADDR\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specify the destination MAC address. The default value is 77:88:99:aa:bb:cc.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-rnd\-seed0 SEED0\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specify the prbs generator bits [31:0]. The default is 1592590336.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-rnd\-seed1 SEED1\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specify the prbs generator bits [47:32]. The default is 1592590337.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-rnd\-seed2 SEED2\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specify the prbs generator bits [91:64]. The default is 155373.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
MODE_OPTIONS [hssi_100g] \- application options specific to the 100G AFU.
.sp
\fB\-\-port PORT\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Select the QSFP port in the range 0\-7. The default is port 0.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-eth\-loopback on|off\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Whether to enable loopback on the ethernet interface. Valid values are
on and off. The default is on.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-num\-packets PACKETS\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
The number of packets to transfer. The default is 1 packet.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-gap random|none\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Inter\-packet gap. Valid values are random and none. The default is none.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-pattern random|fixed|increment\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Pattern mode. Valid values are random, fixed, or increment. The default
is random.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-src\-addr ADDR\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specify the source MAC address. The default value is 11:22:33:44:55:66.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-dest\-addr ADDR\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specify the destination MAC address. The default value is 77:88:99:aa:bb:cc.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-start\-size SIZE\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specify the packet size in bytes, or the first packet size for \-\-pattern increment.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-end\-size SIZE\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specify the end packet size in bytes.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-\-end\-select pkt_num|gen_idle\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specify packet generation end mode.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
MODE_OPTIONS [pkt_filt_10g] \- application options specific to the Packet Filter 10G AFU.
.sp
\fB\-\-dfl\-dev DFL_DEV\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Packet Filter DFL device, eg \-\-dfl\-dev dfl_dev.0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
MODE_OPTIONS [pkt_filt_100g] \- application options specific to the Packet Filter 100G AFU.
.sp
\fB\-\-dfl\-dev DFL_DEV\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Packet Filter DFL device, eg \-\-dfl\-dev dfl_dev.1
.ft P
.fi
.UNINDENT
.UNINDENT
.SS EXAMPLES
.sp
\fBhssi \-h\fP
\fBhssi hssi_10g \-h\fP
\fBsudo hssi \-\-pci\-address=0000:3b:00.0 hssi_10g \-\-eth\-loopback=on \-\-num\-packets=500\fP
\fBsudo hssi \-\-pci\-address=0000:3b:00.0 hssi_100g \-\-pattern=increment\fP
.SS Revision History
.sp
Document Version | Intel Acceleration Stack Version | Changes
—————–|———————————\-|——–
2021.01.08 | IOFS EA | Initial release.
.SH OPAEVFIO
.SS SYNOPSIS
.sp
\fBopaevfio [\-h] [\-i] [\-r] [\-d DRIVER] [\-u USER] [\-g GROUP] [\-n] [\-v] [addr]\fP
.SS DESCRIPTION
.sp
The \fBopaevfio\fP command enables the binding/unbinding of a PCIe device
to/from the vfio\-pci device driver. See https://kernel.org/doc/Documentation/vfio.txt
for a description of vfio\-pci.
.SS OPTIONS
.sp
\fBaddr\fP
The PCIe address of the device in ssss:bb:dd.f format, eg 0000:7f:00.0
.sp
\fB\-h, \-\-help\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Display command\-line help and exit.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-i, \-\-init\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specifies binding mode operation \- initialize the given addr for vfio.
Used in conjunction with \-u, \-g, and \-n.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-r, \-\-release\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specifies unbinding mode operation \- release the given addr from vfio.
Used in conjunction with \-d.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-d DRIVER, \-\-driver DRIVER\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specifies the device driver to bind to when releasing from vfio.
When omitted, the device is not rebound to a driver (default).
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-u USER, \-\-user USER\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
The user ID to assign when binding to vfio. A new device node is created in
/dev/vfio when the device is bound to vfio\-pci. Use this option to specify
the new device owner.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-g GROUP, \-\-group GROUP\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
The group ID to assign when binding to vfio. Use this option to specify the
new device group for the device created in /dev/vfio.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-n, \-\-no\-sriov\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Do not enable SR\-IOV when binding to vfio. The default value for this option
is FALSE, ie the script should specify SR\-IOV functionality when binding to
the vfio\-pci driver. When omitted, the modprobe command which loads the vfio\-pci
driver will contain the \(gaenable_sriov=1\(ga option. When given, it will not.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-v, \-\-version\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Display script version information and exit.
.ft P
.fi
.UNINDENT
.UNINDENT
.SS EXAMPLES
.sp
\fBopaevfio \-h\fP
\fBopaevfio \-v\fP
\fBsudo opaevfio \-i \-u lab \-g labusers 0000:7f:00.0\fP
\fBsudo opaevfio \-r 0000:7f:00.0\fP
.SS Revision History
.sp
Document Version | Intel Acceleration Stack Version | Changes
—————–|———————————\-|——–
2021.01.07 | IOFS EA | Initial release.
.SH PCI_DEVICE
.SS SYNOPSIS
.sp
\fBpci_device [\-h] [\-E] device\-filter [{aer,remove,rescan,topology,unbind,vf}]\fP
.SS DESCRIPTION
.sp
pci_device is a tool to aid in common operations for managing PCIe devices and
drivers.
.SS OPTIONS
.SS POSITIONAL ARGUMENTS
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\(gadevice filter\(ga

PCIe address of a device or vendor/device ID pair.
The PCIe address follows the format of [segment:]bus:device.function
while the vendor/device ID pair follows the format [vendor ID]:[device ID]
where at least one of these must be present.

\(ga{aer,remove,rescan,topology,unbind,vf}\(ga

action to perform on device

\(gaaer\(ga
Perform AER (Advanced Error Reporting) operations.
The aer action has its own sub\-commands which are listed below:

* \(gadump\(ga sub\-command will print out the AER error counters as reported
   by the sysfs files for the device.
* \(gamask\(ga can either print out the current AER mask bits or set them
  * If \(gashow\(ga or \(gaprint\(ga (or nothing) is given after the \(gamask\(ga
    command, it will show the current mask bits for AER.
By default output will be written in stdout but can be written to an
output file if \(ga\-o|\-\-output FILENAME\(ga argument is given.
  * If \(gaall\(ga is given after the \(gamask\(ga command, it will mask all bits
    (by setting the values to 0xffffffff and 0xffffffff).
  * If \(gaoff\(ga is given after the \(gamask\(ga command, it will unmask all
    bits (by setting the values to 0x0 and 0x0).
  * If two numbers are present after the \(gamask\(ga command, those two
    numbers will be used to set the mask bits.
Values for setting the mask can also be read in from an input file if
\(ga\-i|\-\-input FILENAME\(ga argument is given.

_NOTE_: mask related operations require root privileges


\(garemove\(ga

Remove the pci device from the pci bus

\(garescan\(ga

Rescan the bus as identified by the bus component of the PCIe device address

\(aqtopology\(ga

Print the PCIe topology from the root port to the PCIe device.
This shows the PCIe tree rooted at the PCIe root port.
Each line shows the the PCIe address, vendor ID, and device ID along with
the driver bound to the device. The indentnation is used to show
parent/child relationship of devices.

The line listing the target PCIe device as identified by the given PCIe
address will be highlighted in green while the endpoints will be
highlighted in cyan.

The example below shows the topology of an N3000 device with eight virtual
functions created from one of the Ethernet controllers:

\(ga\(ga\(gaconsole
[pci_address(0000:3a:00.0), pci_id(0x8086, 0x2030)] (pcieport)
    [pci_address(0000:3b:00.0), pci_id(0x10b5, 0x8747)] (pcieport)
        [pci_address(0000:3c:09.0), pci_id(0x10b5, 0x8747)] (pcieport)
            [pci_address(0000:3f:00.0), pci_id(0x8086, 0x0b30)] (dfl\-pci)
        [pci_address(0000:3c:11.0), pci_id(0x10b5, 0x8747)] (pcieport)
            [pci_address(0000:43:00.0), pci_id(0x8086, 0x0b32)] (no driver)
	[pci_address(0000:3c:08.0), pci_id(0x10b5, 0x8747)] (pcieport)
            [pci_address(0000:3d:02.0), pci_id(0x8086, 0x154c)] (iavf)
            [pci_address(0000:3d:00.1), pci_id(0x8086, 0x0d58)] (i40e)
            [pci_address(0000:3d:02.7), pci_id(0x8086, 0x154c)] (iavf)
            [pci_address(0000:3d:02.5), pci_id(0x8086, 0x154c)] (iavf)
            [pci_address(0000:3d:02.3), pci_id(0x8086, 0x154c)] (iavf)
            [pci_address(0000:3d:02.1), pci_id(0x8086, 0x154c)] (iavf)
            [pci_address(0000:3d:00.0), pci_id(0x8086, 0x0d58)] (i40e)
            [pci_address(0000:3d:02.6), pci_id(0x8086, 0x154c)] (iavf)
            [pci_address(0000:3d:02.4), pci_id(0x8086, 0x154c)] (iavf)
            [pci_address(0000:3d:02.2), pci_id(0x8086, 0x154c)] (iavf)
        [pci_address(0000:3c:10.0), pci_id(0x10b5, 0x8747)] (pcieport)
            [pci_address(0000:41:00.0), pci_id(0x8086, 0x0d58)] (i40e)
            [pci_address(0000:41:00.1), pci_id(0x8086, 0x0d58)] (i40e)

\(ga\(ga\(ga

\(gaunbind\(ga

Unbind the driver bound to the device.

\(gavf\(ga

Create/destroy VFs (virtual functions) by setting the number here.
The number given here will be written to sriov_numvfs sysfs file triggering
the PCIe subsystem to create/destroy VFs so that the current number of VFs
will be equal to the given number. If the number given is outside of the total VFs supported, an error message will be displayed to indicate this.
.ft P
.fi
.UNINDENT
.UNINDENT
.SS OPTIONAL ARGUMENTS
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\(ga\-h, \-\-help\(ga

show this help message and exit

\(ga\-E, \-\-other\-endpoints\(ga

perform action on peer PCIe devices
.ft P
.fi
.UNINDENT
.UNINDENT
.SS EXAMPLES
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pci_device 0000:3d:00.0 remove
pci_device 0000:3d:00.0 rescan
pci_device 3d:00.0 topology
pci_device :0b30 topology
pci_device :0b30 aer
pci_device :0b30 aer mask
pci_device :0b30 aer mask all
pci_device :0b30 aer mask \-o mask.dat
pci_device :0b30 aer mask \-i mask.dat
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Revision History
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Document Version | Intel Acceleration Stack Version | Changes
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-
2021.01.13 | IOFS EA | Initial release.
.ft P
.fi
.UNINDENT
.UNINDENT
.SH OPAE.IO
.SS SYNOPSIS
.sp
\fBopae.io ls [\-v,\-\-viddid VID:DID]\fP
\fBopae.io init [\-d PCI_ADDR USER[:GROUP]]\fP
\fBopae.io release [\-d PCI_ADDR]\fP
\fBopae.io [\-d PCI_ADDR] [\-r REGION] walk OFFSET [\-u,\-\-show\-uuid]\fP
\fBopae.io [\-d PCI_ADDR] [\-r REGION] peek OFFSET\fP
\fBopae.io [\-d PCI_ADDR] [\-r REGION] poke OFFSET VALUE\fP
\fBopae.io [\-d PCI_ADDR] [\-r REGION] SCRIPT ARG1 ARG2 ... ARGN\fP
\fBopae.io [\-d PCI_ADDR] [\-r REGION]\fP
.SS DESCRIPTION
.sp
\fBopae.io\fP is an interactive Python environment packaged on top of
\fBlibopaevfio.so\fP, which provides user space access to PCIe devices
via the vfio\-pci driver. The main feature of opae.io is its built\-in
Python command interpreter, along with some Python bindings that provide
a means to access Configuration and Status Registers (CSRs) that reside
on the PCIe device.
.sp
\fBopae.io\fP has two operating modes: command line mode and interactive
mode.
.SS COMMAND LINE MODE
.sp
To view the accelerator devices that are present on the system, \fBopae.io\fP
provides the \fBls\fP command option.
.sp
\fBopae.io ls [\-v,\-\-viddid VID:DID]\fP
.sp
Each accelerator device is listed along with the PCIe address, the
PCIe vendor/device ID, a brief description of the device, and the
driver to which the device is currently bound.
.sp
\fBopae.io\fP provide an option to initialize a PCIe device for use with
the vfio\-pci driver. In order for the device CSRs to be accessed from
user space, the device must first be bound to the vfio\-pci driver. This
is the job of the \fBinit\fP command option.
.sp
\fBopae.io init [\-d PCI_ADDR USER:[GROUP]]\fP
.sp
The \fBinit\fP command unbinds the specified device from its current
driver and binds it to vfio\-pci. This creates a new vfio group under
/dev/vfio. This group path is then used by the \fBlibopaevfio.so\fP
library to interact with the device.
.sp
To release the PCIe device from vfio\-pci and return it to use with its
previous driver, the \fBrelease\fP command option is used.
.sp
\fBopae.io release [\-d PCI_ADDR]\fP
.sp
The \fBrelease\fP command option reverses the actions of the last
\fBinit\fP command, releasing the device from vfio\-pci and binding
it to the driver which was bound at the time the \fBinit\fP command
was issued.
.sp
The \fBwalk\fP command option traverses and displays the Device
Feature List of the given region.
.sp
\fBopae.io walk [\-d PCI_ADDR] [\-r REGION] [OFFSET] [\-u,\-\-show\-uuid]\fP
.sp
The various fields of each Device Feature Header are displayed. The
\fB\-\-show\-uuid\fP option additionally displays the GUID for each feature.
OFFSET can be used to specify the beginning of the DFL in the MMIO
region.
.sp
The \fBpeek\fP command option reads and displays a CSR value.
.sp
\fBopae.io peek [\-d PCI_ADDR] [\-r REGION] OFFSET\fP
.sp
The \fBpoke\fP command option writes a given value to a CSR.
.sp
\fBopae.io poke [\-d PCI_ADDR] [\-r REGION] OFFSET VALUE\fP
.sp
\fBopae.io\fP can also execute Python scripts from the command line.
These Python scripts may contain calls to the device built\-in
functions that are available during an interactive session. Refer
to the description of interactive mode for details.
.sp
\fBopae.io [\-d PCI_ADDR] [\-r REGION] myscript.py a b c\fP
.sp
In order to enter the interactive mode of \fBopae.io\fP, simply
invoke it and optionally pass the desired device address and
MMIO region options.
.sp
\fBopae.io [\-d PCI_ADDR] [\-r REGION]\fP
.SS INTERACTIVE MODE
.sp
Upon entering interactive mode, \fBopae.io\fP begins a Python
interpreter session and displays the command prompt shown below:
.sp
0000:3f:00.0[0]>>
.sp
The first portion of the prompt shows the address of the active
PCIe device, here 0000:3f:00.0. The part in square brackets shows
the active MMIO region, here [0]\&.
.sp
The interpreter waits for a valid Python command, then attempts
to execute the given command in the usual way. The only
differences between the traditional Python command intepreter and
\fBopae.io\fP are that opae.io provides 1) the notion of an active
PCIe device and MMIO region and 2) several built\-in functions and
objects that allow manipulating the active device and MMIO region.
.SS BUILT\-IN FUNCTIONS
.sp
The \fBopae.io\fP built\-in functions assume an active device and
MMIO region. Attempting to use the built\-in functions without first
opening a device and region will result in errors.
.sp
\fBpeek(OFFSET)\fP
.sp
The \fBpeek\fP built\-in function reads and displays a CSR value from
the active device and region, at the offset supplied by its argument.
.sp
0000:3f:00.0[0]>> peek(0x28)
0xdeadbeef
.sp
\fBpoke(OFFSET, VALUE)\fP
.sp
The \fBpoke\fP built\-in function writes the given VALUE to the current
MMIO region at the given OFFSET.
.sp
0000:3f:00.0[0]>> poke(0x28, 0xdeadbeef)
.sp
\fBread_csr(OFFSET)\fP
.sp
The \fBread_csr\fP built\-in function returns the value of the CSR at
the active MMIO region and the given OFFSET.
.sp
0000:3f:00.0[0]>> print(‘0x{:0x}’\&.format(read_csr(0x28)))
0xdeadbeef
.sp
\fBwrite_csr(OFFSET, VALUE)\fP
.sp
The \fBwrite_csr\fP built\-in function writes the given VALUE to
the current MMIO region at the given OFFSET.
.sp
0000:3f:00.0[0]>> write_csr(0x28, 0xdeadbeef)
.sp
\fBdevice(PCI_ADDR)\fP
.sp
The \fBdevice\fP built\-in function allows changing the active
PCIe device.
.sp
0000:3f:00.0[0]>> device(‘0000:2b:00.0’)
0000:2b:00.0>>
.sp
\fBregion(REGION)\fP
.sp
The \fBregion\fP built\-in function allows changing the active
MMIO region.
.sp
0000:2b:00.0>> region(0)
0000:2b:00.0[0]>>
.sp
\fBallocate_buffer(SIZE)\fP
.sp
The \fBallocate_buffer\fP built\-in function creates and returns
a DMA buffer object. The underlying buffer will be SIZE bytes
in length.
.sp
0000:2b:00.0[0]>> b1 = allocate_buffer(4096)
0000:2b:00.0[0]>> print(b1.size, ‘0x{:0x}’\&.format(b1.address), b1.io_address)
4096 0x7f9361c66000 0
.sp
\fBversion()\fP
.sp
The \fBversion\fP built\-in function returns a tuple containing
the four components used to identify the opae.io version:
.sp
0000:2b:00.0[0]>> print(version())
(‘opae.io’, 0, 2, 0)
.SS BUILT\-IN OBJECTS
.sp
\fBopae.io\fP interactive mode provides two global objects
corresponding to the current device and that device’s current
MMIO region. These objects are referred to by global variables
\fBthe_device\fP and \fBthe_region\fP, respectively.
.sp
The \fBdevice\fP class:
.sp
the_device.descriptor() : method that returns the integer file
descriptor of the \fBVFIO container\fP\&.
.sp
0000:2b:00.0[0]>> print(the_device.descriptor())
5
.sp
the_device.\fBrepr\fP() : method that is invoked when a \fBdevice\fP
object is printed.
.sp
0000:2b:00.0[0]>> print(the_device)
0000:2b:00.0
.sp
the_device.allocate(SIZE) : method that allocates and returns a
\fBsystem_buffer\fP object. The buffer will be mapped into the
DMA space of \fBthe_device\fP\&.
.sp
0000:2b:00.0[0]>> b1 = the_device.allocate(4096)
.sp
the_device.pci_address() : read\-only property that returns the
PCIe address of \fBthe_device\fP\&.
.sp
0000:2b:00.0[0]>> print(the_device.pci_address)
0000:2b:00.0
.sp
the_device.num_regions : read\-only property that returns the
number of MMIO regions in \fBthe_device\fP\&.
.sp
0000:2b:00.0[0]>> print(the_device.num_regions)
2
.sp
the_device.regions : read\-only property that returns a list
of the active MMIO regions of \fBthe_device\fP:
.sp
0000:2b:00.0[0]>> print(the_device.regions)
[0, 2]
.sp
The \fBregion\fP class:
.sp
the_region.write32(OFFSET, VALUE) : method that writes a
32\-bit VALUE to the CSR at OFFSET.
.sp
the_region.read32(OFFSET) : method that returns a 32\-bit
CSR at the given OFFSET.
.sp
0000:2b:00.0[0]>> the_region.write32(0x28, 0xdeadbeef)
0000:2b:00.0[0]>> print(‘0x{:0x}’\&.format(the_region.read32(0x28)))
0xdeadbeef
.sp
the_region.write64(OFFSET, VALUE): method that writes a
64\-bit VALUE to the CSR at OFFSET.
.sp
the_region.read64(OFFSET): method that returns a 64\-bit
CSR at the given OFFSET.
.sp
0000:2b:00.0[0]>> the_region.write64(0x28, 0xbaddecaf)
0000:2b:00.0[0]>> print(‘0x{:0x}’\&.format(the_region.read64(0x28)))
0xbaddecaf
.sp
the_region.index(): method that returns the MMIO index
of \fBthe_region\fP\&.
.sp
0000:2b:00.0[0]>> print(the_region.index())
0
.sp
the_region.\fBrepr\fP(): method that is invoked when a \fBregion\fP
object is printed.
.sp
0000:2b:00.0[0]>> print(the_region)
0
.sp
the_region.\fBlen\fP(): method that is invoked to determine the
MMIO region size.
.sp
0000:2b:00.0[0]>> print(len(the_region))
524288
.sp
The \fBallocate_buffer()\fP built\-in function and the
\fBdevice.allocate()\fP method return objects of type \fBsystem_buffer\fP\&.
.sp
The \fBsystem_buffer\fP class is as follows:
.sp
\fBbuf.size\fP: read\-only property that gives the buffer size.
.sp
0000:2b:00.0[0]>> print(b1.size)
4096
.sp
\fBbuf.address\fP: read\-only property that gives the buffer’s
user mode virtual address.
.sp
0000:2b:00.0[0]>> print(‘0x{:0x}’\&.format(b1.address))
0x7f2c15d8200
.sp
\fBbuf.io_address\fP: read\-only property that gives the buffer’s
IO address.
.sp
0000:2b:00.0[0]>> print(‘0x{:0x}’\&.format(b1.io_address))
0x0
.sp
\fBbuf.__getitem__\fP and \fBbuf.__setitem__\fP: indexing get/set
of 64\-bit data item.
.sp
0000:2b:00.0[0]>> b1[0] = 0xdecafbad
0000:2b:00.0[0]>> print(‘0x{:0x}’\&.format(b1[0]))
0xdecafbad
.sp
\fBbuf.read8(OFFSET)\fP
\fBbuf.read16(OFFSET)\fP
\fBbuf.read32(OFFSET)\fP
\fBbuf.read64(OFFSET)\fP : methods that read the given size
data item from the given buffer OFFSET.
.sp
\fBbuf.fill8(VALUE)\fP
\fBbuf.fill16(VALUE)\fP
\fBbuf.fill32(VALUE)\fP
\fBbuf.fill64(VALUE)\fP : methods that fill the buffer with
the given VALUE, using the given size.
.sp
\fBb1.compare(b2)\fP: method that compares buffers.
The method returns the index of the first byte that miscompares,
or the length of b1.
.SS Revision History
.sp
Document Version | Intel Acceleration Stack Version | Changes
—————–|———————————\-|——–
2021.01.25 | IOFS EA | Initial release.
.SH HOST_EXERCISER
.SS SYNOPSIS
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Usage: host_exerciser [OPTIONS] SUBCOMMAND


Options:
  \-h,\-\-help                   Print this help message and exit
  \-p,\-\-pci\-address TEXT       [<domain>:]<bus>:<device>.<function>
  \-l,\-\-log\-level TEXT:{trace,debug,info,warning,error,critical,off}=warning
                              stdout logging level
  \-s,\-\-shared                 open in shared mode, default is off
  \-t,\-\-timeout UINT=60000     test timeout (msec)
  \-m,\-\-mode UINT:value in {lpbk\->0,read\->1,trput\->3,write\->2} OR {0,1,3,2}=lpbk
                              host exerciser mode {lpbk,read, write, trput}
  \-\-cls UINT:value in {cl_1\->0,cl_2\->1,cl_4\->2,cl_8\->3} OR {0,1,2,3}=cl_1
                              number of CLs per request{cl_1, cl_2, cl_4, cl_8}
  \-\-continuousmode BOOLEAN=false
                              test rollover or test termination
  \-\-atomic UINT:value in {cas_4\->9,cas_8\->11,fadd_4\->1,fadd_8\->3,off\->0,swap_4\->5,swap_8\->7} OR {9,11,1,3,0,5,7}=off
                              atomic requests (only permitted in combination with lpbk/cl_1)
  \-\-encoding UINT:value in {default\->0,dm\->1,pu\->2,random\->3} OR {0,1,2,3}=default
                              data mover or power user encoding \-\- random interleaves both in the same stream
  \-d,\-\-delay BOOLEAN=false    Enables random delay insertion between requests
  \-\-interleave UINT=0         Interleave requests pattern to use in throughput mode {0, 1, 2}
                              indicating one of the following series of read/write requests:
                              0: rd\-wr\-rd\-wr
                              1: rd\-rd\-wr\-wr
                              2: rd\-rd\-rd\-rd\-wr\-wr\-wr\-wr
  \-\-interrupt UINT:INT in [0 \- 3]
                              The Interrupt Vector Number for the device
  \-\-contmodetime UINT=1       Continuous mode time in seconds
  \-\-testall BOOLEAN=false     Run all tests
  \-\-clock\-mhz UINT=0          Clock frequency (MHz) \-\- when zero, read the frequency from the AFU

Subcommands:
  lpbk                        run simple loopback test
  mem                         run simple mem test

.ft P
.fi
.UNINDENT
.UNINDENT
.SS DESCRIPTION
.sp
The host exerciser used to exercise and characterize the various host\-FPGA
interactions eg. MMIO, Data transfer from host to FPGA , PR, host to FPGA memory etc.
.SS Host Exerciser Loopback (HE\-LBK)
.sp
HE\-LB is responsible for generating traffic with the intention of exercising the
path from the AFU to the Host at full bandwidth.
Host Exerciser Loopback (HE\-LBK) AFU can move data between host memory and FPGA.
.sp
HE\-LBK supports:
.INDENT 0.0
.IP \(bu 2
Latency (AFU to Host memory read)
.IP \(bu 2
MMIO latency (Write+Read)
.IP \(bu 2
MMIO BW (64B MMIO writes)
.IP \(bu 2
BW (Read/Write, Read only, Wr only)
.UNINDENT
.SS Host Exerciser Memory (HE\-MEM)
.sp
HE\-MEM is used to exercise use of FPGA connected DDR; data read from the host is
written to DDR, and the same data is read from DDR before sending it back to the
host. HE\-MEM uses external DDR memory (i.e. EMIF) to store data. It has a customized
version of the AVMM interface to communicate with the EMIF memory controller.
.sp
Execution of these exercisors requires the user to bind specific VF endpoint to vfio\-pci
Bind the correct endpoint for a device with B/D/F 0000:b1:00.0
.sp
\fB[user@localhost]: sudo opae.io init \-d 0000:b1:00.2 user:user\fP
.SS HOST EXERCISER SUB COMMANDS
.sp
\fBlpbk\fP
.sp
run host exerciser loopback test
.sp
\fBmem\fP
.sp
run host exerciser memory test
.SS OPTIONAL ARGUMENTS
.sp
\fB\-\-help, \-h\fP
.sp
Prints help information and exit.
.SS COMMON ARGUMENTS / OPTIONS
.sp
The following arguments are common to all commands and are optional.
.sp
\fB \-p,\-\-pci\-address\fP
.sp
PCIe domain, bus, device, function number of fpga resource.
.sp
\fB\-l,\-\-log\-level\fP
.sp
set host exerciser tool log level, trace, debug, info, warning, error, critical, off
.sp
\fB\-s,\-\-shared \fP
.sp
open FPGA PCIe resource in shared mode
.sp
\fB\-t,\-\-timeout\fP
.sp
host exerciser tool time out, by default time out 60000
.sp
\fB\-m,\-\-mode\fP
.sp
host exerciser test modes are lpbk, read, write, trput
.sp
\fB\-\-cls\fP
.sp
Number of cachelines per request 1, 2, 3, 4.
.sp
\fB\-\-continuousmode\fP
.sp
Configures test rollover or test termination mode.
.sp
\fB\-\-atomic\fP
.sp
atomic requests.
.sp
\fB\-\-encoding\fP
.sp
select data mover mode or power user mode or random.
.sp
\fB\-d,\-\-delay\fP
.sp
Enables random delay insertion between requests.
.sp
\fB\-\-interleave\fP
.sp
Enables interleave requests in throughput mode.
Value:3’b000\-Rd,Wr,Rd,Wr
Value:3’b001\-Rd,Rd,Wr,Wr
Value:3’b010\-Rd,Rd,Rd,Rd,Wr,Wr,Wr,Wr
Value:3’b011\-Not supported
.sp
\fB\-\-interrupt\fP
.sp
Accelerator interrupt vector Number.
.sp
\fB\-\-contmodetime\fP
.sp
Continuous mode time in seconds.
.sp
\fB\-\-testall \fP
.sp
Run all host exerciser tests.
.sp
\fB\-\-clock\-mhz\fP
.sp
pcie clock frequency, default value 350Mhz.
.SS EXAMPLES
.sp
This command exerciser Loopback afu:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
host_exerciser lpbk
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command exerciser memory afu:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
host_exerciser mem
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command exerciser Loopback afu on pcie 000:3b:00.0:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
host_exerciser \-\-pci\-address 000:3b:00.0    lpbk
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command exerciser Loopback afu on pcie 000:3b:00.0 and run in write mode:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
host_exerciser \-\-pci\-address 000:3b:00.0   \-\-mode write lpbl
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command exerciser Loopback afu on pcie 000:3b:00.0 and run 2 cache lines per request:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
host_exerciser \-\-pci\-address 000:3b:00.0   \-\-cls cl_2  lpbk
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command exerciser Loopback afu on pcie 000:3b:00.0 and run continuous mode for 10 seconds:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
host_exerciser \-\-pci\-address 000:3b:00.0   \-cls cl_1   \-m 0 \-\-continuousmode true \-\-contmodetime 10 lpbk
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Revision History
.sp
| Document Version |  Intel Acceleration Stack Version  | Changes  |
| —————\- |————————————|———\-|
| 2018.05.21 | 1.1 Beta. (Supported with Intel Quartus Prime Pro Edition 17.1.) | Updated description of the \fBfme\fP command |
.SH HSSI ETHERNET STATISTICS
.SS SYNOPSIS
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
hssistats [\-h] [\-\-pcie\-address PCIE_ADDRESS, \-P PCIE_ADDRESS]
.ft P
.fi
.UNINDENT
.UNINDENT
.SS DESCRIPTION
.sp
The \fBhssistats\fP  tool provides the MAC statistics.
.SS OPTIONAL ARGUMENTS
.sp
\fB\-h, \-\-help\fP
.sp
Prints usage information
.sp
\fB\-\-pcie\-address PCIE_ADDRESS, \-P PCIE_ADDRESS\fP
.sp
The PCIe address of the desired fpga in ssss:bb:dd.f format. sbdf of device to program (e.g. 04:00.0 or 0000:04:00.0). Optional when one device in system.
.SS EXAMPLES
.sp
\fBhssistats \-\-pcie\-address  0000:04:00.0\fP
.sp
prints the MAC statistics
.SS Revision History
.sp
| Date | Intel Acceleration Stack Version | Changes Made |
|:——|—————————\-|:————–|
|2018.05.21| DCP 1.1 Beta (works with Quartus Prime Pro 17.1.1) | Made the following changes: Expanded descriptions of \fBnlb_mode_3\fP and\fBdma_afu\fP tests.  Added a second example command. |
.SH HSSI ETHERNET MAC
.SS SYNOPSIS
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
hssimac [\-h] \-\-pcie\-address PCIE_ADDRESS [\-\-port PORT]
.ft P
.fi
.UNINDENT
.UNINDENT
.SS DESCRIPTION
.sp
The \fBhssimac\fP  tool provides Maximum TX and RX frame size.
.SS OPTIONAL ARGUMENTS
.sp
\fB\-h, \-\-help\fP
.sp
Prints usage information
.sp
\fB\-\-pcie\-address PCIE_ADDRESS, \-P PCIE_ADDRESS\fP
.sp
The PCIe address of the desired fpga  in ssss:bb:dd.f format. sbdf of device to program (e.g. 04:00.0 or 0000:04:00.0).
.sp
\fB\-\-port PORT\fP
.sp
hssi port number.
.SS EXAMPLES
.sp
\fBhssimac \-\-pcie\-address  0000:04:00.0 \-\-port 1\fP
.sp
prints Maximum TX and RX frame size for port 1.
.SS Revision History
.sp
| Date | Intel Acceleration Stack Version | Changes Made |
|:——|—————————\-|:————–|
|2018.05.21| DCP 1.1 Beta (works with Quartus Prime Pro 17.1.1) | Made the following changes: Expanded descriptions of \fBnlb_mode_3\fP and\fBdma_afu\fP tests.  Added a second example command. |
.SH HSSI ETHERNET LOOPBACK
.SS SYNOPSIS
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
hssiloopback [\-h] [\-\-pcie\-address PCIE_ADDRESS, \-P PCIE_ADDRESS] \-\-loopback [{enable,disable}]
.ft P
.fi
.UNINDENT
.UNINDENT
.SS DESCRIPTION
.sp
The \fBhssiloopback\fP  tool enables and disable ethernet loopback.
.SS OPTIONAL ARGUMENTS
.sp
\fB\-h, \-\-help\fP
.sp
Prints usage information
.sp
\fB\-\-pcie\-address PCIE_ADDRESS, \-P PCIE_ADDRESS\fP
.sp
The PCIe address of the desired fpga  in ssss:bb:dd.f format. sbdf of device to program (e.g. 04:00.0 or 0000:04:00.0). Optional when one device in system.
.sp
\fB\-\-loopback [{enable,disable}]\fP
.sp
Ethernet enable or disable loopback.
.SS EXAMPLES
.sp
\fBhssiloopback \-\-pcie\-address  0000:04:00.0 \-\-loopback enable\fP
.sp
Enables ethernet loopback
.sp
\fBhssiloopback \-\-pcie\-address  0000:04:00.0 \-\-loopback disable\fP
.sp
Disable ethernet loopback
.SS Revision History
.sp
| Date | Intel Acceleration Stack Version | Changes Made |
|:——|—————————\-|:————–|
|2018.05.21| DCP 1.1 Beta (works with Quartus Prime Pro 17.1.1) | Made the following changes: Expanded descriptions of \fBnlb_mode_3\fP and\fBdma_afu\fP tests.  Added a second example command. |
.SH RSU
.SS SYNOPSIS
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
rsu [\-h] [\-d] {bmc,bmcimg,retimer,fpga,sdm,fpgadefault} [PCIE_ADDR]

.ft P
.fi
.UNINDENT
.UNINDENT
.SS DESCRIPTION
.SS Mode 1: RSU
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
rsu bmc \-\-page=(user|factory) [PCIE_ADDR]
rsu retimer [PCIE_ADDR]
rsu fpga \-\-page=(user1|user2|factory) [PCIE_ADDR]
rsu sdm \-\-type=(sr|pr|sr_cancel|pr_cancel) [PCIE_ADDR]
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Perform RSU (remote system update) operation on PAC device
given its PCIe address.
An RSU operation sends an instruction to the device to trigger
a power cycle of the card only. This will force reconfiguration
from flash for either BMC, Retimer, SDM, (on devices that support these)
or the FPGA.
.SS Mode 2: Default FPGA Image
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
rsu fpgadefault \-\-page=(user1|user2|factory) \-\-fallback=<csv> [PCIE_ADDR]
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Set the default FPGA boot sequence. The –page option determines
the primary FPGA boot image. The –fallback option allows a comma\-separated
list of values to specify fallback images.
.SS POSITIONAL ARGUMENTS
.sp
\fB{bmc,bmcimg,retimer,fpga,sdm,fpgadefault}\fP
.sp
type of RSU operation or set Default FPGA Image operation.
.sp
\fBPCIE_ADDR\fP
PCIe address of device to do rsu (e.g. 04:00.0 or 0000:04:00.0)
.SS OPTIONAL ARGUMENTS
.sp
\fB\-h, \-\-help\fP
show this help message and exit
.sp
\fB\-d, \-\-debug\fP
log debug statements
.sp
\fB\-\-force\fP
force rsu operation
.SS EXAMPLE
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# rsu bmc \-\-page=user 25:00.0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Triggers a boot of the BMC image (user page) for the device with PCIe
address 25:00.0.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# rsu bmc \-\-page=factory 25:00.0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Triggers a factory boot of the BMC image for the device with
PCIe address 25:00.0.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# rsu fpga \-\-page=user2 25:00.0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Triggers a reconfiguration of the FPGA (user2 page) for the
device with PCIe address 25:00.0.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# rsu \-\-force fpga \-\-page=user2 25:00.0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Forces a reconfiguration of the FPGA (user2 page) for the
device with PCIe address 25:00.0. Default behavior is to not perform
the rsu operation if DPC (downstream port containment) is not supported
and AER (advanced error reporting) is also not supported. Using –force
changes this behavior to perform rsu operation regardless but may result
in a surprise removal of pci devices which may cause the Linux kernel
to panic.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# rsu fpga \-\-page=factory 25:00.0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Triggers a factory reconfiguration of the FPGA for the device
with PCIe address 25:00.0.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# rsu sdm \-\-type=sr 25:00.0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Triggers Static Region key programming for the device with
PCIE address 25:00.0.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# rsu fpgadefault \-\-page=factory \-\-fallback=user1,user2 25:00.0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Sets the FPGA boot sequence to factory with fallbacks user1, user2.
.SH MEM_TG
.SS SYNOPSIS
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Usage: mem_tg [OPTIONS] SUBCOMMAND

Options:
  \-h,\-\-help                   Print this help message and exit
  \-g,\-\-guid TEXT=4DADEA34\-2C78\-48CB\-A3DC\-5B831F5CECBB
                              GUID
  \-p,\-\-pci\-address TEXT       [<domain>:]<bus>:<device>.<function>
  \-l,\-\-log\-level TEXT:{trace,debug,info,warning,error,critical,off}=info
                              stdout logging level
  \-s,\-\-shared                 open in shared mode, default is off
  \-t,\-\-timeout UINT=60000     test timeout (msec)
  \-m,\-\-mem\-channel UINT=0     Target memory bank for test to run on (0 indexed)
  \-\-loops UINT=1              Number of read/write loops to be run
  \-w,\-\-writes UINT=1          Number of unique write transactions per loop
  \-r,\-\-reads UINT=1           Number of unique read transactions per loop
  \-b,\-\-bls UINT=1             Burst length of each request
  \-\-stride UINT=1             Address stride for each sequential transaction
  \-\-data UINT:value in {fixed\->0,prbs15\->2,prbs31\->3,prbs7\->1,rot1\->3} OR {0,2,3,1,3}=fixed
                              Memory traffic data pattern: fixed, prbs7, prbs15, prbs31, rot1
  \-f,\-\-mem\-frequency UINT=0   Memory traffic clock frequency in MHz

Subcommands:
  tg_test                     configure & run mem traffic generator test

.ft P
.fi
.UNINDENT
.UNINDENT
.SS DESCRIPTION
.sp
The memory traffic generator (TG) used to exercise and test available memory channels
with a configurable traffic pattern.
.sp
Execution of this application requires the user to bind the specific VF endpoint containing the mem_tg AFU id to vfio\-pci
.sp
In the TG, read responses are checked against a specified pattern. If the application is configured to perform a read only test on a region of memory that has not previously been initialized to contain that pattern it will flag a test failure.
.SS OPTIONAL ARGUMENTS
.sp
\fB\-\-help, \-h\fP
.sp
Prints help information and exit.
.SS COMMON ARGUMENTS / OPTIONS
.sp
The following arguments are common to all commands and are optional.
.sp
\fB \-p,\-\-pci\-address\fP
.sp
PCIe domain, bus, device, function number of fpga resource.
.sp
\fB\-l,\-\-log\-level\fP
.sp
set application log level, trace, debug, info, warning, error, critical, off
.sp
\fB\-s,\-\-shared \fP
.sp
open FPGA PCIe resource in shared mode
.sp
\fB\-t,\-\-timeout\fP
.sp
mem_tg application time out, by default time out 60000
.sp
\fB\-m,\-\-mem\-channel\fP
.sp
Target memory banks for test to run on (0 indexed). Multiple banks seperated by ‘, ‘\&. ‘\-m all’ will use every channel enumerated in MEM_TG_CTRL
Example: to run on channels 1 and 2:            \-m 0, 1
Example: to run on all available channels:      \-m all
.sp
default: 0
.sp
\fB\-\-loops\fP
.sp
Number of read/write loops to be run
default: 1
.sp
\fB\-w,\-\-writes\fP
.sp
Number of unique write transactions per loop.
default: 1
.sp
\fB\-r,\-\-reads\fP
.sp
Number of unique read transactions per loop
default: 1
.sp
\fB\-b,\-\-bls\fP
.sp
AXI4 burst length of each request.  Supports 1\-256 transfers beginning from 0.
default: 0
.sp
\fB\-\-stride\fP
.sp
Address stride for each sequential transaction (>= burst length)
default: 1
.sp
\fB\-\-data\fP
.sp
Memory traffic data pattern.
0 = fixed {0xFF, 0x00}
1 = prbs7
2 = prbs15
3 = prbs31
4 = rot1
.sp
default: fixed
.sp
\fB\-f, \-\-mem\-frequency\fP
.sp
Memory traffic clock frequency in MHz
default: 300 MHz
.SS EXAMPLES
.sp
This command will run a basic read/write test on the channel 0 traffic generator:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mem_tg tg_test
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command will run the application for an afu on pcie 000:b1:00.7:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mem_tg \-\-pci\-address 000:b1:00.7 tg_test
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command will test channel 2 write bandwidth:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mem_tg \-loops 1000 \-w 1000 \-r 0 \-m 2 tg_test
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command will perform a read bandwidth test with a burst of 16 on channel 1 and perform a data comparison with the prbs7 pattern:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mem_tg \-loops 1000 \-w 0 \-r 1000 \-b 0xF \-\-data prbs7 \-m 1 tg_test
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command will perform a read/write test with 1 MB strided access to channel 0 memory:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mem_tg \-loops 10000 \-\-stride 0x100000 tg_test
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Revision History
.sp
| Document Version |  Intel Acceleration Stack Version  | Changes  |
| —————\- |————————————|———\-|
| 2022.07.21 | 2.0.11  (Supported with Intel Quartus Prime Pro Edition 22.1.) | Added description of the \fBmem_tg\fP command |
.SH VABTOOL
.SS SYNOPSIS
.sp
\fBvabtool [\-r RETRIES] [\-d] [\-y] [\-v] <ACTION>\fP
.sp
Where ACTION is defined as one of the following:
.sp
\fBvabtool sr_key_provision PCIE_ADDRESS SR_RKH_FILE FPGA_IMG_FILE\fP
\fBvabtool sr_status PCIE_ADDRESS\fP
\fBvabtool pr_key_provision PCIE_ADDRESS PR_AUTH_CERT_FILE PR_RKH_FILE\fP
\fBvabtool pr_status PCIE_ADDRESS\fP
\fBvabtool sr_key_cancel PCIE_ADDRESS SR_RKH_CANCEL_FILE\fP
\fBvabtool sr_cancel_status PCIE_ADDRESS\fP
\fBvabtool pr_key_cancel PCIE_ADDRESS PR_RKH_CANCEL_FILE\fP
\fBvabtool pr_cancel_status PCIE_ADDRESS\fP
.SS DESCRIPTION
.sp
The \fBvabtool\fP command helps perform Vendor Authenticated Boot
provisioning of Static Region and Partial Reconfiguration Region key
hashes and helps perform SR and PR hash cancellation and status reporting.
.SS OPTIONS
.sp
\fB\-r RETRIES, \-\-retries RETRIES\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Specifies the number of times a failed SR or PR key provision is to be
retried. The default value for RETRIES is 3.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-d, \-\-dry\-run\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Don\(aqt execute the actual fpgasupdate and rsu commands, but only print
the commands that would be executed during a normal run of the script.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-y, \-\-yes\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
The tool will respond with an automatic Yes answer to all confirmation
prompts posed by the sub\-tools.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\-v, \-\-version\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Display script version information and exit.
.ft P
.fi
.UNINDENT
.UNINDENT
.SS EXAMPLES
.sp
\fBsudo vabtool \-y sr_key_provision 0000:bc:00.0 my_sr_rkh.bin my_fpga.bin\fP
\fBsudo vabtool sr_status 0000:bc:00.0\fP
\fBsudo vabtool \-y pr_key_provision 0000:bc:00.0 pr_auth_cert.bin my_pr_rkh.bin\fP
\fBsudo vabtool pr_status 0000:bc:00.0\fP
\fBsudo vabtool sr_key_cancel 0000:bc:00.0 my_sr_rhk_cancel.bin\fP
\fBsudo vabtool sr_cancel_status 0000:bc:00.0\fP
\fBsudo vabtool pr_key_cancel 0000:bc:00.0 my_pr_rhk_cancel.bin\fP
\fBsudo vabtool pr_cancel_status 0000:bc:00.0\fP
.SS Revision History
.sp
Document Version | Intel Acceleration Stack Version | Changes
—————–|———————————\-|——–
2022.10.31 | IOFS 2022.4 | Initial release.
.SH OFS.UIO
.SS SYNOPSIS
.sp
\fBofs.uio [\-h] [\-\-pcie\-address PCIE_ADDRESS] [\-\-uio uiox] [\-\-feature\-id FEATURE_ID] [\-\-region\-index REGION_INDEX] [\-\-mailbox\-cmdcsr offset] [\-\-bit\-size {8,16,32,64}] [\-\-peek offset] [\-\-poke offset value] [\-\-mailbox\-read offset] [\-\-mailbox\-dump address size] [\-\-mailbox\-write address value]\fP
.sp
\fBofs.uio [\-\-uio uiox] [\-\-peek offset]\fP
\fBofs.uio [\-\-uio uiox] [\-\-poke offset value] \fP
\fBofs.uio [\-\-uio uiox] [\-\-mailbox\-read address] \fP
\fBofs.uio [\-\-uio uiox] [\-\-mailbox\-write address value] \fP
\fBofs.uio [\-\-uio uiox] [\-\-mailbox\-dump address size] \fP
\fBofs.uio [\-\-pcie\-address PCIE_ADDRESS] [\-\-feature\-id FEATURE_ID] [\-\-peek offset]\fP
\fBofs.uio [\-\-pcie\-address PCIE_ADDRESS] [\-\-feature\-id FEATURE_ID] [\-\-poke offset value] \fP
\fBofs.uio [\-\-pcie\-address PCIE_ADDRESS] [\-\-feature\-id FEATURE_ID] [\-\-mailbox\-read address] \fP
\fBofs.uio [\-\-pcie\-address PCIE_ADDRESS] [\-\-feature\-id FEATURE_ID] [\-\-mailbox\-write address value] \fP
\fBofs.uio [\-\-pcie\-address PCIE_ADDRESS] [\-\-feature\-id FEATURE_ID] [\-\-mailbox\-dump address size] \fP
.SS DESCRIPTION
.sp
\fBofs.uio\fP is a tool that provides user space access to DFL UIO devices,
command line options like peek, poke, mailbox\-read, mailbox\-write, mailbox\-dump to
access Configuration and Status Registers (CSRs).
.SS OPTIONS
.SS Peek
.sp
Peek/Read UIO CSR offset
\fBofs.uio [\-\-uio uio] [\-\-peek offset]\fP
\fBofs.uio [\-\-pcie\-address PCIE_ADDRESS] [\-\-feature\-id FEATURE_ID] [\-\-peek offset]\fP
.SS Poke
.sp
Poke/Write value to UIO CSR offset
\fBofs.uio [\-\-uio uio] [\-\-poke offset value] \fP
\fBofs.uio [\-\-pcie\-address PCIE_ADDRESS] [\-\-feature\-id FEATURE_ID] [\-\-poke offset value] \fP
.SS Mailbox Read
.sp
Read CSR address using mailbox
\fBofs.uio [\-\-uio uio] [\-\-mailbox\-read address] \fP
\fBofs.uio [\-\-pcie\-address PCIE_ADDRESS] [\-\-feature\-id FEATURE_ID] [\-\-mailbox\-read address] \fP
.SS Mailbox Write
.sp
Write value to CSR address using mailbox 
\fBofs.uio [\-\-uio uio] [\-\-mailbox\-write address value] \fP
\fBofs.uio [\-\-pcie\-address PCIE_ADDRESS] [\-\-feature\-id FEATURE_ID] [\-\-mailbox\-write address value] \fP
.SS Mailbox Dump
.sp
Reads/Dumps block size of CSR address using mailbox
\fBofs.uio [\-\-uio uio] [\-\-mailbox\-dump address size] \fP
\fBofs.uio [\-\-pcie\-address PCIE_ADDRESS] [\-\-feature\-id FEATURE_ID] [\-\-mailbox\-dump address size] \fP
.SS Bit size
.sp
Read/Write bit\-field 8,16,32,64 sizes
\fBofs.uio [\-\-uio uio] \-\-bit\-size 8 [\-\-peek offset]\fP
\fBofs.uio [\-\-uio uio] \-\-bit\-size 32 [\-\-peek offset]\fP
.SS PCIe Address
.sp
PCIE_ADDR PCIe address of FPGA device
\fBofs.uio [\-\-pcie\-address PCIE_ADDRESS] [\-\-feature\-id FEATURE_ID] [\-\-peek offset]\fP
.SS UIO region index
.sp
UIO region index, default region index is 0 
\fBofs.uio [\-\-uio uio] \-\-region\-index 0 [\-\-peek offset]\fP
\fBofs.uio [\-\-uio uio] \-\-region\-index 1 [\-\-peek offset]\fP
.SS Mailbox command status csr offset
.sp
Mailbox command status csr offset,
default value set to dfl pcie subsystem system feature mailbox command status register offset 0x28 
\fBofs.uio [\-\-uio uio] \-\-mailbox\-cmdcsr 0xa8 [\-\-mailbox\-read address] \fP
\fBofs.uio [\-\-pcie\-address PCIE_ADDRESS] [\-\-feature\-id FEATURE_ID] \-\-mailbox\-cmdcsr 0xa8  [\-\-mailbox\-read address] \fP
.SS EXAMPLES
.sp
Peek/Read
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
ofs.uio \-\-uio uio0 \-\-peek 0x0
peek(0x0): 0x3000000010002015

ofs.uio \-\-uio uio6 \-\-peek 0x0
peek(0x0): 0x3000000100000020

ofs.uio \-\-pcie\-address 0000:b1:00.0 \-\-feature\-id 0x15 \-\-peek 0x0
peek(0x0): 0x3000000010002015

ofs.uio \-\-uio uio0 \-\-peek 0x0 \-\-bit\-size 32
peek(0x0): 0x10002015
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Poke/Write
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
ofs.uio \-\-uio uio6 \-\-peek 0x8
peek(0x8): 0x0
ofs.uio \-\-uio uio6 \-\-poke  0x8 0xabcdd12345
poke(0x8):0xabcdd12345

ofs.uio \-\-pcie\-address 0000:b1:00.0 \-\-feature\-id 0x15 \-\-peek 0x0
peek(0x8): 0x0
ofs.uio \-\-pcie\-address 0000:b1:00.0 \-\-feature\-id 0x15 \-\-poke  0x8 0x1234
poke(0x8):0x1234
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Mailbox Read
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
ofs.uio \-\-uio uio6 \-\-mailbox\-read 0x0
MailboxRead(0x0): 0x1000000
ofs.uio \-\-uio uio6 \-\-mailbox\-read 0x8
MailboxRead(0x8): 0x110c000

ofs.uio \-\-pcie\-address 0000:b1:00.0 \-\-feature\-id 0x20 \-\-mailbox\-read 0x0
MailboxRead(0x0): 0x1000000
ofs.uio \-\-pcie\-address 0000:b1:00.0 \-\-feature\-id 0x20 \-\-mailbox\-read 0x8 
MailboxRead(0x8): 0x110c000
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Mailbox Write
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
ofs.uio \-\-uio uio6 \-\-mailbox\-write 0x0 0x1234
MailboxWrite(0x0):0x1234
ofs.uio \-\-uio uio6 \-\-mailbox\-read 0x0
MailboxRead(0x0):0x1234

ofs.uio \-\-pcie\-address 0000:b1:00.0 \-\-feature\-id 0x20 \-\-mailbox\-write 0x0 0x1234
MailboxWrite(0x0):0x1234
ofs.uio \-\-pcie\-address 0000:b1:00.0 \-\-feature\-id 0x20 \-\-mailbox\-read 0x0 
MailboxRead(0x0):0x1234
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Mailbox Dump
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
ofs.uio \-\-uio uio6 \-\-mailbox\-dump 0x0 0x10
MailboxDump(0x0): 0x1000000
MailboxDump(0x4): 0x1000000
MailboxDump(0x8): 0x110c000
MailboxDump(0xc): 0x110c000
MailboxDump(0x10): 0x0
MailboxDump(0x14): 0x0
MailboxDump(0x18): 0x0
MailboxDump(0x1c): 0x0
MailboxDump(0x20): 0x0
MailboxDump(0x24): 0x0
MailboxDump(0x28): 0x0
MailboxDump(0x2c): 0x0
MailboxDump(0x30): 0x0
MailboxDump(0x34): 0x0
MailboxDump(0x38): 0x0
MailboxDump(0x3c): 0x0



ofs.uio \-\-pcie\-address 0000:b1:00.0 \-\-feature\-id 0x20 \-\-mailbox\-dump 0x0 0x10
MailboxDump(0x0): 0x1000000
MailboxDump(0x4): 0x1000000
MailboxDump(0x8): 0x110c000
MailboxDump(0xc): 0x110c000
MailboxDump(0x10): 0x0
MailboxDump(0x14): 0x0
MailboxDump(0x18): 0x0
MailboxDump(0x1c): 0x0
MailboxDump(0x20): 0x0
MailboxDump(0x24): 0x0
MailboxDump(0x28): 0x0
MailboxDump(0x2c): 0x0
MailboxDump(0x30): 0x0
MailboxDump(0x34): 0x0
MailboxDump(0x38): 0x0
MailboxDump(0x3c): 0x0


.ft P
.fi
.UNINDENT
.UNINDENT
.SS Revision History
.sp
Document Version | Intel Acceleration Stack Version | Changes
—————–|———————————\-|——–
2021.01.25 | IOFS EA | Initial release.
.SH AUTHOR
Intel DCG FPT SW
.SH COPYRIGHT
2017 Intel Corporation
.\" Generated by docutils manpage writer.
.
