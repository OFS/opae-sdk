.TH "include/opae/enum.h" 3 "Wed Nov 22 2023" "Version -.." "OPAE C API" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/opae/enum.h \- APIs for resource enumeration and managing tokens\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <opae/types\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "\fBfpga_result\fP \fBfpgaEnumerate\fP (const \fBfpga_properties\fP *filters, uint32_t num_filters, \fBfpga_token\fP *tokens, uint32_t max_tokens, uint32_t *num_matches)"
.br
.ti -1c
.RI "\fBfpga_result\fP \fBfpgaCloneToken\fP (\fBfpga_token\fP src, \fBfpga_token\fP *dst)"
.br
.ti -1c
.RI "\fBfpga_result\fP \fBfpgaDestroyToken\fP (\fBfpga_token\fP *token)"
.br
.in -1c
.SH "Detailed Description"
.PP 
APIs for resource enumeration and managing tokens\&. 

These APIs are the first step for any application using OPAE to discover resources that are present on the system\&. They allow selective enumeration (i\&.e\&. getting a list of resources that match a given list of criteria) and methods to manage the lifecycle of tokens generated by \fBfpgaEnumerate()\fP\&. 
.PP
Definition in file \fBenum\&.h\fP\&.
.SH "Function Documentation"
.PP 
.SS "\fBfpga_result\fP fpgaEnumerate (const \fBfpga_properties\fP * filters, uint32_t num_filters, \fBfpga_token\fP * tokens, uint32_t max_tokens, uint32_t * num_matches)"
Enumerate FPGA resources present in the system
.PP
This call allows the user to query the system for FPGA resources that match a certain set of criteria, e\&.g\&. all accelerators that are assigned to a host interface and available, all FPGAs of a specific type, etc\&.
.PP
\fBfpgaEnumerate()\fP will create a number of \fCfpga_token\fPs to represent the matching resources and populate the array \fCtokens\fP with these tokens\&. The \fCmax_tokens\fP argument can be used to limit the number of tokens allocated/returned by \fBfpgaEnumerate()\fP; i\&.e\&., the number of tokens in the returned \fCtokens\fP array will be either \fCmax_tokens\fP or \fCnum_matches\fP (the number of resources matching the filter), whichever is smaller\&. Use \fBfpgaDestroyToken()\fP to destroy tokens that are no longer needed\&.
.PP
To query the number of matches for a particular set of filters (e\&.g\&. to allocate a \fCtokens\fP array of the appropriate size), call \fBfpgaEnumerate()\fP with the parameter \fCtokens\fP set to NULL; this will only return the number of matches in \fCnum_matches\fP\&.
.PP
\fBNote\fP
.RS 4
\fBfpgaEnumerate()\fP will allocate memory for the created tokens returned in \fCtokens\fP\&. It is the responsibility of the using application to free this memory after use by calling \fBfpgaDestroyToken()\fP for each of the returned tokens\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIfilters\fP Array of \fCfpga_properties\fP objects describing the properties of the objects that should be returned\&. A resource is considered matching if its properties match any one of the supplied filters\&. To match all FPGA resources, pass an empty filters object (one without any filter criteria set) or pass a NULL filters parameter with num_filters set to 0\&. 
.br
\fInum_filters\fP Number of entries in the \fCfilters\fP array, or 0 to match all FPGA resources when \fCfilters\fP is NULL\&. 
.br
\fItokens\fP Pointer to an array of fpga_token variables to be populated\&. If NULL is supplied, \fBfpgaEnumerate()\fP will not create any tokens, but it will return the number of possible matches in \fCnum_match\fP\&. 
.br
\fImax_tokens\fP Maximum number of tokens that \fBfpgaEnumerate()\fP shall return (length of \fCtokens\fP array)\&. There may be more or fewer matches than this number; \fCnum_matches\fP is set to the number of actual matches\&. 
.br
\fInum_matches\fP Number of resources matching the \fCfilter\fP criteria\&. This number can be higher than the number of tokens returned in the \fCtokens\fP array (depending on the value of \fCmax_tokens\fP)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
FPGA_OK on success\&. FPGA_INVALID_PARAM if invalid pointers or objects are passed into the function\&. FPGA_NO_DRIVER if OPAE can't find the respective enumeration data structures usually provided by the driver\&. FPGA_NO_MEMORY if there was not enough memory to create tokens\&. 
.RE
.PP

.PP
Referenced by find_fpga(), fpga_open(), main(), and probe_for_ase()\&.
.SS "\fBfpga_result\fP fpgaCloneToken (\fBfpga_token\fP src, \fBfpga_token\fP * dst)"
Clone a fpga_token object
.PP
Creates a copy of an fpga_token object\&.
.PP
\fBNote\fP
.RS 4
This call creates a new token object and allocates memory for it\&. It is the responsibility of the using application to free this memory after use by calling \fBfpgaDestroyToken()\fP for the cloned token\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIsrc\fP fpga_token object to copy 
.br
\fIdst\fP New fpga_token object cloned from 'src' 
.RE
.PP
\fBReturns\fP
.RS 4
FPGA_OK on success 
.RE
.PP

.SS "\fBfpga_result\fP fpgaDestroyToken (\fBfpga_token\fP * token)"
Destroy a Token
.PP
This function destroys a token created by \fBfpgaEnumerate()\fP and frees the associated memory\&.
.PP
\fBNote\fP
.RS 4
\fBfpgaDestroyToken()\fP requires the address of an fpga_token as previously created by \fBfpgaEnumerate()\fP or \fBfpgaCloneToken()\fP\&. Passing any other value results in undefined behavior\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fItoken\fP fpga_token to destroy 
.RE
.PP
\fBReturns\fP
.RS 4
FPGA_OK on success 
.RE
.PP

.PP
Referenced by fpga_close(), main(), and probe_for_ase()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for OPAE C API from the source code\&.
