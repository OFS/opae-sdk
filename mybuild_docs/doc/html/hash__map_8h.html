<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OPAE C API: include/opae/hash_map.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OPAE C API
   &#160;<span id="projectnumber">-..</span>
   </div>
   <div id="projectbrief">FPGA API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_beaf459716867cfd62f7e910a709c36d.html">opae</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">hash_map.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A general-purpose hybrid array/list hash map implementation.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;<a class="el" href="types__enum_8h_source.html">opae/types_enum.h</a>&gt;</code><br />
</div>
<p><a href="hash__map_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structopae__hash__map__item"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__map_8h.html#structopae__hash__map__item">opae_hash_map_item</a></td></tr>
<tr class="separator:structopae__hash__map__item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopae__hash__map.html">opae_hash_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2f858c6198f438f243a9b886e361fa0c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__map_8h.html#a2f858c6198f438f243a9b886e361fa0c">opae_hash_map_flags</a> { <a class="el" href="hash__map_8h.html#a2f858c6198f438f243a9b886e361fa0ca4089fe07cd9c5d05ea168d2b49beae5d">OPAE_HASH_MAP_UNIQUE_KEYSPACE</a> = (1u &lt;&lt; 0)
 }</td></tr>
<tr class="separator:a2f858c6198f438f243a9b886e361fa0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5d8b6eed0eea3e1e74de38cb04c1d4e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types__enum_8h.html#a27aaa9bd2d94c9b53602b1a7af49fc6d">fpga_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__map_8h.html#a5d8b6eed0eea3e1e74de38cb04c1d4e2">opae_hash_map_init</a> (<a class="el" href="structopae__hash__map.html">opae_hash_map</a> *hm, uint32_t num_buckets, uint32_t hash_seed, int flags, uint32_t(*key_hash)(uint32_t num_buckets, uint32_t hash_seed, void *key), int(*key_compare)(void *keya, void *keyb), void(*key_cleanup)(void *key, void *context), void(*value_cleanup)(void *value, void *context))</td></tr>
<tr class="separator:a5d8b6eed0eea3e1e74de38cb04c1d4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42574e8d296806a5b395fce978a1338"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types__enum_8h.html#a27aaa9bd2d94c9b53602b1a7af49fc6d">fpga_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__map_8h.html#ae42574e8d296806a5b395fce978a1338">opae_hash_map_add</a> (<a class="el" href="structopae__hash__map.html">opae_hash_map</a> *hm, void *key, void *value)</td></tr>
<tr class="separator:ae42574e8d296806a5b395fce978a1338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf46fb910f75709741009e5f6c42b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types__enum_8h.html#a27aaa9bd2d94c9b53602b1a7af49fc6d">fpga_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__map_8h.html#a2cf46fb910f75709741009e5f6c42b16">opae_hash_map_find</a> (<a class="el" href="structopae__hash__map.html">opae_hash_map</a> *hm, void *key, void **value)</td></tr>
<tr class="separator:a2cf46fb910f75709741009e5f6c42b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5750c806056b605248bee90399e64e29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types__enum_8h.html#a27aaa9bd2d94c9b53602b1a7af49fc6d">fpga_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__map_8h.html#a5750c806056b605248bee90399e64e29">opae_hash_map_remove</a> (<a class="el" href="structopae__hash__map.html">opae_hash_map</a> *hm, void *key)</td></tr>
<tr class="separator:a5750c806056b605248bee90399e64e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb709ed616790bfc7fd58d2b3f72b69c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types__enum_8h.html#a27aaa9bd2d94c9b53602b1a7af49fc6d">fpga_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__map_8h.html#adb709ed616790bfc7fd58d2b3f72b69c">opae_hash_map_destroy</a> (<a class="el" href="structopae__hash__map.html">opae_hash_map</a> *hm)</td></tr>
<tr class="separator:adb709ed616790bfc7fd58d2b3f72b69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d05504a7cf422f506626a68a9aca28e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__map_8h.html#a6d05504a7cf422f506626a68a9aca28e">opae_hash_map_is_empty</a> (<a class="el" href="structopae__hash__map.html">opae_hash_map</a> *hm)</td></tr>
<tr class="separator:a6d05504a7cf422f506626a68a9aca28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21604f9336e0cff5cacdfa01d0d56b87"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__map_8h.html#a21604f9336e0cff5cacdfa01d0d56b87">opae_u64_key_hash</a> (uint32_t num_buckets, uint32_t hash_seed, void *key)</td></tr>
<tr class="separator:a21604f9336e0cff5cacdfa01d0d56b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccdf1c3216e0b98093641cd44f93a10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__map_8h.html#abccdf1c3216e0b98093641cd44f93a10">opae_u64_key_compare</a> (void *keya, void *keyb)</td></tr>
<tr class="separator:abccdf1c3216e0b98093641cd44f93a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A general-purpose hybrid array/list hash map implementation. </p>
<p>Presents a generic interface for mapping key objects to value objects. Both keys and values may be arbitrary data structures. The user supplies the means by which the hash of values is generated and by which the keys are compared to each other. </p>

<p class="definition">Definition in file <a class="el" href="hash__map_8h_source.html">hash_map.h</a>.</p>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structopae__hash__map__item" id="structopae__hash__map__item"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structopae__hash__map__item">&#9670;&nbsp;</a></span>opae_hash_map_item</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct opae_hash_map_item</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>List link item.</p>
<p>This structure provides the association between key and value. When the supplied hash function for keys A and B returns the same bucket index, both A and B can co-exist on the same list rooted at the bucket index. </p>

<p class="definition">Definition at line <a class="el" href="hash__map_8h_source.html#l00070">70</a> of file <a class="el" href="hash__map_8h_source.html">hash_map.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a2bc84efb62b050093f82300b050f9476"></a>void *</td>
<td class="fieldname">
key</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a90e4ff6c4d033b0076d462069671f3c5"></a>void *</td>
<td class="fieldname">
value</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a426277c984ea3e44d733ade585aef233"></a>struct _opae_hash_map_item *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2f858c6198f438f243a9b886e361fa0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f858c6198f438f243a9b886e361fa0c">&#9670;&nbsp;</a></span>opae_hash_map_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="hash__map_8h.html#a2f858c6198f438f243a9b886e361fa0c">opae_hash_map_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags used to initialize a hash map.</p>
<p>OPAE_HASH_MAP_UNIQUE_KEYSPACE says that the user provides a guarantee that the key space is truly unique. In other words, when the provided hash function for keys A and B returns the same bucket index, the key comparison function when comparing A and B will never return a result saying that the keys are equal in value. This is helpful in situations where the key space is guaranteed to produce unique values, for example a memory allocator. When the key space is guaranteed to be unique, <a class="el" href="hash__map_8h.html#ae42574e8d296806a5b395fce978a1338">opae_hash_map_add()</a> can implement a small performance improvement. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2f858c6198f438f243a9b886e361fa0ca4089fe07cd9c5d05ea168d2b49beae5d"></a>OPAE_HASH_MAP_UNIQUE_KEYSPACE&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="hash__map_8h_source.html#l00058">58</a> of file <a class="el" href="hash__map_8h_source.html">hash_map.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5d8b6eed0eea3e1e74de38cb04c1d4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8b6eed0eea3e1e74de38cb04c1d4e2">&#9670;&nbsp;</a></span>opae_hash_map_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types__enum_8h.html#a27aaa9bd2d94c9b53602b1a7af49fc6d">fpga_result</a> opae_hash_map_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopae__hash__map.html">opae_hash_map</a> *&#160;</td>
          <td class="paramname"><em>hm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_buckets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hash_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t(*)(uint32_t num_buckets, uint32_t hash_seed, void *key)&#160;</td>
          <td class="paramname"><em>key_hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *keya, void *keyb)&#160;</td>
          <td class="paramname"><em>key_compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *key, void *context)&#160;</td>
          <td class="paramname"><em>key_cleanup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *value, void *context)&#160;</td>
          <td class="paramname"><em>value_cleanup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a hash map</p>
<p>Populates the hash map data structure and allocates the buckets array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">hm</td><td>A pointer to the storage for the hash map object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_buckets</td><td>The desired size of the buckets array. Each array entry may be empty (NULL), or may contain a list of <a class="el" href="hash__map_8h.html#structopae__hash__map__item">opae_hash_map_item</a> structures for which the given key_hash function returned the same key hash value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_seed</td><td>A seed value used during key hash computation. This value will be the hash_seed parameter to the key hash function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Initialization flags. See opae_hash_map_flags. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_hash</td><td>A pointer to a function that produces the hash value, given the number of buckets, the hash seed, and the key. Valid values are between 0 and num_buckets - 1, inclusively. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_compare</td><td>A pointer to a function that compares two keys. The return value is similar to that of strcmp(), where a negative value means that keya &lt; keyb, 0 means that keya == keyb, and a positive values means that keya &gt; keyb. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_cleanup</td><td>A pointer to a function that is called when a key is being removed from the map. This function is optional and may be NULL. When supplied, the function is responsible for freeing any resources allocated when the key was created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_cleanup</td><td>A pointer to a function that is called when a value is being removed from the map. This function is optional and may be NULL. When supplied, the function is responsible for freeing any resources allocated when the value was created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FPGA_OK on success, FPGA_INVALID_PARAM if any of the required parameters are NULL, or FPGA_NO_MEMORY if the bucket array could not be allocated. </dd></dl>

</div>
</div>
<a id="ae42574e8d296806a5b395fce978a1338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42574e8d296806a5b395fce978a1338">&#9670;&nbsp;</a></span>opae_hash_map_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types__enum_8h.html#a27aaa9bd2d94c9b53602b1a7af49fc6d">fpga_result</a> opae_hash_map_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopae__hash__map.html">opae_hash_map</a> *&#160;</td>
          <td class="paramname"><em>hm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map a key to a value</p>
<p>Inserts a mapping from key to value in the given hash map object. Subsequent calls to <a class="el" href="hash__map_8h.html#a2cf46fb910f75709741009e5f6c42b16">opae_hash_map_find()</a> that are given the key will retrieve the value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hm</td><td>A pointer to the storage for the hash map object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The hash map key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The hash map value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FPGA_OK on success, FPGA_INVALID_PARAM if hm is NULL, FPGA_NO_MEMORY if malloc() fails when allocating the list item, or FPGA_INVALID_PARAM if the key hash produced by key_hash is out of bounds. </dd></dl>

</div>
</div>
<a id="a2cf46fb910f75709741009e5f6c42b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf46fb910f75709741009e5f6c42b16">&#9670;&nbsp;</a></span>opae_hash_map_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types__enum_8h.html#a27aaa9bd2d94c9b53602b1a7af49fc6d">fpga_result</a> opae_hash_map_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopae__hash__map.html">opae_hash_map</a> *&#160;</td>
          <td class="paramname"><em>hm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the value for a given key</p>
<p>Given a key that was previously passed to <a class="el" href="hash__map_8h.html#ae42574e8d296806a5b395fce978a1338">opae_hash_map_add()</a>, retrieve its associated value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hm</td><td>A pointer to the storage for the hash map object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The hash map key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>A pointer to receive the hash map value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FPGA_OK on success, FPGA_INVALID_PARAM if hm is NULL or if the key hash produced by key_hash is out of bounds, or FPGA_NOT_FOUND if the given key was not found in the hash map. </dd></dl>

</div>
</div>
<a id="a5750c806056b605248bee90399e64e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5750c806056b605248bee90399e64e29">&#9670;&nbsp;</a></span>opae_hash_map_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types__enum_8h.html#a27aaa9bd2d94c9b53602b1a7af49fc6d">fpga_result</a> opae_hash_map_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopae__hash__map.html">opae_hash_map</a> *&#160;</td>
          <td class="paramname"><em>hm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a key/value association</p>
<p>Given a key that was previously passed to <a class="el" href="hash__map_8h.html#ae42574e8d296806a5b395fce978a1338">opae_hash_map_add()</a>, remove the key and its associated value, calling the cleanup functions as needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hm</td><td>A pointer to the storage for the hash map object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The hash map key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FPGA_OK on success, FPGA_INVALID_PARAM when hm is NULL or when the key hash produced by key_hash is out of bounds, or FPGA_NOT_FOUND if the key is not found in the hash map. </dd></dl>

</div>
</div>
<a id="adb709ed616790bfc7fd58d2b3f72b69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb709ed616790bfc7fd58d2b3f72b69c">&#9670;&nbsp;</a></span>opae_hash_map_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types__enum_8h.html#a27aaa9bd2d94c9b53602b1a7af49fc6d">fpga_result</a> opae_hash_map_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopae__hash__map.html">opae_hash_map</a> *&#160;</td>
          <td class="paramname"><em>hm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tear down a hash map</p>
<p>Given a hash map that was previously initialized by <a class="el" href="hash__map_8h.html#a5d8b6eed0eea3e1e74de38cb04c1d4e2">opae_hash_map_init()</a>, destroy the hash map, releasing all keys, values, and the bucket array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hm</td><td>A pointer to the storage for the hash map object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FPGA_OK on success or FPGA_INVALID_PARAM is hm is NULL. </dd></dl>

</div>
</div>
<a id="a6d05504a7cf422f506626a68a9aca28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d05504a7cf422f506626a68a9aca28e">&#9670;&nbsp;</a></span>opae_hash_map_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool opae_hash_map_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopae__hash__map.html">opae_hash_map</a> *&#160;</td>
          <td class="paramname"><em>hm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine whether a hash map is empty</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hm</td><td>A pointer to the storage for the hash map object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there are no key/value mappings present, false otherwise. </dd></dl>

</div>
</div>
<a id="a21604f9336e0cff5cacdfa01d0d56b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21604f9336e0cff5cacdfa01d0d56b87">&#9670;&nbsp;</a></span>opae_u64_key_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t opae_u64_key_hash </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_buckets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hash_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience hash function for arbitrary pointers/64-bit values.</p>
<p>Simply converts the key to a uint64_t and then performs the modulus operation with the configured num_buckets. hash_seed is unused. </p>

</div>
</div>
<a id="abccdf1c3216e0b98093641cd44f93a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abccdf1c3216e0b98093641cd44f93a10">&#9670;&nbsp;</a></span>opae_u64_key_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opae_u64_key_compare </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>keya</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>keyb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience key comparison function for 64-bit values.</p>
<p>Simply converts the key pointers to uint64_t's and performs unsigned integer comparison. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
