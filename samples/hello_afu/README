A simple AFU template that demonstrates the primary CCI-P interface.  The
RTL satisfies the bare miminum requirements of an AFU, responding to MMIO
reads to return the device feature header and the AFU's UUID.

Of note in this example:

- RTL sources are specified in hw/rtl/filelist.txt.  In addition to
  SystemVerilog, the AFU's JSON file is also declared there.  The AFU JSON
  describes the interfaces required by the AFU.  It also holds a UUID to
  identify the AFU when it is loaded on an FPGA.

- The AFU declares that it expects the ccip_std_afu top-level interface by
  setting "afu-top-interface" to "ccip_std_afu" in hw/rtl/hello_afu.json.
  This is the base CCI-P interface with clocks, reset and CCI-P Rx/Tx
  structures.  Other interface options will be described in subsequent
  examples.

- The AFU UUID is declared exactly once in the sources: in the JSON file.
  The RTL loads the UUID from afu_json_info.vh, which is generated
  automatically by the scripts below.  The software loads the UUID from
  afu_json_info.h, which is generated by sw/Makefile.

- The software demonstrates the minimum necessary to attach to an FPGA
  using OPAE.  The RTL demonstrates the minimum necessary to satisfy the
  OPAE driver and the hello_afu software.


Simulation with ASE:

  Follow the steps in ../README for configuring your environment.  In
  particular, ensure that the OPAE SDK is properly installed.  OPAE SDK
  scripts must be on PATH and include files and libraries must be available
  to the C compiler.  In addition, ensure that the OPAE_PLATFORM_ROOT
  environment variable is set.

  A set of scripts is provided for running all the sample workloads.
  In this case, however, we will not use them.  Instead, we will introduce
  the underlying OPAE SDK scripts that they invoke.  AFU designers are free
  to incorporate either option into their workflows.

  Simulation requires two software processes: one for RTL simulation and
  the other to run the connected software.  To construct an RTL simulation
  environment execute the following in the directory containing this
  README:

    $ afu_sim_setup --source hw/rtl/filelist.txt build_sim

  This will construct an ASE environment in the build_sim subdirectory.  If
  the command fails, confirm that afu_sim_setup is on your PATH (in the
  OPAE SDK bin directory), that your Python version is at least 2.7 and
  that the jsonschema Python package is installed
  (https://pypi.python.org/pypi/jsonschema).

  To build and execute the simulator:

    $ cd build_sim
    $ make
    $ make sim

  This will build and run the RTL simulator.  If this step fails it is
  likely that your RTL simulator is not installed properly.  ModelSim,
  Questa and VCS are supported.

  The simulator prints a message that it is ready for simulation.  It also
  prints a message to set the ASE_WORKDIR environment variable.  Open
  another shell and cd to the directory holding this README.  To build and
  run the software:

    $ <Set ASE_WORKDIR as directed by the simulator>
    $ cd sw
    $ make clean
    $ make USE_ASE=1
    $ ./hello_afu

  The software and simulator should both run quickly, log transactions and
  exit.  If the software prints "Error enumerating AFCs", you forgot to set
  USE_ASE=1 on the make command line and the software is searching for an
  actual FPGA.  Do "make clean" in the sw directory and repeat the steps
  above.


Synthesis with Quartus:

  RTL simulation and synthesis are driven by the same filelist.txt and
  underlying OPAE scripts.  To construct a Quartus synthesis environment
  for this AFU, enter:

    $ afu_synth_setup --source hw/rtl/filelist.txt build_synth
    $ cd build_synth
    $ ${OPAE_PLATFORM_ROOT}/bin/run.sh

  run.sh will invoke Quartus, which must be properly installed.  The end
  result will be a file named hello_afu.gbs in the build_synth directory.
  This GBS file may be loaded onto a compatible FPGA using OPAE's fpgaconf
  tool.

  To run the software connected to an FPGA, compile it as above but do not
  specify "USE_ASE=1".
