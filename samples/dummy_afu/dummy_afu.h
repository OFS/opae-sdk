#pragma once
// THIS IS AUTOGENERATED CODE
// DO NOT MODIFY
#include <poll.h>
#include <unistd.h>
#include <map>
#include <memory>
#include <random>
#include <stdexcept>
#include <opae/cxx/core/events.h>
#include <opae/cxx/core/handle.h>
#include <opae/cxx/core/shared_buffer.h>

namespace fpga = opae::fpga::types;

namespace dummy_afu {

enum {
  AFU_DFH = 0x0000,
  AFU_ID_L = 0x0008,
  AFU_ID_H = 0x0010,
  NEXT_AFU = 0x0018,
  AFU_DFH_RSVD = 0x0020,
  SCRATCHPAD = 0x0028,
  MMIO_TEST_SCRATCHPAD = 0x1000,
  MEM_TEST_CTRL = 0x2040,
  MEM_TEST_STAT = 0x2048,
  MEM_TEST_SRC_ADDR = 0x2050,
  MEM_TEST_DST_ADDR = 0x2058,
  DDR_TEST_CTRL = 0x3000,
  DDR_TEST_STAT = 0x3008,
  DDR_TEST_BANK0_STAT = 0x3010,
  DDR_TEST_BANK1_STAT = 0x3018,
  DDR_TEST_BANK2_STAT = 0x3020,
  DDR_TEST_BANK3_STAT = 0x3028,
};


union afu_dfh  {
  enum {
    offset = AFU_DFH
  };

  afu_dfh(uint64_t v) : value(v) {}
  uint64_t value;
  struct {
    uint64_t FeatureType : 4;
    uint64_t Reserved41 : 19;
    uint64_t EOL : 1;
    uint64_t NextDfhByteOffset : 24;
    uint64_t FeatureRev : 4;
    uint64_t FeatureID : 12;
  };
};

union mem_test_ctrl  {
  enum {
    offset = MEM_TEST_CTRL
  };

  mem_test_ctrl(uint64_t v) : value(v) {}
  uint64_t value;
  struct {
    uint64_t Reserved1 : 63;
    uint64_t StartTest : 1;
  };
};

union ddr_test_ctrl  {
  enum {
    offset = DDR_TEST_CTRL
  };

  ddr_test_ctrl(uint64_t v) : value(v) {}
  uint64_t value;
  struct {
    uint64_t Reserved4 : 60;
    uint64_t DDRBank3StartTest : 1;
    uint64_t DDRBank2StartTest : 1;
    uint64_t DDRBank1StartTest : 1;
    uint64_t DDRBank0StartTest : 1;
  };
};

union ddr_test_stat  {
  enum {
    offset = DDR_TEST_STAT
  };

  ddr_test_stat(uint64_t v) : value(v) {}
  uint64_t value;
  struct {
    uint64_t Reserved8 : 56;
    uint64_t NumDDRBank : 8;
  };
};

union ddr_test_bank0_stat  {
  enum {
    offset = DDR_TEST_BANK0_STAT
  };

  ddr_test_bank0_stat(uint64_t v) : value(v) {}
  uint64_t value;
  struct {
    uint64_t Reserved4 : 57;
    uint64_t TrafficGenFSMState : 4;
    uint64_t TrafficGenTestTimeout : 1;
    uint64_t TrafficGenTestFail : 1;
    uint64_t TrafficGenTestPass : 1;
  };
};

union ddr_test_bank1_stat  {
  enum {
    offset = DDR_TEST_BANK1_STAT
  };

  ddr_test_bank1_stat(uint64_t v) : value(v) {}
  uint64_t value;
  struct {
    uint64_t Reserved4 : 57;
    uint64_t TrafficGenFSMState : 4;
    uint64_t TrafficGenTestTimeout : 1;
    uint64_t TrafficGenTestFail : 1;
    uint64_t TrafficGenTestPass : 1;
  };
};

union ddr_test_bank2_stat  {
  enum {
    offset = DDR_TEST_BANK2_STAT
  };

  ddr_test_bank2_stat(uint64_t v) : value(v) {}
  uint64_t value;
  struct {
    uint64_t Reserved4 : 57;
    uint64_t TrafficGenFSMState : 4;
    uint64_t TrafficGenTestTimeout : 1;
    uint64_t TrafficGenTestFail : 1;
    uint64_t TrafficGenTestPass : 1;
  };
};

union ddr_test_bank3_stat  {
  enum {
    offset = DDR_TEST_BANK3_STAT
  };

  ddr_test_bank3_stat(uint64_t v) : value(v) {}
  uint64_t value;
  struct {
    uint64_t Reserved4 : 57;
    uint64_t TrafficGenFSMState : 4;
    uint64_t TrafficGenTestTimeout : 1;
    uint64_t TrafficGenTestFail : 1;
    uint64_t TrafficGenTestPass : 1;
  };
};

class dummy_afu {
public:
  dummy_afu(fpga::handle::ptr_t feature)
    : max_(0x3028),
      feature_(feature){
    limits_[0x1000] = 0x11ff;
  }
  ~dummy_afu(){}

  uint64_t read64(uint32_t offset) {
    return feature_->read_csr64(offset);
  }

  void write64(uint32_t offset, uint64_t value) {
    return feature_->write_csr64(offset, value);
  }

  uint64_t read64(uint32_t offset, uint32_t i) {
    return read64(get_offset(offset, i));
  }

  void write64(uint32_t offset, uint32_t i, uint64_t value) {
    write64(get_offset(offset, i), value);
  }

  fpga::shared_buffer::ptr_t allocate(size_t size)
  {
    return fpga::shared_buffer::allocate(feature_, size);
  }

  void fill(fpga::shared_buffer::ptr_t buffer)
  {
    std::random_device rd;
    std::mt19937 mt(rd());
    std::uniform_int_distribution<uint32_t> dist(1, 4096);
    auto sz = sizeof(uint32_t);
    for (uint32_t i = 0; i < buffer->size()/sz; i+=sz){
      buffer->write<uint32_t>(dist(mt), i);
    }

  }

  void fill(fpga::shared_buffer::ptr_t buffer, uint32_t value)
  {
    buffer->fill(value);
  }

  fpga::event::ptr_t register_interrupt()
  {
    auto event = fpga::event::register_event(feature_, FPGA_EVENT_INTERRUPT);
    return event;
  }

  void interrupt_wait(fpga::event::ptr_t event, int timeout=-1)
  {
    struct pollfd pfd;
    pfd.events = POLLIN;
    pfd.fd = event->os_object();
    auto ret = poll(&pfd, 1, timeout);
    int count = 0;

    if (ret < 0)
      throw std::runtime_error(strerror(errno));
    if (ret == 0)
      throw std::runtime_error("timeout error");
    std::cout << "got ineterrupt\n";

    if (read(pfd.fd, &count, sizeof(count)))
      throw std::runtime_error("error reading from poll fd");
  }

  void compare(fpga::shared_buffer::ptr_t b1,
               fpga::shared_buffer::ptr_t b2, uint32_t count = 0)
  {
      if (b1->compare(b2, count ? count : b1->size())) {
        throw std::runtime_error("buffers mismatch");
      }

  }

  template<class T>
  T read_register()
  {
    return *reinterpret_cast<T*>(feature_->mmio_ptr(T::offset));
  }

  template<class T>
  volatile T* register_ptr()
  {
    return reinterpret_cast<volatile T*>(feature_->mmio_ptr(T::offset));
  }

  template<class T>
  void write_register(T reg)
  {
    return *reinterpret_cast<T*>(feature_->mmio_ptr(T::offset)) = reg;
  }

private:
  uint32_t max_;
  fpga::handle::ptr_t feature_;
  std::map<uint32_t, uint32_t> limits_;
  uint32_t get_offset(uint32_t base, uint32_t i) {
    auto limit = limits_.find(base);
    auto offset = base + sizeof(uint64_t)*i;
    if (limit != limits_.end() &&
        offset > limit->second - sizeof(uint64_t)) {
      throw std::out_of_range("offset out range in csr space");
    }
    return offset;
  }

};

} // end of namespace dummy_afu