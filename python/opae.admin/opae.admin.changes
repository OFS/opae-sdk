diff --git a/python/opae.admin/opae/admin/sysfs.py b/python/opae.admin/opae/admin/sysfs.py
index e732cc7..e65542a 100644
--- a/python/opae.admin/opae/admin/sysfs.py
+++ b/python/opae.admin/opae/admin/sysfs.py
@@ -29,6 +29,7 @@ import glob
 import os
 import re
 from contextlib import contextmanager
+from pathlib import Path
 from subprocess import CalledProcessError
 from opae.admin.path import sysfs_path
 from opae.admin.utils.process import call_process, DRY_RUN
@@ -269,7 +270,9 @@ class pci_node(sysfs_node):
             This function is recursively called with any children found in
             this node, incrementing the level every recursive call.
         """
-        text = '{}{}\n'.format(' ' * level*4, self)
+        driver = self.find_one('driver')
+        driver_name = Path(driver.sysfs_path).resolve().stem if driver else 'no driver'
+        text = '{}{} ({})\n'.format(' ' * level*4, self, driver_name)
         for n in self.children:
             text += n.tree(level+1)
         return text
diff --git a/python/opae.admin/opae/admin/tools/pci_driver.py b/python/opae.admin/opae/admin/tools/pci_driver.py
index 1deb1b7..88d0f20 100644
--- a/python/opae.admin/opae/admin/tools/pci_driver.py
+++ b/python/opae.admin/opae/admin/tools/pci_driver.py
@@ -25,8 +25,9 @@
 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
 # POSSIBILITY OF SUCH DAMAGE.
 import re
+import sys
 from argparse import ArgumentParser
-from opae.admin.sysfs import pcie_device
+from opae.admin.sysfs import pcie_device, pci_node
 
 
 PCI_ADDRESS_PATTERN = (r'^(?P<pci_address>'
@@ -45,40 +46,62 @@ def pci_address(inp):
     return '{}:{}'.format(d.get('segment') or '0000', d['bdf'])
 
 
-def bind(device):
-    print(f'bind: {device}')
 
+class pci_op(object):
+    def __init__(self, op):
+        if op not in dir(pci_node):
+            raise KeyError(f'{op} is not a valid operation')
+        self.op = op
 
-def unbind(device):
-    print(f'unbind: {device}')
+    def __call__(self, pci_device, args):
+        if not args.other_endpoints:
+           getattr(pci_device.pci_node, self.op)()
+        else:
+            for p in pci_device.pci_node.root.endpoints:
+                if p.pci_address != args.device:
+                    getattr(p, self.op)()
 
 
-def peer_devices(device):
-    print(f'peer_devices: {device}')
+def rescan(pci_device, args):
+        pci_device.pci_node.pci_bus.node('rescan').value = 1
+
+
+def topology(pci_device, args):
+    for line in pci_device.pci_node.root.tree().split('\n'):
+        if pci_device.pci_node.pci_address in line:
+            line = '\033[92m{}\033[00m' .format(line)
+        elif '(pcieport)' not in line:
+            line = '\033[96m{}\033[00m' .format(line)
+            
+        print(line)
 
 
 def main():
+    actions = {'unbind': pci_op('unbind'),
+               'rescan': rescan,
+               'remove': pci_op('remove'),
+               'topology': topology}
+
     parser = ArgumentParser()
     parser.add_argument('device', type=pci_address,
                         help=('pcie address of device '
                               '([segment:]bus:device.function)'))
-    parser.add_argument('action', choices=['bind', 'unbind'],
+    parser.add_argument('action', choices=sorted(actions.keys()),
                         help='action to perform on device')
-    parser.add_argument('--peers', action='store_true', default=False,
+    parser.add_argument('-E', '--other-endpoints', action='store_true', default=False,
                         help='perform action on peer pcie devices')
     args = parser.parse_args()
-    actions = {'bind': bind,
-               'unbind': unbind}
 
-    pci_device = pcie_device.enum({'pci_address': args.device})
-    if not pci_device:
+    pci_devices = pcie_device.enum([{'pci_node.pci_address': args.device}])
+    if not pci_devices:
         raise SystemExit(f'{args.device} not found')
 
-    if not args.peers:
-        actions[args.action](args.device)
-    else:
-        for p in peer_devices(args.device):
-            actions[args.action](p)
+    if len(pci_devices) > 1:
+        raise SystemExit(f'more than one device found for: {args.device}')
+
+    pci_device = pci_devices[0]
+
+    actions[args.action](pci_device, args)
 
 
 if __name__ == '__main__':
