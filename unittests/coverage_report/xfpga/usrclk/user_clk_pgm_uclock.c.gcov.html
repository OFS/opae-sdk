<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info.cleaned - xfpga/usrclk/user_clk_pgm_uclock.c</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">xfpga/usrclk</a> - user_clk_pgm_uclock.c<span style="font-size: 80%;"> (source / <a href="user_clk_pgm_uclock.c.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info.cleaned</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">202</td>
            <td class="headerCovTableEntry">403</td>
            <td class="headerCovTableEntryLo">50.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-20</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">13</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntryMed">81.2 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Copyright(c) 2017, Intel Corporation</a>
<span class="lineNum">       2 </span>            : //
<span class="lineNum">       3 </span>            : // Redistribution  and  use  in source  and  binary  forms,  with  or  without
<span class="lineNum">       4 </span>            : // modification, are permitted provided that the following conditions are met:
<span class="lineNum">       5 </span>            : //
<span class="lineNum">       6 </span>            : // * Redistributions of  source code  must retain the  above copyright notice,
<span class="lineNum">       7 </span>            : //   this list of conditions and the following disclaimer.
<span class="lineNum">       8 </span>            : // * Redistributions in binary form must reproduce the above copyright notice,
<span class="lineNum">       9 </span>            : //   this list of conditions and the following disclaimer in the documentation
<span class="lineNum">      10 </span>            : //   and/or other materials provided with the distribution.
<span class="lineNum">      11 </span>            : // * Neither the name  of Intel Corporation  nor the names of its contributors
<span class="lineNum">      12 </span>            : //   may be used to  endorse or promote  products derived  from this  software
<span class="lineNum">      13 </span>            : //   without specific prior written permission.
<span class="lineNum">      14 </span>            : //
<span class="lineNum">      15 </span>            : // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
<span class="lineNum">      16 </span>            : // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
<span class="lineNum">      17 </span>            : // IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
<span class="lineNum">      18 </span>            : // ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
<span class="lineNum">      19 </span>            : // LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
<span class="lineNum">      20 </span>            : // CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
<span class="lineNum">      21 </span>            : // SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
<span class="lineNum">      22 </span>            : // INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
<span class="lineNum">      23 </span>            : // CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
<span class="lineNum">      24 </span>            : // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
<span class="lineNum">      25 </span>            : // POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      26 </span>            : //****************************************************************************
<span class="lineNum">      27 </span>            : // Arthur.Sheiman@Intel.com   Created: 09-08-16
<span class="lineNum">      28 </span>            : // Revision: 10-18-16  18:06
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #ifdef HAVE_CONFIG_H
<span class="lineNum">      31 </span>            : #include &lt;config.h&gt;
<span class="lineNum">      32 </span>            : #endif // HAVE_CONFIG_H
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : #include &lt;errno.h&gt;
<span class="lineNum">      35 </span>            : #include &lt;malloc.h&gt; /* malloc */
<span class="lineNum">      36 </span>            : #include &lt;stdlib.h&gt; /* exit */
<span class="lineNum">      37 </span>            : #include &lt;stdio.h&gt;  /* printf */
<span class="lineNum">      38 </span>            : #include &lt;string.h&gt; /* memcpy */
<span class="lineNum">      39 </span>            : #include &lt;unistd.h&gt; /* getpid */
<span class="lineNum">      40 </span>            : #include &lt;stdint.h&gt;
<span class="lineNum">      41 </span>            : #include &lt;ctype.h&gt;
<span class="lineNum">      42 </span>            : #include &lt;sys/stat.h&gt;
<span class="lineNum">      43 </span>            : #include &lt;fcntl.h&gt;
<span class="lineNum">      44 </span>            : #include &lt;stdarg.h&gt;
<span class="lineNum">      45 </span>            : #include &lt;time.h&gt;
<span class="lineNum">      46 </span>            : #include &lt;glob.h&gt;
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : #include &quot;safe_string/safe_string.h&quot;
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : #include &quot;user_clk_pgm_uclock.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;user_clk_pgm_uclock_freq_template.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;user_clk_pgm_uclock_freq_template_322.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;user_clk_pgm_uclock_eror_messages.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;user_clk_s10_freq.h&quot;
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : // user clock sysfs
<span class="lineNum">      58 </span>            : #define USER_CLOCK_CMD0 &quot;userclk_freqcmd&quot;
<span class="lineNum">      59 </span>            : #define USER_CLOCK_CMD1 &quot;userclk_freqcntrcmd&quot;
<span class="lineNum">      60 </span>            : #define USER_CLOCK_STS0 &quot;userclk_freqsts&quot;
<span class="lineNum">      61 </span>            : #define USER_CLOCK_STS1 &quot;userclk_freqcntrsts&quot;
<span class="lineNum">      62 </span>            : #define IOPLL_CLOCK_FREQ &quot;intel-pac-iopll.*.auto/userclk/frequency&quot;
<span class="lineNum">      63 </span>            : #define IOPLL_MAX_FREQ 800
<span class="lineNum">      64 </span>            : #define IOPLL_MIN_FREQ 1
<span class="lineNum">      65 </span>            : #define MAX_FPGA_FREQ 1200
<span class="lineNum">      66 </span>            : #define MIN_FPGA_FREQ 25
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            : // User clock sleep
<span class="lineNum">      69 </span>            : #define USRCLK_SLEEEP_1MS 1000000
<span class="lineNum">      70 </span>            : #define USRCLK_SLEEEP_10MS 10000000
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : struct QUCPU_Uclock gQUCPU_Uclock;
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : STATIC int using_iopll(char *sysfs_usrpath, const char *sysfs_path);
<a name="75"><span class="lineNum">      75 </span>            : </a>
<span class="lineNum">      76 </span>            : // Get fpga user clock
<span class="lineNum">      77 </span><span class="lineNoCov">          0 : fpga_result __FIXME_MAKE_VISIBLE__ get_userclock(const char *sysfs_path,</span>
<span class="lineNum">      78 </span>            :                                                  uint64_t *userclk_high,
<span class="lineNum">      79 </span>            :                                                  uint64_t *userclk_low)
<span class="lineNum">      80 </span>            : {
<span class="lineNum">      81 </span>            :         char sysfs_usrpath[SYSFS_PATH_MAX];
<span class="lineNum">      82 </span>            :         QUCPU_tFreqs userClock;
<span class="lineNum">      83 </span>            :         fpga_result result;
<span class="lineNum">      84 </span>            :         uint32_t high, low;
<span class="lineNum">      85 </span>            :         int ret;
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :         if ((sysfs_path == NULL) || (userclk_high == NULL)</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :             || (userclk_low == NULL)) {</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :                 FPGA_ERR(&quot;Invalid input parameters&quot;);</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :                 return FPGA_INVALID_PARAM;</span>
<span class="lineNum">      91 </span>            :         }
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            :         // Test for the existence of the userclk_frequency file
<span class="lineNum">      94 </span>            :         // which indicates an S10 driver
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :         ret = using_iopll(sysfs_usrpath, sysfs_path);</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :         if (ret == FPGA_OK) {</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :                 result = sysfs_read_u32_pair(sysfs_usrpath, &amp;low, &amp;high, ' ');</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :                 if (FPGA_OK != result)</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :                         return result;</span>
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :                 *userclk_high = high * 1000; // Adjust to Hz</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :                 *userclk_low = low * 1000;</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :                 return FPGA_OK;</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :         } else if (ret == FPGA_NO_ACCESS) {</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">     106 </span>            :         }
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            :         // Initialize
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :         if (fi_RunInitz(sysfs_path) != 0) {</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :                 FPGA_ERR(&quot;Failed to initialize user clock &quot;);</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :                 return FPGA_NOT_SUPPORTED;</span>
<span class="lineNum">     112 </span>            :         }
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            :         // get user clock
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :         if (fi_GetFreqs(&amp;userClock) != 0) {</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :                 FPGA_ERR(&quot;Failed to get user clock Frequency &quot;);</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :                 return FPGA_NOT_SUPPORTED;</span>
<span class="lineNum">     118 </span>            :         }
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :         *userclk_high = userClock.u64i_Frq_ClkUsr;</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :         *userclk_low = userClock.u64i_Frq_DivBy2;</span>
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :         return FPGA_OK;</span>
<span class="lineNum">     124 </span>            : }
<a name="125"><span class="lineNum">     125 </span>            : </a>
<span class="lineNum">     126 </span>            : // set fpga user clock
<span class="lineNum">     127 </span><span class="lineCov">          3 : fpga_result __FIXME_MAKE_VISIBLE__ set_userclock(const char *sysfs_path,</span>
<span class="lineNum">     128 </span>            :                                                  uint64_t userclk_high,
<span class="lineNum">     129 </span>            :                                                  uint64_t userclk_low)
<span class="lineNum">     130 </span>            : {
<span class="lineNum">     131 </span>            :         char sysfs_usrpath[SYSFS_PATH_MAX];
<span class="lineNum">     132 </span><span class="lineCov">          3 :         uint64_t freq = userclk_high;</span>
<span class="lineNum">     133 </span><span class="lineCov">          3 :         uint64_t refClk = 0;</span>
<span class="lineNum">     134 </span>            :         int fd, res;
<span class="lineNum">     135 </span>            :         char *bufp;
<span class="lineNum">     136 </span>            :         size_t cnt;
<span class="lineNum">     137 </span>            :         int ret;
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span><span class="lineCov">          3 :         if (sysfs_path == NULL) {</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :                 FPGA_ERR(&quot;Invalid Input parameters&quot;);</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :                 return FPGA_INVALID_PARAM;</span>
<span class="lineNum">     142 </span>            :         }
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span><span class="lineCov">          3 :         ret = using_iopll(sysfs_usrpath, sysfs_path);</span>
<span class="lineNum">     145 </span><span class="lineCov">          3 :         if (ret == FPGA_OK) {</span>
<span class="lineNum">     146 </span>            :                 // Enforce 1x clock within valid range
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :                 if ((userclk_low &gt; IOPLL_MAX_FREQ)</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :                     || (userclk_low &lt; IOPLL_MIN_FREQ)) {</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :                         FPGA_ERR(&quot;Invalid Input frequency&quot;);</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :                         return FPGA_INVALID_PARAM;</span>
<span class="lineNum">     151 </span>            :                 }
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :                 fd = open(sysfs_usrpath, O_WRONLY);</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :                 if (fd &lt; 0) {</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :                         FPGA_MSG(&quot;open(%s) failed: %s&quot;, sysfs_usrpath,</span>
<span class="lineNum">     156 </span>            :                                  strerror(errno));
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :                         return FPGA_NOT_FOUND;</span>
<span class="lineNum">     158 </span>            :                 }
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :                 bufp = (char *)&amp;pll_freq_config[userclk_low];</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :                 cnt = sizeof(struct pll_config);</span>
<span class="lineNum">     161 </span>            :                 do {
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :                         res = write(fd, bufp, cnt);</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :                         if (res &lt; 0) {</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :                                 FPGA_ERR(&quot;Failed to write&quot;);</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">     166 </span>            :                         }
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :                         bufp += res;</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :                         cnt -= res;</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :                 } while (cnt &gt; 0);</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :                 close(fd);</span>
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :                 return FPGA_OK;</span>
<span class="lineNum">     173 </span><span class="lineCov">          3 :         } else if (ret == FPGA_NO_ACCESS) {</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">     175 </span>            :         }
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            :         // verify user clock freq range (100hz to 1200hz)
<span class="lineNum">     178 </span><span class="lineCov">          3 :         if ((userclk_high &gt; MAX_FPGA_FREQ) || (userclk_low &gt; MAX_FPGA_FREQ)) {</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :                 FPGA_ERR(&quot;Invalid Input frequency&quot;);</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :                 return FPGA_INVALID_PARAM;</span>
<span class="lineNum">     181 </span>            :         }
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span><span class="lineCov">          3 :         if (userclk_low != 0 &amp;&amp; userclk_high != 0</span>
<span class="lineNum">     184 </span><span class="lineCov">          1 :             &amp;&amp; userclk_low &gt; userclk_high) {</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :                 FPGA_ERR(&quot;Invalid Input low frequency&quot;);</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :                 return FPGA_INVALID_PARAM;</span>
<span class="lineNum">     187 </span>            :         }
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            :         // set low refclk if only one clock is avalible
<span class="lineNum">     190 </span><span class="lineCov">          3 :         if (userclk_high == 0 &amp;&amp; userclk_low != 0) {</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :                 freq = userclk_low;</span>
<span class="lineNum">     192 </span>            :         }
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span><span class="lineCov">          3 :         if (freq &lt; MIN_FPGA_FREQ) {</span>
<span class="lineNum">     195 </span><span class="lineCov">          1 :                 FPGA_ERR(&quot;Invalid Input frequency&quot;);</span>
<span class="lineNum">     196 </span><span class="lineCov">          1 :                 return FPGA_INVALID_PARAM;</span>
<span class="lineNum">     197 </span>            :         }
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            :         // Initialize
<span class="lineNum">     200 </span><span class="lineCov">          2 :         if (fi_RunInitz(sysfs_path) != 0) {</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :                 FPGA_ERR(&quot;Failed to initialize user clock &quot;);</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :                 return FPGA_NOT_SUPPORTED;</span>
<span class="lineNum">     203 </span>            :         }
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span><span class="lineCov">          2 :         if ((gQUCPU_Uclock.tInitz_InitialParams.u64i_Version</span>
<span class="lineNum">     206 </span>            :              == QUCPU_UI64_STS_1_VER_version_legacy)
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :             &amp;&amp; (gQUCPU_Uclock.tInitz_InitialParams.u64i_PLL_ID</span>
<span class="lineNum">     208 </span>            :                 == QUCPU_UI64_AVMM_FPLL_IPI_200_IDI_RF322M)) { // Use the
<span class="lineNum">     209 </span>            :                                                                // 322.265625 MHz
<span class="lineNum">     210 </span>            :                                                                // REFCLK
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :                 refClk = 1;</span>
<span class="lineNum">     212 </span>            :         }
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            :         FPGA_DBG(&quot;User clock: %ld \n&quot;, freq);
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            :         // set user clock
<span class="lineNum">     217 </span><span class="lineCov">          2 :         if (fi_SetFreqs(refClk, freq) != 0) {</span>
<span class="lineNum">     218 </span><span class="lineCov">          2 :                 FPGA_ERR(&quot;Failed to set user clock frequency &quot;);</span>
<span class="lineNum">     219 </span><span class="lineCov">          2 :                 return FPGA_NOT_SUPPORTED;</span>
<span class="lineNum">     220 </span>            :         }
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :         return FPGA_OK;</span>
<span class="lineNum">     223 </span>            : }
<a name="224"><span class="lineNum">     224 </span>            : </a>
<span class="lineNum">     225 </span>            : // fi_RunInitz
<span class="lineNum">     226 </span><span class="lineCov">          2 : int fi_RunInitz(const char *sysfs_path)</span>
<span class="lineNum">     227 </span>            : {
<span class="lineNum">     228 </span>            :         // fi_RunInitz
<span class="lineNum">     229 </span>            :         // Initialize
<span class="lineNum">     230 </span>            :         // Reinitialization okay too, since will issue machine reset
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :         uint64_t u64i_PrtData;
<span class="lineNum">     233 </span>            :         uint64_t u64i_AvmmAdr, u64i_AvmmDat;
<span class="lineNum">     234 </span>            :         int i_ReturnErr;
<span class="lineNum">     235 </span>            :         char syfs_usrpath[SYSFS_PATH_MAX];
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span><span class="lineCov">          2 :         gQUCPU_Uclock.i_InitzState = 0;</span>
<span class="lineNum">     238 </span><span class="lineCov">          2 :         gQUCPU_Uclock.tInitz_InitialParams.u64i_Version = (uint64_t)0;</span>
<span class="lineNum">     239 </span><span class="lineCov">          2 :         gQUCPU_Uclock.tInitz_InitialParams.u64i_PLL_ID = (uint64_t)0;</span>
<span class="lineNum">     240 </span><span class="lineCov">          2 :         gQUCPU_Uclock.tInitz_InitialParams.u64i_NumFrq_Intg_End = (uint64_t)0;</span>
<span class="lineNum">     241 </span><span class="lineCov">          2 :         gQUCPU_Uclock.tInitz_InitialParams.u64i_NumFrq_Frac_Beg = (uint64_t)0;</span>
<span class="lineNum">     242 </span><span class="lineCov">          2 :         gQUCPU_Uclock.tInitz_InitialParams.u64i_NumFrq_Frac_End = (uint64_t)0;</span>
<span class="lineNum">     243 </span><span class="lineCov">          2 :         gQUCPU_Uclock.tInitz_InitialParams.u64i_NumFrq = (uint64_t)0;</span>
<span class="lineNum">     244 </span><span class="lineCov">          2 :         gQUCPU_Uclock.tInitz_InitialParams.u64i_NumReg = (uint64_t)0;</span>
<span class="lineNum">     245 </span><span class="lineCov">          2 :         gQUCPU_Uclock.tInitz_InitialParams.u64i_NumRck = (uint64_t)0;</span>
<span class="lineNum">     246 </span><span class="lineCov">          2 :         gQUCPU_Uclock.u64i_cmd_reg_0 = (uint64_t)0x0LLU;</span>
<span class="lineNum">     247 </span><span class="lineCov">          2 :         gQUCPU_Uclock.u64i_cmd_reg_1 = (uint64_t)0x0LLU;</span>
<span class="lineNum">     248 </span><span class="lineCov">          2 :         gQUCPU_Uclock.u64i_AVMM_seq = (uint64_t)0x0LLU;</span>
<span class="lineNum">     249 </span><span class="lineCov">          2 :         gQUCPU_Uclock.i_Bug_First = 0;</span>
<span class="lineNum">     250 </span><span class="lineCov">          2 :         gQUCPU_Uclock.i_Bug_Last = 0;</span>
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span><span class="lineCov">          2 :         if (sysfs_path == NULL) {</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :                 printf(&quot; Invalid input sysfs path \n&quot;);</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">     256 </span>            :         }
<span class="lineNum">     257 </span><span class="lineCov">          2 :         snprintf_s_s(gQUCPU_Uclock.sysfs_path, sizeof(gQUCPU_Uclock.sysfs_path),</span>
<span class="lineNum">     258 </span>            :                      &quot;%s&quot;, sysfs_path);
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            :         // Assume return error okay, for now
<span class="lineNum">     261 </span><span class="lineCov">          2 :         i_ReturnErr = 0;</span>
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            :         // Initialize default values (for error abort)
<span class="lineNum">     264 </span><span class="lineCov">          2 :         gQUCPU_Uclock.tInitz_InitialParams.u64i_Version = 0;</span>
<span class="lineNum">     265 </span><span class="lineCov">          2 :         gQUCPU_Uclock.tInitz_InitialParams.u64i_PLL_ID = 0;</span>
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            :         // Initialize command shadow registers
<span class="lineNum">     268 </span><span class="lineCov">          2 :         gQUCPU_Uclock.u64i_cmd_reg_0 = ((uint64_t)0x0LLU);</span>
<span class="lineNum">     269 </span><span class="lineCov">          2 :         gQUCPU_Uclock.u64i_cmd_reg_1 = ((uint64_t)0x0LLU);</span>
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            :         // Initialize sequence IO
<span class="lineNum">     272 </span><span class="lineCov">          2 :         gQUCPU_Uclock.u64i_AVMM_seq = ((uint64_t)0x0LLU);</span>
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            :         // Static values
<span class="lineNum">     275 </span><span class="lineCov">          2 :         gQUCPU_Uclock.tInitz_InitialParams.u64i_NumFrq_Intg_End =</span>
<span class="lineNum">     276 </span>            :                 (uint64_t)QUCPU_INT_NUMFRQ_INTG_END;
<span class="lineNum">     277 </span><span class="lineCov">          2 :         gQUCPU_Uclock.tInitz_InitialParams.u64i_NumFrq_Frac_Beg =</span>
<span class="lineNum">     278 </span>            :                 (uint64_t)QUCPU_INT_NUMFRQ_FRAC_BEG;
<span class="lineNum">     279 </span><span class="lineCov">          2 :         gQUCPU_Uclock.tInitz_InitialParams.u64i_NumFrq_Frac_End =</span>
<span class="lineNum">     280 </span>            :                 (uint64_t)QUCPU_INT_NUMFRQ_FRAC_END;
<span class="lineNum">     281 </span><span class="lineCov">          2 :         gQUCPU_Uclock.tInitz_InitialParams.u64i_NumFrq =</span>
<span class="lineNum">     282 </span>            :                 (uint64_t)QUCPU_INT_NUMFRQ;
<span class="lineNum">     283 </span><span class="lineCov">          2 :         gQUCPU_Uclock.tInitz_InitialParams.u64i_NumReg =</span>
<span class="lineNum">     284 </span>            :                 (uint64_t)QUCPU_INT_NUMREG;
<span class="lineNum">     285 </span><span class="lineCov">          2 :         gQUCPU_Uclock.tInitz_InitialParams.u64i_NumRck =</span>
<span class="lineNum">     286 </span>            :                 (uint64_t)QUCPU_INT_NUMRCK;
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            :         // Read version number
<span class="lineNum">     290 </span><span class="lineCov">          2 :         if (i_ReturnErr == 0) { // This always true; added for future safety</span>
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            :                 // Verifying User Clock version number
<span class="lineNum">     293 </span><span class="lineCov">          2 :                 snprintf_s_ss(syfs_usrpath, sizeof(syfs_usrpath), &quot;%s/%s&quot;,</span>
<span class="lineNum">     294 </span>            :                               gQUCPU_Uclock.sysfs_path, USER_CLOCK_STS1);
<span class="lineNum">     295 </span><span class="lineCov">          2 :                 sysfs_read_u64(syfs_usrpath, &amp;u64i_PrtData);</span>
<span class="lineNum">     296 </span>            :                 // printf(&quot; fi_RunInitz u64i_PrtData %llx  \n&quot;, u64i_PrtData);
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span><span class="lineCov">          2 :                 gQUCPU_Uclock.tInitz_InitialParams.u64i_Version =</span>
<span class="lineNum">     299 </span><span class="lineCov">          2 :                         (u64i_PrtData &amp; QUCPU_UI64_STS_1_VER_b63t60) &gt;&gt; 60;</span>
<span class="lineNum">     300 </span><span class="lineCov">          2 :                 if ((gQUCPU_Uclock.tInitz_InitialParams.u64i_Version</span>
<span class="lineNum">     301 </span>            :                      != QUCPU_UI64_STS_1_VER_version)
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :                     &amp;&amp; (gQUCPU_Uclock.tInitz_InitialParams.u64i_Version</span>
<span class="lineNum">     303 </span>            :                         != QUCPU_UI64_STS_1_VER_version_legacy)) { // User Clock
<span class="lineNum">     304 </span>            :                                                                    // wrong
<span class="lineNum">     305 </span>            :                                                                    // version
<span class="lineNum">     306 </span>            :                                                                    // number
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :                         i_ReturnErr = QUCPU_INT_UCLOCK_RUNINITZ_ERR_VER;</span>
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            :                 } // User Clock wrong version number
<span class="lineNum">     310 </span>            :         }        // Verifying User Clock version number
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            :         FPGA_DBG(&quot;User clock version = %lx \n&quot;,
<span class="lineNum">     313 </span>            :                  gQUCPU_Uclock.tInitz_InitialParams.u64i_Version);
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            :         // Read PLL ID
<span class="lineNum">     316 </span><span class="lineCov">          2 :         if (i_ReturnErr</span>
<span class="lineNum">     317 </span>            :             == 0) { // Waiting for fcr PLL calibration not to be busy
<span class="lineNum">     318 </span><span class="lineCov">          2 :                 i_ReturnErr = fi_WaitCalDone();</span>
<span class="lineNum">     319 </span>            :         } // Waiting for fcr PLL calibration not to be busy
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span><span class="lineCov">          2 :         if (i_ReturnErr == 0) {</span>
<span class="lineNum">     322 </span>            :                 // Cycle reset and wait for any calibration to finish
<span class="lineNum">     323 </span>            :                 // Activating management &amp; machine reset
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span><span class="lineCov">          2 :                 gQUCPU_Uclock.u64i_cmd_reg_0 |= (QUCPU_UI64_CMD_0_PRS_b56);</span>
<span class="lineNum">     326 </span><span class="lineCov">          2 :                 gQUCPU_Uclock.u64i_cmd_reg_0 &amp;= ~(QUCPU_UI64_CMD_0_MRN_b52);</span>
<span class="lineNum">     327 </span><span class="lineCov">          2 :                 u64i_PrtData = gQUCPU_Uclock.u64i_cmd_reg_0;</span>
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span><span class="lineCov">          2 :                 snprintf_s_ss(syfs_usrpath, sizeof(syfs_usrpath), &quot;%s/%s&quot;,</span>
<span class="lineNum">     330 </span>            :                               gQUCPU_Uclock.sysfs_path, USER_CLOCK_CMD0);
<span class="lineNum">     331 </span><span class="lineCov">          2 :                 sysfs_write_u64(syfs_usrpath, u64i_PrtData);</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            :                 // Deasserting management &amp; machine reset
<span class="lineNum">     334 </span><span class="lineCov">          2 :                 gQUCPU_Uclock.u64i_cmd_reg_0 |= (QUCPU_UI64_CMD_0_MRN_b52);</span>
<span class="lineNum">     335 </span><span class="lineCov">          2 :                 gQUCPU_Uclock.u64i_cmd_reg_0 &amp;= ~(QUCPU_UI64_CMD_0_PRS_b56);</span>
<span class="lineNum">     336 </span><span class="lineCov">          2 :                 u64i_PrtData = gQUCPU_Uclock.u64i_cmd_reg_0;</span>
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span><span class="lineCov">          2 :                 sysfs_write_u64(syfs_usrpath, u64i_PrtData);</span>
<span class="lineNum">     339 </span>            :                 // printf(&quot; fi_RunInitz u64i_PrtData %llx  \n&quot;, u64i_PrtData);
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            :                 // Waiting for fcr PLL calibration not to be busy
<span class="lineNum">     342 </span><span class="lineCov">          2 :                 i_ReturnErr = fi_WaitCalDone();</span>
<span class="lineNum">     343 </span>            :         } // Cycle reset and wait for any calibration to finish
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span><span class="lineCov">          2 :         if (i_ReturnErr == 0) { // Checking fPLL ID</span>
<span class="lineNum">     346 </span><span class="lineCov">          2 :                 u64i_AvmmAdr = QUCPU_UI64_AVMM_FPLL_IPI_200;</span>
<span class="lineNum">     347 </span><span class="lineCov">          2 :                 i_ReturnErr = fi_AvmmRead(u64i_AvmmAdr, &amp;u64i_AvmmDat);</span>
<span class="lineNum">     348 </span><span class="lineCov">          2 :                 if (i_ReturnErr == 0) { // Check identifier</span>
<span class="lineNum">     349 </span><span class="lineCov">          2 :                         gQUCPU_Uclock.tInitz_InitialParams.u64i_PLL_ID =</span>
<span class="lineNum">     350 </span>            :                                 u64i_AvmmDat &amp; 0xffLLU;
<span class="lineNum">     351 </span><span class="lineCov">          2 :                         if (!(gQUCPU_Uclock.tInitz_InitialParams.u64i_PLL_ID</span>
<span class="lineNum">     352 </span>            :                                       == QUCPU_UI64_AVMM_FPLL_IPI_200_IDI_RFDUAL
<span class="lineNum">     353 </span><span class="lineCov">          2 :                               || gQUCPU_Uclock.tInitz_InitialParams.u64i_PLL_ID</span>
<span class="lineNum">     354 </span>            :                                          == QUCPU_UI64_AVMM_FPLL_IPI_200_IDI_RF100M
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :                               || gQUCPU_Uclock.tInitz_InitialParams.u64i_PLL_ID</span>
<span class="lineNum">     356 </span>            :                                          == QUCPU_UI64_AVMM_FPLL_IPI_200_IDI_RF322M)) { // ERROR: Wrong fPLL ID Identifer
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :                                 printf(&quot; ERROR  \n&quot;);</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :                                 i_ReturnErr =</span>
<span class="lineNum">     359 </span>            :                                         QUCPU_INT_UCLOCK_RUNINITZ_ERR_FPLL_ID_ILLEGAL;
<span class="lineNum">     360 </span>            :                         } // ERROR: Wrong fPLL ID Identifer
<span class="lineNum">     361 </span>            :                 }        // Check identifier
<span class="lineNum">     362 </span>            :         }                 // Checking fPLL ID
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            :         // Copy structure, initialize, and return based on error status
<span class="lineNum">     365 </span>            :         //*ptInitz_retInitz = gQUCPU_Uclock.tInitz_InitialParams;
<span class="lineNum">     366 </span><span class="lineCov">          2 :         gQUCPU_Uclock.i_InitzState = !i_ReturnErr; // Set InitzState to 0 or 1</span>
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span><span class="lineCov">          2 :         return i_ReturnErr;</span>
<span class="lineNum">     369 </span>            : } // fi_RunInitz
<a name="370"><span class="lineNum">     370 </span>            : </a>
<span class="lineNum">     371 </span>            : // fu64i_GetAVMM_seq
<span class="lineNum">     372 </span><span class="lineCov">          4 : uint64_t fu64i_GetAVMM_seq()</span>
<span class="lineNum">     373 </span>            : {
<span class="lineNum">     374 </span>            :         // fu64i_GetAVMM_seq
<span class="lineNum">     375 </span>            :         // Increment seq
<span class="lineNum">     376 </span><span class="lineCov">          4 :         gQUCPU_Uclock.u64i_AVMM_seq++;</span>
<span class="lineNum">     377 </span><span class="lineCov">          4 :         gQUCPU_Uclock.u64i_AVMM_seq &amp;= 0x03LLU;</span>
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span><span class="lineCov">          4 :         return gQUCPU_Uclock.u64i_AVMM_seq;</span>
<span class="lineNum">     380 </span>            : } // fu64i_GetAVMM_seq
<span class="lineNum">     381 </span>            : 
<a name="382"><span class="lineNum">     382 </span>            : </a>
<span class="lineNum">     383 </span>            : // fi_AvmmRWcom
<span class="lineNum">     384 </span><span class="lineCov">          4 : int fi_AvmmRWcom(int i_CmdWrite, uint64_t u64i_AvmmAdr, uint64_t u64i_WriteData,</span>
<span class="lineNum">     385 </span>            :                  uint64_t *pu64i_ReadData)
<span class="lineNum">     386 </span>            : {
<span class="lineNum">     387 </span>            :         // fi_AvmmRWcom
<span class="lineNum">     388 </span>            :         uint64_t u64i_SeqCmdAddrData, u64i_SeqCmdAddrData_seq_2,
<span class="lineNum">     389 </span>            :                 u64i_SeqCmdAddrData_wrt_1;
<span class="lineNum">     390 </span>            :         uint64_t u64i_SeqCmdAddrData_adr_10, u64i_SeqCmdAddrData_dat_32;
<span class="lineNum">     391 </span>            :         uint64_t u64i_PrtData;
<span class="lineNum">     392 </span>            :         uint64_t u64i_DataX;
<span class="lineNum">     393 </span>            :         uint64_t u64i_FastPoll, u64i_SlowPoll;
<span class="lineNum">     394 </span>            :         long int li_sleep_nanoseconds;
<span class="lineNum">     395 </span>            :         int i_ReturnErr;
<span class="lineNum">     396 </span>            :         char syfs_usrpath[SYSFS_PATH_MAX];
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            :         // Assume return error okay, for now
<span class="lineNum">     399 </span><span class="lineCov">          4 :         i_ReturnErr = 0;</span>
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            :         // Common portion
<span class="lineNum">     402 </span><span class="lineCov">          4 :         u64i_SeqCmdAddrData_seq_2 = fu64i_GetAVMM_seq();</span>
<span class="lineNum">     403 </span><span class="lineCov">          4 :         u64i_SeqCmdAddrData_adr_10 = u64i_AvmmAdr;</span>
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span><span class="lineCov">          4 :         if (i_CmdWrite == 1) {</span>
<span class="lineNum">     406 </span>            :                 // Write data
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :                 u64i_SeqCmdAddrData_wrt_1 = 0x1LLU;</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :                 u64i_SeqCmdAddrData_dat_32 = u64i_WriteData;</span>
<span class="lineNum">     409 </span>            :         }      // Write data
<span class="lineNum">     410 </span>            :         else { // Read data
<span class="lineNum">     411 </span><span class="lineCov">          4 :                 u64i_SeqCmdAddrData_wrt_1 = 0x0LLU;</span>
<span class="lineNum">     412 </span><span class="lineCov">          4 :                 u64i_SeqCmdAddrData_dat_32 = 0x0LLU;</span>
<span class="lineNum">     413 </span>            :         } // Read data
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span><span class="lineCov">          4 :         u64i_SeqCmdAddrData =</span>
<span class="lineNum">     416 </span><span class="lineCov">          4 :                 (u64i_SeqCmdAddrData_seq_2 &amp; 0x00000003LLU) &lt;&lt; 48    // [49:48]</span>
<span class="lineNum">     417 </span><span class="lineCov">          4 :                 | (u64i_SeqCmdAddrData_wrt_1 &amp; 0x00000001LLU) &lt;&lt; 44  // [   44]</span>
<span class="lineNum">     418 </span><span class="lineCov">          4 :                 | (u64i_SeqCmdAddrData_adr_10 &amp; 0x000003ffLLU) &lt;&lt; 32 // [41:32]</span>
<span class="lineNum">     419 </span><span class="lineCov">          4 :                 | (u64i_SeqCmdAddrData_dat_32 &amp; 0xffffffffLLU) &lt;&lt; 0; // [31:00]</span>
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span><span class="lineCov">          4 :         gQUCPU_Uclock.u64i_cmd_reg_0 &amp;= ~QUCPU_UI64_CMD_0_AMM_b51t00;</span>
<span class="lineNum">     422 </span><span class="lineCov">          4 :         gQUCPU_Uclock.u64i_cmd_reg_0 |= u64i_SeqCmdAddrData;</span>
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span>            :         // Write register 0 to kick it off
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span><span class="lineCov">          4 :         u64i_PrtData = gQUCPU_Uclock.u64i_cmd_reg_0;</span>
<span class="lineNum">     427 </span><span class="lineCov">          4 :         snprintf_s_ss(syfs_usrpath, sizeof(syfs_usrpath), &quot;%s/%s&quot;,</span>
<span class="lineNum">     428 </span>            :                       gQUCPU_Uclock.sysfs_path, USER_CLOCK_CMD0);
<span class="lineNum">     429 </span><span class="lineCov">          4 :         sysfs_write_u64(syfs_usrpath, u64i_PrtData);</span>
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span><span class="lineCov">          4 :         li_sleep_nanoseconds = USRCLK_SLEEEP_1MS;</span>
<span class="lineNum">     432 </span><span class="lineCov">          4 :         fv_SleepShort(li_sleep_nanoseconds);</span>
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span><span class="lineCov">          4 :         snprintf_s_ss(syfs_usrpath, sizeof(syfs_usrpath), &quot;%s/%s&quot;,</span>
<span class="lineNum">     435 </span>            :                       gQUCPU_Uclock.sysfs_path, USER_CLOCK_STS0);
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            :         // Poll register 0 for completion.
<span class="lineNum">     438 </span>            :         // CCI is synchronous and needs only 1 read with matching sequence.
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span><span class="lineCov">        204 :         for (u64i_SlowPoll = 0; u64i_SlowPoll &lt; 100; ++u64i_SlowPoll) { // 100 ms</span>
<span class="lineNum">     441 </span>            :           // Poll 0, slow outer loop with 1 ms sleep
<span class="lineNum">     442 </span><span class="lineCov">      20202 :                 for (u64i_FastPoll = 0; u64i_FastPoll &lt; 100; ++u64i_FastPoll) {</span>
<span class="lineNum">     443 </span>            :                         // Poll 0, fast inner loop with no sleep
<span class="lineNum">     444 </span><span class="lineCov">      20002 :                         sysfs_read_u64(syfs_usrpath, &amp;u64i_DataX);</span>
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span><span class="lineCov">      20002 :                         if ((u64i_DataX &amp; QUCPU_UI64_STS_0_SEQ_b49t48)</span>
<span class="lineNum">     447 </span><span class="lineCov">      20002 :                             == (u64i_SeqCmdAddrData</span>
<span class="lineNum">     448 </span>            :                                 &amp; QUCPU_UI64_STS_0_SEQ_b49t48)) { // Have result
<span class="lineNum">     449 </span><span class="lineCov">          2 :                                 goto GOTO_LABEL_HAVE_RESULT;</span>
<span class="lineNum">     450 </span>            :                         } // Have result
<span class="lineNum">     451 </span>            :                 }        // Poll 0, fast inner loop with no sleep
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span>            :                 // Sleep 1 ms
<span class="lineNum">     454 </span><span class="lineCov">        200 :                 li_sleep_nanoseconds = USRCLK_SLEEEP_1MS;</span>
<span class="lineNum">     455 </span><span class="lineCov">        200 :                 fv_SleepShort(li_sleep_nanoseconds);</span>
<span class="lineNum">     456 </span>            :         } // Poll 0, slow outer loop with 1 ms sleep
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span><span class="lineCov">          2 :         i_ReturnErr = QUCPU_INT_UCLOCK_AVMMRWCOM_ERR_TIMEOUT; // Error</span>
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            : GOTO_LABEL_HAVE_RESULT: // No error
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span><span class="lineCov">          4 :         if (i_CmdWrite == 0)</span>
<span class="lineNum">     463 </span><span class="lineCov">          4 :                 *pu64i_ReadData = u64i_DataX;</span>
<span class="lineNum">     464 </span><span class="lineCov">          4 :         return i_ReturnErr;</span>
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            : } // fi_AvmmRWcom
<span class="lineNum">     467 </span>            : 
<a name="468"><span class="lineNum">     468 </span>            : </a>
<span class="lineNum">     469 </span>            : // fi_AvmmRead
<span class="lineNum">     470 </span><span class="lineCov">          4 : int fi_AvmmRead(uint64_t u64i_AvmmAdr, uint64_t *pu64i_ReadData)</span>
<span class="lineNum">     471 </span>            : {
<span class="lineNum">     472 </span>            :         // fi_AvmmRead
<span class="lineNum">     473 </span><span class="lineCov">          4 :         int i_CmdWrite = 0;</span>
<span class="lineNum">     474 </span><span class="lineCov">          4 :         uint64_t u64i_WriteData = 0;</span>
<span class="lineNum">     475 </span><span class="lineCov">          4 :         int res = 0;</span>
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            :         // Perform read with common code
<span class="lineNum">     478 </span><span class="lineCov">          4 :         i_CmdWrite = 0;</span>
<span class="lineNum">     479 </span><span class="lineCov">          4 :         u64i_WriteData = 0; // Not used for read</span>
<span class="lineNum">     480 </span><span class="lineCov">          4 :         res = fi_AvmmRWcom(i_CmdWrite, u64i_AvmmAdr, u64i_WriteData,</span>
<span class="lineNum">     481 </span>            :                            pu64i_ReadData);
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            :         // Return error status
<span class="lineNum">     484 </span><span class="lineCov">          4 :         return res;</span>
<span class="lineNum">     485 </span>            : } // fi_AvmmRead
<a name="486"><span class="lineNum">     486 </span>            : </a>
<span class="lineNum">     487 </span>            : // fi_AvmmWrite
<span class="lineNum">     488 </span><span class="lineNoCov">          0 : int fi_AvmmWrite(uint64_t u64i_AvmmAdr, uint64_t u64i_WriteData)</span>
<span class="lineNum">     489 </span>            : {
<span class="lineNum">     490 </span>            :         // fi_AvmmWrite
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :         int i_CmdWrite = 0;</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :         uint64_t u64i_ReadData = 0; // Read data is not used</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :         int res = 0;</span>
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            :         // Perform write with common code
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :         i_CmdWrite = 1;</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :         res = fi_AvmmRWcom(i_CmdWrite, u64i_AvmmAdr, u64i_WriteData,</span>
<span class="lineNum">     498 </span>            :                            &amp;u64i_ReadData);
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            :         // Return error status
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :         return res;</span>
<span class="lineNum">     502 </span>            : } // fi_AvmmWrite
<span class="lineNum">     503 </span>            : 
<a name="504"><span class="lineNum">     504 </span>            : </a>
<span class="lineNum">     505 </span>            : // Sleep for nanoseconds
<span class="lineNum">     506 </span><span class="lineCov">        206 : void fv_SleepShort(long int li_sleep_nanoseconds)</span>
<span class="lineNum">     507 </span>            : {
<span class="lineNum">     508 </span>            :         // fv_SleepShort
<span class="lineNum">     509 </span>            :         // Sleep for nanoseconds
<span class="lineNum">     510 </span><span class="lineCov">        206 :         struct timespec timespecRemaining = {0};</span>
<span class="lineNum">     511 </span><span class="lineCov">        206 :         struct timespec timespecWait = {0};</span>
<span class="lineNum">     512 </span><span class="lineCov">        206 :         int res = 0;</span>
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span><span class="lineCov">        206 :         timespecRemaining.tv_nsec = li_sleep_nanoseconds;</span>
<span class="lineNum">     515 </span><span class="lineCov">        206 :         timespecRemaining.tv_sec = 0;</span>
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span>            :         do { // Wait, and retry if wait ended early
<span class="lineNum">     518 </span><span class="lineCov">        206 :                 timespecWait = timespecRemaining;</span>
<span class="lineNum">     519 </span><span class="lineCov">        206 :                 res = (int)nanosleep(&amp;timespecWait, &amp;timespecRemaining);</span>
<span class="lineNum">     520 </span><span class="lineCov">        206 :                 if (res != 0</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :                     &amp;&amp; res != -1) { // BUG: unexpected nanosleep return value</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :                         fv_BugLog((int)QUCPU_INT_UCLOCK_BUG_SLEEP_SHORT);</span>
<span class="lineNum">     523 </span>            :                 } // BUG: unexpected nanosleep return value
<span class="lineNum">     524 </span><span class="lineCov">        206 :         } while (res != 0); // Wait, and retry if wait ended early</span>
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span><span class="lineCov">        206 :         return;</span>
<span class="lineNum">     527 </span>            : } // fv_SleepShort
<span class="lineNum">     528 </span>            : 
<a name="529"><span class="lineNum">     529 </span>            : // get user clock</a>
<span class="lineNum">     530 </span>            : // Read the frequency for the User clock and div2 clock
<span class="lineNum">     531 </span><span class="lineNoCov">          0 : int fi_GetFreqs(QUCPU_tFreqs *ptFreqs_retFreqs)</span>
<span class="lineNum">     532 </span>            : {
<span class="lineNum">     533 </span>            :         // fi_GetFreqs
<span class="lineNum">     534 </span>            :         // Read the frequency for the User clock and div2 clock
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :         uint64_t u64i_PrtData = 0;</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :         long int li_sleep_nanoseconds = 0;</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :         int res = 0;</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :         char syfs_usrpath[SYSFS_PATH_MAX] = {0};</span>
<span class="lineNum">     540 </span>            : 
<span class="lineNum">     541 </span>            :         // Assume return error okay, for now
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :         res = 0;</span>
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :         if (!gQUCPU_Uclock.i_InitzState)</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :                 res = QUCPU_INT_UCLOCK_GETFREQS_ERR_INITZSTATE;</span>
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :         if (res == 0) { // Read div2 and 1x user clock frequency</span>
<span class="lineNum">     548 </span>            :                 // Low frequency
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :                 gQUCPU_Uclock.u64i_cmd_reg_1 &amp;= ~QUCPU_UI64_CMD_1_MEA_b32;</span>
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :                 u64i_PrtData = gQUCPU_Uclock.u64i_cmd_reg_1;</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :                 snprintf_s_ss(syfs_usrpath, sizeof(syfs_usrpath), &quot;%s/%s&quot;,</span>
<span class="lineNum">     553 </span>            :                               gQUCPU_Uclock.sysfs_path, USER_CLOCK_CMD1);
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :                 sysfs_write_u64(syfs_usrpath, u64i_PrtData);</span>
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :                 li_sleep_nanoseconds =</span>
<span class="lineNum">     558 </span>            :                         USRCLK_SLEEEP_10MS; // 10 ms for frequency counter
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :                 fv_SleepShort(li_sleep_nanoseconds);</span>
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :                 snprintf_s_ss(syfs_usrpath, sizeof(syfs_usrpath), &quot;%s/%s&quot;,</span>
<span class="lineNum">     562 </span>            :                               gQUCPU_Uclock.sysfs_path, USER_CLOCK_STS1);
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :                 sysfs_read_u64(syfs_usrpath, &amp;u64i_PrtData);</span>
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span>            : 
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :                 ptFreqs_retFreqs-&gt;u64i_Frq_DivBy2 =</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :                         (u64i_PrtData &amp; QUCPU_UI64_STS_1_FRQ_b16t00)</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :                         * 10000; // Hz</span>
<span class="lineNum">     569 </span>            :                 // printf(&quot; ptFreqs_retFreqs-&gt;u64i_Frq_ClkUsr %llx \n&quot;,
<span class="lineNum">     570 </span>            :                 // ptFreqs_retFreqs-&gt;u64i_Frq_DivBy2);
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :                 li_sleep_nanoseconds = USRCLK_SLEEEP_10MS;</span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :                 fv_SleepShort(li_sleep_nanoseconds);</span>
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span>            :                 // High frequency
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :                 gQUCPU_Uclock.u64i_cmd_reg_1 |= QUCPU_UI64_CMD_1_MEA_b32;</span>
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :                 u64i_PrtData = gQUCPU_Uclock.u64i_cmd_reg_1;</span>
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :                 snprintf_s_ss(syfs_usrpath, sizeof(syfs_usrpath), &quot;%s/%s&quot;,</span>
<span class="lineNum">     580 </span>            :                               gQUCPU_Uclock.sysfs_path, USER_CLOCK_CMD1);
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :                 sysfs_write_u64(syfs_usrpath, u64i_PrtData);</span>
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :                 li_sleep_nanoseconds =</span>
<span class="lineNum">     584 </span>            :                         USRCLK_SLEEEP_10MS; // 10 ms for frequency counter
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :                 fv_SleepShort(li_sleep_nanoseconds);</span>
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :                 snprintf_s_ss(syfs_usrpath, sizeof(syfs_usrpath), &quot;%s/%s&quot;,</span>
<span class="lineNum">     588 </span>            :                               gQUCPU_Uclock.sysfs_path, USER_CLOCK_STS1);
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :                 sysfs_read_u64(syfs_usrpath, &amp;u64i_PrtData);</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :                 ptFreqs_retFreqs-&gt;u64i_Frq_ClkUsr =</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :                         (u64i_PrtData &amp; QUCPU_UI64_STS_1_FRQ_b16t00)</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :                         * 10000; // Hz</span>
<span class="lineNum">     593 </span>            :                 // printf(&quot; ptFreqs_retFreqs-&gt;u64i_Frq_ClkUsr %llx \n&quot;,
<span class="lineNum">     594 </span>            :                 // ptFreqs_retFreqs-&gt;u64i_Frq_ClkUsr);
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :                 fv_SleepShort(li_sleep_nanoseconds);</span>
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            :         } // Read div2 and 1x user clock frequency
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span>            :         FPGA_DBG(
<span class="lineNum">     601 </span>            :                 &quot;\nApproximate frequency:\n&quot;
<span class="lineNum">     602 </span>            :                 &quot;High clock = %5.1f MHz\n&quot;
<span class="lineNum">     603 </span>            :                 &quot;Low clock  = %5.1f MHz\n \n&quot;,
<span class="lineNum">     604 </span>            :                 ptFreqs_retFreqs-&gt;u64i_Frq_ClkUsr / 1.0e6,
<span class="lineNum">     605 </span>            :                 (ptFreqs_retFreqs-&gt;u64i_Frq_DivBy2) / 1.0e6);
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :         return res;</span>
<span class="lineNum">     609 </span>            : } // fi_GetFreqs
<a name="610"><span class="lineNum">     610 </span>            : </a>
<span class="lineNum">     611 </span>            : // set user clock
<span class="lineNum">     612 </span><span class="lineCov">          2 : int fi_SetFreqs(uint64_t u64i_Refclk, uint64_t u64i_FrqInx)</span>
<span class="lineNum">     613 </span>            : {
<span class="lineNum">     614 </span>            :         // fi_SetFreqs
<span class="lineNum">     615 </span>            :         // Set the user clock frequency
<span class="lineNum">     616 </span>            :         uint64_t u64i_I, u64i_MifReg, u64i_PrtData;
<span class="lineNum">     617 </span>            :         uint64_t u64i_AvmmAdr, u64i_AvmmDat, u64i_AvmmMsk;
<span class="lineNum">     618 </span>            :         long int li_sleep_nanoseconds;
<span class="lineNum">     619 </span>            :         int i_ReturnErr;
<span class="lineNum">     620 </span>            :         char syfs_usrpath[SYSFS_PATH_MAX];
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span>            :         // Assume return error okay, for now
<span class="lineNum">     623 </span><span class="lineCov">          2 :         i_ReturnErr = 0;</span>
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span><span class="lineCov">          2 :         if (!gQUCPU_Uclock.i_InitzState)</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :                 i_ReturnErr = QUCPU_INT_UCLOCK_SETFREQS_ERR_INITZSTATE;</span>
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span><span class="lineCov">          2 :         if (i_ReturnErr == 0) {         // Check REFCLK</span>
<span class="lineNum">     629 </span><span class="lineCov">          2 :                 if (u64i_Refclk == 0) { // 100 MHz REFCLK requested</span>
<span class="lineNum">     630 </span><span class="lineCov">          4 :                         if (!(gQUCPU_Uclock.tInitz_InitialParams.u64i_PLL_ID</span>
<span class="lineNum">     631 </span>            :                                       == QUCPU_UI64_AVMM_FPLL_IPI_200_IDI_RFDUAL
<span class="lineNum">     632 </span><span class="lineCov">          2 :                               || gQUCPU_Uclock.tInitz_InitialParams.u64i_PLL_ID</span>
<span class="lineNum">     633 </span>            :                                          == QUCPU_UI64_AVMM_FPLL_IPI_200_IDI_RF100M))
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :                                 i_ReturnErr =</span>
<span class="lineNum">     635 </span>            :                                         QUCPU_INT_UCLOCK_SETFREQS_ERR_REFCLK_100M_MISSING;
<span class="lineNum">     636 </span>            :                 }                            // 100 MHz REFCLK requested
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :                 else if (u64i_Refclk == 1) { // 322.265625 MHz REFCLK requested</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :                         if (!(gQUCPU_Uclock.tInitz_InitialParams.u64i_PLL_ID</span>
<span class="lineNum">     639 </span>            :                                       == QUCPU_UI64_AVMM_FPLL_IPI_200_IDI_RFDUAL
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :                               || gQUCPU_Uclock.tInitz_InitialParams.u64i_PLL_ID</span>
<span class="lineNum">     641 </span>            :                                          == QUCPU_UI64_AVMM_FPLL_IPI_200_IDI_RF322M))
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :                                 i_ReturnErr =</span>
<span class="lineNum">     643 </span>            :                                         QUCPU_INT_UCLOCK_SETFREQS_ERR_REFCLK_322M_MISSING;
<span class="lineNum">     644 </span>            :                 } // 322.265625 MHz REFCLK requested
<span class="lineNum">     645 </span>            :                 else
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :                         i_ReturnErr =</span>
<span class="lineNum">     647 </span>            :                                 QUCPU_INT_UCLOCK_SETFREQS_ERR_REFCLK_ILLEGAL;
<span class="lineNum">     648 </span>            :         } // Check REFCLK
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span><span class="lineCov">          2 :         if (i_ReturnErr == 0) { // Check frequency index</span>
<span class="lineNum">     651 </span><span class="lineCov">          2 :                 if (u64i_FrqInx</span>
<span class="lineNum">     652 </span><span class="lineCov">          2 :                     &gt; gQUCPU_Uclock.tInitz_InitialParams.u64i_NumFrq_Frac_End)</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :                         i_ReturnErr =</span>
<span class="lineNum">     654 </span>            :                                 QUCPU_INT_UCLOCK_SETFREQS_ERR_FINDEX_OVERRANGE;
<span class="lineNum">     655 </span><span class="lineCov">          2 :                 else if (u64i_FrqInx &lt; gQUCPU_Uclock.tInitz_InitialParams</span>
<span class="lineNum">     656 </span><span class="lineCov">          2 :                                                .u64i_NumFrq_Frac_Beg</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :                          &amp;&amp; u64i_FrqInx &gt; gQUCPU_Uclock.tInitz_InitialParams</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :                                                   .u64i_NumFrq_Intg_End)</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :                         i_ReturnErr =</span>
<span class="lineNum">     660 </span>            :                                 QUCPU_INT_UCLOCK_SETFREQS_ERR_FINDEX_INTG_RANGE_BAD;
<span class="lineNum">     661 </span><span class="lineCov">          2 :                 else if (u64i_FrqInx &lt; gQUCPU_Uclock.tInitz_InitialParams</span>
<span class="lineNum">     662 </span><span class="lineCov">          2 :                                                .u64i_NumFrq_Frac_Beg</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :                          &amp;&amp; u64i_Refclk != 1) // Integer-PLL mode, exact</span>
<span class="lineNum">     664 </span>            :                                               // requires 322.265625 MHz
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :                         i_ReturnErr =</span>
<span class="lineNum">     666 </span>            :                                 QUCPU_INT_UCLOCK_SETFREQS_ERR_FINDEX_INTG_NEEDS_322M;
<span class="lineNum">     667 </span>            :         } // Check frequency index
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span><span class="lineCov">          2 :         if (i_ReturnErr == 0) { // Power down PLL</span>
<span class="lineNum">     671 </span>            :                 // Altera bug. Power down pin doesn't work  SR #11229652.
<span class="lineNum">     672 </span>            :                 // WORKAROUND: Use power down port
<span class="lineNum">     673 </span><span class="lineCov">          2 :                 u64i_AvmmAdr = 0x2e0LLU;</span>
<span class="lineNum">     674 </span><span class="lineCov">          2 :                 u64i_AvmmDat = 0x03LLU;</span>
<span class="lineNum">     675 </span><span class="lineCov">          2 :                 u64i_AvmmMsk = 0x03LLU;</span>
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span><span class="lineCov">          2 :                 i_ReturnErr = fi_AvmmReadModifyWriteVerify(</span>
<span class="lineNum">     678 </span>            :                         u64i_AvmmAdr, u64i_AvmmDat, u64i_AvmmMsk);
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span>            :                 // Sleep 1 ms
<span class="lineNum">     681 </span><span class="lineCov">          2 :                 li_sleep_nanoseconds = USRCLK_SLEEEP_1MS;</span>
<span class="lineNum">     682 </span><span class="lineCov">          2 :                 fv_SleepShort(li_sleep_nanoseconds);</span>
<span class="lineNum">     683 </span>            :         } // Power down PLL
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span><span class="lineCov">          2 :         if (i_ReturnErr == 0) { // Verifying fcr PLL not locking</span>
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :                 snprintf_s_ss(syfs_usrpath, sizeof(syfs_usrpath), &quot;%s/%s&quot;,</span>
<span class="lineNum">     688 </span>            :                               gQUCPU_Uclock.sysfs_path, USER_CLOCK_STS0);
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :                 sysfs_read_u64(syfs_usrpath, &amp;u64i_PrtData);</span>
<span class="lineNum">     690 </span>            :                 // sysfs_read_uint64(gQUCPU_Uclock.sys_path, USER_CLOCK_STS0,
<span class="lineNum">     691 </span>            :                 // &amp;u64i_PrtData);
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :                 if ((u64i_PrtData &amp; QUCPU_UI64_STS_0_LCK_b60)</span>
<span class="lineNum">     694 </span>            :                     != 0) { // fcr PLL is locked but should be unlocked
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :                         i_ReturnErr =</span>
<span class="lineNum">     696 </span>            :                                 QUCPU_INT_UCLOCK_SETFREQS_ERR_PLL_NO_UNLOCK;
<span class="lineNum">     697 </span>            :                 } // fcr PLL is locked but should be unlocked
<span class="lineNum">     698 </span>            :         }        // Verifying fcr PLL not locking
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span><span class="lineCov">          2 :         if (i_ReturnErr == 0) { // Select reference and push table</span>
<span class="lineNum">     701 </span>            :                 // Selecting desired reference clock
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :                 gQUCPU_Uclock.u64i_cmd_reg_0 &amp;= ~QUCPU_UI64_CMD_0_SR1_b58;</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :                 if (u64i_Refclk)</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :                         gQUCPU_Uclock.u64i_cmd_reg_0 |=</span>
<span class="lineNum">     705 </span>            :                                 QUCPU_UI64_CMD_0_SR1_b58;
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :                 u64i_PrtData = gQUCPU_Uclock.u64i_cmd_reg_0;</span>
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :                 snprintf_s_ss(syfs_usrpath, sizeof(syfs_usrpath), &quot;%s/%s&quot;,</span>
<span class="lineNum">     709 </span>            :                               gQUCPU_Uclock.sysfs_path, USER_CLOCK_CMD0);
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :                 sysfs_write_u64(syfs_usrpath, u64i_PrtData);</span>
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span>            :                 // Sleep 1 ms
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :                 li_sleep_nanoseconds = USRCLK_SLEEEP_1MS;</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :                 fv_SleepShort(li_sleep_nanoseconds);</span>
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            :                 // Pushing the table
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :                 for (u64i_MifReg = 0;</span>
<span class="lineNum">     718 </span>            :                      u64i_MifReg
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :                      &lt; gQUCPU_Uclock.tInitz_InitialParams.u64i_NumReg;</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :                      u64i_MifReg++) { // Write each register in the diff mif</span>
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            :                         uint32_t tbl_entry;
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :                         if (u64i_Refclk == 0) { // 100 MHz table</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :                                 tbl_entry =</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :                                         scu32ia3d_DiffMifTbl[(int)u64i_FrqInx]</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :                                                             [(int)u64i_MifReg]</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :                                                             [(int)u64i_Refclk];</span>
<span class="lineNum">     728 </span>            :                         } else { // 322.265625 MHz table
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :                                 tbl_entry = scu32ia3d_DiffMifTbl_322</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :                                         [(int)u64i_FrqInx][(int)u64i_MifReg]</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :                                         [(int)u64i_Refclk];</span>
<span class="lineNum">     732 </span>            :                         }
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :                         u64i_AvmmAdr = (uint64_t)(tbl_entry) &gt;&gt; 16;</span>
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :                         u64i_AvmmDat = (uint64_t)(tbl_entry &amp; 0x000000ff);</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :                         u64i_AvmmMsk = (uint64_t)(tbl_entry &amp; 0x0000ff00) &gt;&gt; 8;</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :                         i_ReturnErr = fi_AvmmReadModifyWriteVerify(</span>
<span class="lineNum">     738 </span>            :                                 u64i_AvmmAdr, u64i_AvmmDat, u64i_AvmmMsk);
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :                         if (i_ReturnErr)</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">     742 </span>            :                 } // Write each register in the diff mif
<span class="lineNum">     743 </span>            :         }        // Select reference and push table
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span><span class="lineCov">          2 :         if (i_ReturnErr</span>
<span class="lineNum">     746 </span>            :             == 0) { // Waiting for fcr PLL calibration not to be busy
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :                 i_ReturnErr = fi_WaitCalDone();</span>
<span class="lineNum">     748 </span>            :         } // Waiting for fcr PLL calibration not to be busy
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span><span class="lineCov">          2 :         if (i_ReturnErr == 0) { // Recalibrating</span>
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span>            :                 // &quot;Request user access to the internal configuration bus&quot;
<span class="lineNum">     753 </span>            :                 // and &quot;Wait for reconfig_waitrequest to be deasserted.&quot;
<span class="lineNum">     754 </span>            :                 // Note that the Verify operation performs the post &quot;wait.&quot;
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :                 u64i_AvmmAdr = 0x000LLU;</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :                 u64i_AvmmDat = 0x02LLU;</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :                 u64i_AvmmMsk = 0xffLLU;</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :                 i_ReturnErr = fi_AvmmReadModifyWriteVerify(</span>
<span class="lineNum">     760 </span>            :                         u64i_AvmmAdr, u64i_AvmmDat, u64i_AvmmMsk);
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :                 if (i_ReturnErr == 0) { // &quot;To calibrate the fPLL,</span>
<span class="lineNum">     763 </span>            :                                         // Read-Modify-Write:&quot; set B1 of 0x100
<span class="lineNum">     764 </span>            :                                         // high
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :                         u64i_AvmmAdr = 0x100LLU;</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :                         u64i_AvmmDat = 0x02LLU;</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :                         u64i_AvmmMsk = 0x02LLU;</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :                         i_ReturnErr = fi_AvmmReadModifyWrite(</span>
<span class="lineNum">     769 </span>            :                                 u64i_AvmmAdr, u64i_AvmmDat, u64i_AvmmMsk);
<span class="lineNum">     770 </span>            :                 } // &quot;To calibrate the fPLL, Read-Modify-Write:&quot; set B1 of 0x100
<span class="lineNum">     771 </span>            :                   // high
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :                 if (i_ReturnErr == 0) { // &quot;Release the internal configuraiton</span>
<span class="lineNum">     774 </span>            :                                         // bus to PreSICE to perform
<span class="lineNum">     775 </span>            :                                         // recalibration&quot;
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :                         u64i_AvmmAdr = 0x000LLU;</span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :                         u64i_AvmmDat = 0x01LLU;</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :                         i_ReturnErr = fi_AvmmWrite(u64i_AvmmAdr, u64i_AvmmDat);</span>
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span>            :                         // Sleep 1 ms
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :                         li_sleep_nanoseconds = USRCLK_SLEEEP_1MS;</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :                         fv_SleepShort(li_sleep_nanoseconds);</span>
<span class="lineNum">     783 </span>            :                 } // &quot;Release the internal configuraiton bus to PreSICE to
<span class="lineNum">     784 </span>            :                   // perform recalibration&quot;
<span class="lineNum">     785 </span>            :         }        // Recalibrating
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span><span class="lineCov">          2 :         if (i_ReturnErr</span>
<span class="lineNum">     788 </span>            :             == 0) { // Waiting for fcr PLL calibration not to be busy
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :                 i_ReturnErr = fi_WaitCalDone();</span>
<span class="lineNum">     790 </span>            :         } // Waiting for fcr PLL calibration not to be busy
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span><span class="lineCov">          2 :         if (i_ReturnErr == 0) { // Power up PLL</span>
<span class="lineNum">     793 </span>            :                 // Altera bug. Power down pin doesn't work  SR #11229652.
<span class="lineNum">     794 </span>            :                 // WORKAROUND: Use power down port
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :                 u64i_AvmmAdr = 0x2e0LLU;</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :                 u64i_AvmmDat = 0x02LLU;</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :                 u64i_AvmmMsk = 0x03LLU;</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :                 i_ReturnErr = fi_AvmmReadModifyWriteVerify(</span>
<span class="lineNum">     799 </span>            :                         u64i_AvmmAdr, u64i_AvmmDat, u64i_AvmmMsk);
<span class="lineNum">     800 </span>            :         } // Power up PLL
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span><span class="lineCov">          2 :         if (i_ReturnErr == 0) { // Wait for PLL to lock</span>
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :                 for (u64i_I = 0; u64i_I &lt; 100;</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :                      u64i_I++) { // Poll with 100 ms timeout</span>
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :                         snprintf_s_ss(syfs_usrpath, sizeof(syfs_usrpath),</span>
<span class="lineNum">     808 </span>            :                                       &quot;%s/%s&quot;, gQUCPU_Uclock.sysfs_path,
<span class="lineNum">     809 </span>            :                                       USER_CLOCK_STS0);
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :                         sysfs_read_u64(syfs_usrpath, &amp;u64i_PrtData);</span>
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :                         if ((u64i_PrtData &amp; QUCPU_UI64_STS_0_LCK_b60) != 0)</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span>            :                         // Sleep 1 ms
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :                         li_sleep_nanoseconds = USRCLK_SLEEEP_1MS;</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :                         fv_SleepShort(li_sleep_nanoseconds);</span>
<span class="lineNum">     818 </span>            :                 } // Poll with 100 ms timeout
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :                 if ((u64i_PrtData &amp; QUCPU_UI64_STS_0_LCK_b60)</span>
<span class="lineNum">     821 </span>            :                     == 0) { // fcr PLL lock error
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :                         i_ReturnErr = QUCPU_INT_UCLOCK_SETFREQS_ERR_PLL_LOCK_TO;</span>
<span class="lineNum">     824 </span>            :                 } // fcr PLL lock error
<span class="lineNum">     825 </span>            :         }        // Verifying fcr PLL is locking
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span><span class="lineCov">          2 :         return i_ReturnErr;</span>
<span class="lineNum">     828 </span>            : } // fi_SetFreqs
<span class="lineNum">     829 </span>            : 
<a name="830"><span class="lineNum">     830 </span>            : // get error message</a>
<span class="lineNum">     831 </span>            : // Read the frequency for the User clock and div2 clock
<span class="lineNum">     832 </span><span class="lineCov">          5 : const char *fpac_GetErrMsg(int i_ErrMsgInx)</span>
<span class="lineNum">     833 </span>            : {
<span class="lineNum">     834 </span>            :         // fpac_GetErrMsg
<span class="lineNum">     835 </span>            :         // Read the frequency for the User clock and div2 clock
<span class="lineNum">     836 </span><span class="lineCov">          5 :         const char *pac_ErrMsgStr = NULL;</span>
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span>            :         // Extra &quot;+1&quot; message has index range error message
<span class="lineNum">     839 </span><span class="lineCov">          5 :         pac_ErrMsgStr =</span>
<span class="lineNum">     840 </span>            :                 pac_UclockErrorMsg[QUCPU_INT_UCLOCK_NUM_ERROR_MESSAGES + 1 - 1];
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span>            :         // Check index range
<span class="lineNum">     843 </span><span class="lineCov">          5 :         if (i_ErrMsgInx &gt;= 0</span>
<span class="lineNum">     844 </span><span class="lineCov">          4 :             &amp;&amp; i_ErrMsgInx &lt; QUCPU_INT_UCLOCK_NUM_ERROR_MESSAGES) {</span>
<span class="lineNum">     845 </span>            :                 // All okay, set the message string
<span class="lineNum">     846 </span><span class="lineCov">          2 :                 pac_ErrMsgStr = pac_UclockErrorMsg[i_ErrMsgInx];</span>
<span class="lineNum">     847 </span>            :         } // All okay, set the message string
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span><span class="lineCov">          5 :         return pac_ErrMsgStr;</span>
<span class="lineNum">     850 </span>            : } // fpac_GetErrMsg
<a name="851"><span class="lineNum">     851 </span>            : </a>
<span class="lineNum">     852 </span>            : // fi_AvmmReadModifyWriteVerify
<span class="lineNum">     853 </span><span class="lineCov">          2 : int fi_AvmmReadModifyWriteVerify(uint64_t u64i_AvmmAdr, uint64_t u64i_AvmmDat,</span>
<span class="lineNum">     854 </span>            :                                  uint64_t u64i_AvmmMsk)
<span class="lineNum">     855 </span>            : {
<span class="lineNum">     856 </span>            :         // fi_AvmmReadModifyWriteVerify
<span class="lineNum">     857 </span><span class="lineCov">          2 :         int res = 0;</span>
<span class="lineNum">     858 </span><span class="lineCov">          2 :         uint64_t u64i_VerifyData = 0;</span>
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span><span class="lineCov">          2 :         res = fi_AvmmReadModifyWrite(u64i_AvmmAdr, u64i_AvmmDat, u64i_AvmmMsk);</span>
<span class="lineNum">     861 </span>            : 
<span class="lineNum">     862 </span><span class="lineCov">          2 :         if (res == 0) { // Read back the data and verify mask-enabled bits</span>
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :                 res = fi_AvmmRead(u64i_AvmmAdr, &amp;u64i_VerifyData);</span>
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :                 if (res == 0) { // Perform verify</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :                         if ((u64i_VerifyData &amp; u64i_AvmmMsk)</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :                             != (u64i_AvmmDat</span>
<span class="lineNum">     869 </span>            :                                 &amp; u64i_AvmmMsk)) { // Verify failure
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :                                 res = QUCPU_INT_UCLOCK_AVMMRMWV_ERR_VERIFY;</span>
<span class="lineNum">     871 </span>            :                         } // Verify failure
<span class="lineNum">     872 </span>            :                 }        // Perform verify
<span class="lineNum">     873 </span>            :         }                 // Read back the data and verify mask-enabled bits
<span class="lineNum">     874 </span>            : 
<span class="lineNum">     875 </span><span class="lineCov">          2 :         return res;</span>
<span class="lineNum">     876 </span>            : } // fi_AvmmReadModifyWriteVerify
<span class="lineNum">     877 </span>            : 
<a name="878"><span class="lineNum">     878 </span>            : </a>
<span class="lineNum">     879 </span>            : // fi_AvmmReadModifyWrite
<span class="lineNum">     880 </span><span class="lineCov">          2 : int fi_AvmmReadModifyWrite(uint64_t u64i_AvmmAdr, uint64_t u64i_AvmmDat,</span>
<span class="lineNum">     881 </span>            :                            uint64_t u64i_AvmmMsk)
<span class="lineNum">     882 </span>            : {
<span class="lineNum">     883 </span><span class="lineCov">          2 :         uint64_t u64i_ReadData = 0;</span>
<span class="lineNum">     884 </span><span class="lineCov">          2 :         uint64_t u64i_WriteData = 0;</span>
<span class="lineNum">     885 </span><span class="lineCov">          2 :         int res = 0;</span>
<span class="lineNum">     886 </span>            : 
<span class="lineNum">     887 </span>            :         // Read data
<span class="lineNum">     888 </span><span class="lineCov">          2 :         res = fi_AvmmRead(u64i_AvmmAdr, &amp;u64i_ReadData);</span>
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span><span class="lineCov">          2 :         if (res == 0) { // Modify the read data and write it</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :                 u64i_WriteData = (u64i_ReadData &amp; ~u64i_AvmmMsk)</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :                                  | (u64i_AvmmDat &amp; u64i_AvmmMsk);</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :                 res = fi_AvmmWrite(u64i_AvmmAdr, u64i_WriteData);</span>
<span class="lineNum">     894 </span>            :         } // Modify the read data and write it
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span><span class="lineCov">          2 :         return res;</span>
<span class="lineNum">     897 </span>            : } // fi_AvmmReadModifyWrite
<span class="lineNum">     898 </span>            : 
<a name="899"><span class="lineNum">     899 </span>            : // fv_BugLog</a>
<span class="lineNum">     900 </span>            : // Logs first and last bugs
<span class="lineNum">     901 </span><span class="lineCov">          2 : void fv_BugLog(int i_BugID)</span>
<span class="lineNum">     902 </span>            : {
<span class="lineNum">     903 </span><span class="lineCov">          2 :         if (gQUCPU_Uclock.i_Bug_First) { // This is not the first bug</span>
<span class="lineNum">     904 </span><span class="lineCov">          1 :                 gQUCPU_Uclock.i_Bug_Last = i_BugID;</span>
<span class="lineNum">     905 </span>            :         }      // This is not the first bug
<span class="lineNum">     906 </span>            :         else { // This is the first bug
<span class="lineNum">     907 </span><span class="lineCov">          1 :                 gQUCPU_Uclock.i_Bug_First = i_BugID;</span>
<span class="lineNum">     908 </span>            :         } // This is the first bug
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span><span class="lineCov">          2 :         return;</span>
<span class="lineNum">     911 </span>            : } // fv_BugLog
<span class="lineNum">     912 </span>            : 
<a name="913"><span class="lineNum">     913 </span>            : // wait caldone</a>
<span class="lineNum">     914 </span>            : // Wait for calibration to be done
<span class="lineNum">     915 </span><span class="lineCov">          4 : int fi_WaitCalDone(void)</span>
<span class="lineNum">     916 </span>            : {
<span class="lineNum">     917 </span>            :         // fi_WaitCalDone
<span class="lineNum">     918 </span>            :         // Wait for calibration to be done
<span class="lineNum">     919 </span><span class="lineCov">          4 :         uint64_t u64i_PrtData = 0;</span>
<span class="lineNum">     920 </span><span class="lineCov">          4 :         uint64_t u64i_I = 0;</span>
<span class="lineNum">     921 </span><span class="lineCov">          4 :         long int li_sleep_nanoseconds = 0;</span>
<span class="lineNum">     922 </span><span class="lineCov">          4 :         int res = 0;</span>
<span class="lineNum">     923 </span><span class="lineCov">          4 :         char syfs_usrpath[SYSFS_PATH_MAX] = {0};</span>
<span class="lineNum">     924 </span>            : 
<span class="lineNum">     925 </span>            :         // Waiting for fcr PLL calibration not to be busy
<span class="lineNum">     926 </span><span class="lineCov">          4 :         for (u64i_I = 0; u64i_I &lt; 1000; u64i_I++) { // Poll with 1000 ms timeout</span>
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span><span class="lineCov">          4 :                 snprintf_s_ss(syfs_usrpath, sizeof(syfs_usrpath), &quot;%s/%s&quot;,</span>
<span class="lineNum">     929 </span>            :                               gQUCPU_Uclock.sysfs_path, USER_CLOCK_STS0);
<span class="lineNum">     930 </span><span class="lineCov">          4 :                 sysfs_read_u64(syfs_usrpath, &amp;u64i_PrtData);</span>
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span><span class="lineCov">          4 :                 if ((u64i_PrtData &amp; QUCPU_UI64_STS_0_BSY_b61) == 0)</span>
<span class="lineNum">     933 </span><span class="lineCov">          4 :                         break;</span>
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            :                 // Sleep 1 ms
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :                 li_sleep_nanoseconds = USRCLK_SLEEEP_1MS;</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :                 fv_SleepShort(li_sleep_nanoseconds);</span>
<span class="lineNum">     938 </span>            :         } // Poll with 1000 ms timeout
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span><span class="lineCov">          4 :         if ((u64i_PrtData &amp; QUCPU_UI64_STS_0_BSY_b61)</span>
<span class="lineNum">     942 </span>            :             != 0) { // ERROR: calibration busy too long
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :                 res = QUCPU_INT_UCLOCK_WAITCALDONE_ERR_BSY_TO;</span>
<span class="lineNum">     944 </span>            :         } // ERROR: calibration busy too long
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span><span class="lineCov">          4 :         return res;</span>
<span class="lineNum">     947 </span>            : } // fi_WaitCalDone
<span class="lineNum">     948 </span>            : 
<a name="949"><span class="lineNum">     949 </span>            : // Determine whether or not the IOPLL is serving as the source of</a>
<span class="lineNum">     950 </span>            : // the user clock.
<span class="lineNum">     951 </span><span class="lineCov">          3 : STATIC int using_iopll(char *sysfs_usrpath, const char *sysfs_path)</span>
<span class="lineNum">     952 </span>            : {
<span class="lineNum">     953 </span>            :         glob_t iopll_glob;
<span class="lineNum">     954 </span>            : 
<span class="lineNum">     955 </span>            :         // Test for the existence of the userclk_frequency file
<span class="lineNum">     956 </span>            :         // which indicates an S10 driver
<span class="lineNum">     957 </span><span class="lineCov">          3 :         snprintf_s_ss(sysfs_usrpath, SYSFS_PATH_MAX, &quot;%s/%s&quot;, sysfs_path,</span>
<span class="lineNum">     958 </span>            :                       IOPLL_CLOCK_FREQ);
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span><span class="lineCov">          3 :         if (glob(sysfs_usrpath, 0, NULL, &amp;iopll_glob))</span>
<span class="lineNum">     961 </span><span class="lineCov">          3 :                 return FPGA_NOT_FOUND;</span>
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :         if (iopll_glob.gl_pathc &gt; 1)</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :                 FPGA_MSG(&quot;WARNING: Port has multiple sysfs frequency files&quot;);</span>
<span class="lineNum">     965 </span>            : 
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :         strncpy(sysfs_usrpath, iopll_glob.gl_pathv[0], SYSFS_PATH_MAX);</span>
<span class="lineNum">     967 </span>            : 
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :         globfree(&amp;iopll_glob);</span>
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :         if (access(sysfs_usrpath, F_OK | R_OK | W_OK) != 0) {</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :                 FPGA_ERR(&quot;Unable to access sysfs frequency file&quot;);</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :                 return FPGA_NO_ACCESS;</span>
<span class="lineNum">     973 </span>            :         }
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :         return FPGA_OK;</span>
<span class="lineNum">     976 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
